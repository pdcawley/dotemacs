#+TITLE: IDO Setup
#+OPTIONS: toc:nil num:nil

* Load IDO Mode
:PROPERTIES:
:noweb-ref: ido-mode
:END:

** Bindings                                                          :drill:
:PROPERTIES:
:noweb-ref: ido-mode-bindings
:END:
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes
("C-x 5 t" . ido-switch-buffer-tiny-frame)
#+END_SRC

** Initialization
:PROPERTIES:
:noweb-ref: ido-mode-init
:END:
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes
  (setq ido-show-dot-for-dired t)
  (ido-mode 'all)
#+END_SRC

** Configuration
:PROPERTIES:
:noweb-ref: ido-mode-config
:END:

*** Load Subsidiary packages
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes
  (use-package ido-complete-space-or-hyphen
    :config
    (ido-complete-space-or-hyphen-enable))
  
  (use-package ido-hacks
    :init
    (ido-hacks-mode 1))
  
  (use-package ido-springboard)
#+END_SRC

*** Another way of selecting the current completed item

I got this from John Wiegley's config, but found that not descending into
directories drove me up the wall, so it's not currently hooked in.

#+BEGIN_SRC emacs-lisp :tangle no :noweb yes
  (defun ido-smart-select-text ()
    "Select the current completed item. Do NOT descend into directories."
    (interactive)
    (when (and (or (not ido-require-match)
                   (if (memq ido-require-match
                             '(confirm confirm-after-completion))
                       (if (or (eq ido-cur-item 'dir)
                               (eq last-command this-command))
                           t
                         (setq ido-show-confirm-message t)
                         nil))
                   (ido-existing-item-p))
               (not ido-incomplete-regexp))
      (when ido-current-directory
        (setq ido-exit 'takeprompt)
        (unless (and ido-text (= 0 (length ido-text)))
          (let ((match (ido-name (car ido-matches))))
            (throw 'ido
                   (setq ido-selected
                         (if match
                             (replace-regexp-in-string "/\\'" "" match)
                           ido-text)
                         ido-text ido-selected
                         ido-final-text ido-text)))))
      (exit-minibuffer)))
  
  ;; (add-hook 'ido-minibuffer-setup-hook
  ;;           #'(lambda ()
  ;;               (bind-key "<return>" 'ido-smart-select-text
  ;;                         ido-file-completion-map)))
  
#+END_SRC

*** Switch to a buffer in a tiny frame
Haven't actually used this yet. Again, from John Wiegley.
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes
  (defun ido-switch-buffer-tiny-frame (buffer)
    (interactive (list (ido-read-buffer "Buffer: " nil t)))
    (with-selected-frame
        (make-frame '((width                . 80)
                      (height               . 22)
                      (left-fringe          . 0)
                      (right-fringe         . 0)
                      (vertical-scroll-bars . nil)
                      (unsplittable         . t)
                      (has-modeline-p       . nil)
                      (minibuffer           . nil)))
      (switch-to-buffer buffer)
      (set (make-local-variable 'mode-line-format) nil)))
#+END_SRC

** Autoloads
:PROPERTIES:
:noweb-ref: ido-mode-defines
:END:
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes
  (ido-cur-item
   ido-require-match
   ido-selected
   ido-final-text
   ido-show-confirm-message
   ido-show-dot-for-dired)
#+END_SRC


** Template
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes
  (eval `(use-package ido
       ,@(cl-loop
          for forms in '((:if         
 <<ido-mode-if>>)
                         (:load-path   
<<ido-mode-load-path>>)
                         (:bind        
<<ido-mode-bindings>>)
                         (:diminish
<<ido-mode-diminish>>)
                         (:commands
<<ido-mode-commands>>)
                         (:mode
<<ido-mode-mode>>)
                         (:interpreter
<<ido-mode-interpreter>>)
                         (:defines
<<ido-mode-defines>>))
          append (let ((keyword (car forms))
                        (body (cdr forms)))
                    (cond ((null body) '())
                          ((eq 1 (length body)) forms)
                          (t (list keyword body)))))
       ,@(cl-loop
          for forms in '((:pre-load 
<<ido-mode-preload>>)
                         (:init
<<ido-mode-init>>)
                         (:config 
<<ido-mode-config>>)
                         (:idle 
<<ido-mode-idle>>))
          append (let ((keyword (car forms))
                       (body (cdr forms)))
                   (cond ((null body) '())
                         ((eq 1 (length body)) forms)
                         (t `(,keyword (progn ,@body))))))))
  
#+END_SRC

