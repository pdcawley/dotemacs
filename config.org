# -*- mode: org; coding: utf-8 -*-
#+TODO: ACTIVE | DISABLED
#+STARTUP: indent

This is the Emacs config file of Piers Cawley.

This file is named =config.org=. =init.el= contains bootstrap code
that tangles (only) the Elisp blocks into =config.el=, which is
interpreted by Emacs on startup.

Note that all Elisp blocks which are part of a =DISABLED= heading, or
which are marked with =:tangle no= won't be tangled to the =config.el=
file. This will also make the invisible to Github's Org-mode
rendering, so the best place to read this is within Emacs.

This approach is shamelessly lifted from [[https://github.com/novoid/dot-emacs/][Novoid's dot-emacs]]. 

* Roadmap

Some near-future plans for =config.org=:

- [X] yasnippet setup (life is too short to type =#+BEGIN_SRC
  emacs-lisp= everywhere
- [X] Leader key based keymaps
- [X] req-package based configuration and installation
- Prog-modes
  - [ ] Perl
  - [1/3] Lisps
    - [X] Emacs Lisp
    - [ ] Scheme
    - [ ] Extempore
  - [ ] Javascript
- Blogging
  - [ ] Multi-hugo support
  - Maybe blogging from org-mode?
- Navigation
  - [X] Avy-jump
  - [X] Swiper
  - [ ] Bookmarks
- Org mode
  - [ ] Sort out a workflow
  - Stick to it

* General settings and bootstrapping

profiling:
#+BEGIN_SRC emacs-lisp
  (defvar my-config-el-start-time (current-time)
    "Time when config.el was started")
#+END_SRC

Turn off backup files
#+BEGIN_SRC emacs-lisp
(setq backup-inhibited t)
#+END_SRC

set start of week to Monday (not sunday) http://sunsite.univie.ac.at/textbooks/emacs/emacs_33.html
#+BEGIN_SRC emacs-lisp
(setq calendar-week-start-day 1)
#+END_SRC

don't indent with tabs
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

set warning of opening large files to 100MB
#+BEGIN_SRC emacs-lisp
(setq large-file-warning-threshold 100000000)
#+END_SRC

do not add double space after periods [[http://www.reddit.com/r/emacs/comments/2l5gtz/real_sentence_in_emacs/][Real sentence in Emacs : emacs]]
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

inhibit the startup screen
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t)
#+END_SRC

I'm okay with narrowing
#+BEGIN_SRC emacs-lisp
(put 'narrow-to-region 'disabled nil)
#+END_SRC

** Support functions

*** hook-into-modes
#+BEGIN_SRC emacs-lisp
(defmacro hook-into-modes (func modes)
  `(--each ,modes (add-hook it ,func)))
#+END_SRC

** Package

Configure the package manager

=package-user-dir= holds the directory where ELPA installs its local
copies of the packages:

#+BEGIN_SRC emacs-lisp
(setq package-user-dir (concat my-user-emacs-directory "elpa"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (package-initialize)
  (add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/"))
  ;; unstable
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))
  (add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/packages/"))

  (setq package-archive-priorities
        '(("melpa-stable" . 10)
          ("melpa" . 5)
          ("org" . 15)
          ("gnu" . 0)))

  (package-refresh-contents)
#+END_SRC

Initialize our package managment and key binding:

#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (progn
      (setq package-enable-at-startup nil)
      (require 'use-package)
      (use-package req-package
        :init
        (add-hook 'after-init-hook (lambda () (req-package-finish)))
        :config
        (progn
          (req-package--log-enable-messaging)
          (req-package--log-enable-debugging)))

      (require 'req-package)
      (require 'cl)))

  (req-package diminish
    :force t)
  (req-package bind-key
    :force t)
#+END_SRC

*** Basic libraries

Some libraries just make life easier so we should just load them up
unconditionally and not worry about dealing with dependencies on them
and fencing some of our helper functions in calls to =req-package= to
ensure that the prereqs are required.

**** dash.el
A modern lisp manipulation library
#+BEGIN_SRC emacs-lisp
  (use-package dash
    :ensure t)
  (eval-when-compile (require 'dash))
#+END_SRC

**** s.el
A modern string manipulation library
#+BEGIN_SRC emacs-lisp
  (use-package s
    :ensure t)
#+END_SRC

**** kv.el
A modern library for messing with dictionaries
#+BEGIN_SRC emacs-lisp
  (use-package kv
    :ensure t)
#+END_SRC

** Get the environment from the shell
#+BEGIN_SRC emacs-lisp
  (when (memq window-system '(mac-ns ns))
    (use-package exec-path-from-shell
      :ensure t
      :init
      (setq exec-path-from-shell-arguments (list "-l"))
      :config
      (exec-path-from-shell-initialize)))
#+END_SRC

** Never type "yes" when "y" will do

=yes-or-no-p= can die in a fire

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Eliminate duplicates from the minibuffer history

#+BEGIN_SRC emacs-lisp
(setq history-delete-duplicates t)
#+END_SRC

** Finding Emacs lisp

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (concat my-user-emacs-directory "vendor/"))
(add-to-list 'load-path (concat my-user-emacs-directory "elisp/"))
#+END_SRC

** no-littering

From:
- [[http://manuel-uberti.github.io/programming/2017/06/17/nolittering/][Manuel Uberti: Keeping your .emacs.d clean]]
- https://github.com/tarsius/no-littering

It sets some default paths in order to separate automatically created
files and directories.

#+BEGIN_SRC emacs-lisp
  (req-package no-littering)
#+END_SRC

* Styling

Making emacs look nice

Show current column:
#+BEGIN_SRC emacs-lisp
(setq column-number-mode t)
#+END_SRC

Cursor settings:
#+BEGIN_SRC emacs-lisp
;; Prevent the cursor from blinking
(blink-cursor-mode 0)
#+END_SRC

Turn off the visible bell:
#+BEGIN_SRC emacs-lisp
(setq visible-bell nil)
#+END_SRC

Make sure we have more emoji
#+BEGIN_SRC emacs-lisp
    (req-package emoji-fontset
      :config
      (setq emoji-fontset-check-version 'force)
      (emoji-fontset-enable "Symbola")
      ;(emoji-fontset-enable "Apple Color Emoji")
      )
#+END_SRC

Turn off the toolbar
#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
#+END_SRC



** Spaceline
#+BEGIN_SRC emacs-lisp
  (req-package which-func)

  (req-package powerline
    :config
    (defun pdc/customize-powerline-faces ()
      "Alter powerline faces to make them work with more themes"
      (set-face-attribute 'powerline-inactive2 nil
                          :inherit 'font-lock-comment-face))
    (pdc/customize-powerline-faces))


  (req-package spaceline
    :require which-func powerline
    :init
    (setq powerline-default-separator (if (display-graphic-p) 'brace 'utf-8)
          powerline-height 24)
    :config
    (require 'spaceline-config)

    (defun pdc//restore-powerline (buffer)
      "Restore the powerline in buffer"
      (with-current-buffer buffer
        (setq-local mode-line-format (default-value 'mode-line-format))
        (powerline-set-selected-window)
        (powerline-reset)))

    (setq spaceline-org-clock-p nil)

    (defun pdc//prepare-diminish ()
      (when spaceline-minor-modes-p
        (setq spaceline-minor-modes-separator
              (if (display-graphic-p) "" " "))))
    (add-hook 'spaceline-pre-hook 'pdc//prepare-diminish)
    (spaceline-toggle-hud-on)
    (spaceline-toggle-line-column-off)
    (spaceline-emacs-theme))

#+END_SRC

** Diminish some modes
#+BEGIN_SRC emacs-lisp
  (diminish 'auto-fill-function " Ⓕ")
  (req-package autorevert
  :diminish (auto-revert-mode . " ⎌"))

  ;;; These will be moved to org-mode config when we have an org-mode
  ;;; config section
  (with-eval-after-load 'org-src
    (diminish 'org-src-mode " ∮")
    (setq org-src-window-setup 'current-window))
  (with-eval-after-load 'org-indent
    (diminish 'org-indent-mode " ∃"))
#+END_SRC


** Themes

Zenburn, it's the only way to be sure!

#+BEGIN_SRC emacs-lisp
(load-theme 'zenburn t)
#+END_SRC

** Only one window on startup

#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-startup-hook 'delete-other-windows t)
#+END_SRC

** Pretty symbols
#+BEGIN_SRC emacs-lisp
  (global-prettify-symbols-mode)
#+END_SRC

** Font sizes


- 2011-04-20: increase/set font size
  - http://www.emacswiki.org/emacs/SetFonts

#+BEGIN_SRC emacs-lisp
(defun my-increase-fontsize ()
  (interactive)
  "Sets the font to bigger size"
  (set-face-attribute 'default (selected-frame) :height 130)
  )
(defun my-normal-fontsize ()
  (interactive)
  "Sets the font to normal size"
  (set-face-attribute 'default (selected-frame) :height 100)
  )
#+END_SRC


* UTF-8 and codings

Activate UTF-8 mode:
#+BEGIN_SRC emacs-lisp
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)

  (set-clipboard-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+END_SRC

* Leader key based bindings

** Leader keys and maps
#+BEGIN_SRC emacs-lisp
  (defvar leader-map (make-sparse-keymap))
  (defvar leader-key "M-m")
  ;(global-set-key (kbd leader-key) nil)

  (defvar mode-leader-key "M-,"
    "Prefix for mode specific leader")
#+END_SRC

** Supporting packages
which-key:
#+BEGIN_SRC emacs-lisp
  (req-package which-key
    :diminish " Ⓚ"
    :init
    (bindings|add-toggle which-key-mode :toggle"TK")
    :config
    (let ((new-descriptions
           '(("select-window-\\"0-9 "\\)" . "window \\1")
             ("avy-goto-word-or-subword-1" . "avy»word")
             ("shell-command" . "shell cmd")
             ("universal-argument" . "universal arg")
             ("er/expand-region" . "expand region"))))
      (dolist (nd new-descriptions)
        (push (cons (concat "\\`" (car nd) "\\'") (cdr nd))
              which-key-description-replacement-alist)))
    (setq which-key-special-keys nil
          which-key-echo-keystrokes 0.02
          which-key-max-description-length 32
          which-key-sort-order 'which-key-key-order-alpha
          which-key-idle-delay 0.4)
    (which-key-mode))
#+END_SRC

hydra:
#+BEGIN_SRC emacs-lisp
  (req-package ivy)
  (req-package ibuffer)
  (req-package hydra
    :requires (ibyffer ivy)
    :commands defhydra
    :init
    (setq hydra-head-format "%s → "))
#+END_SRC


** Supporting macros
These define space keymaps under the leader key
#+BEGIN_SRC emacs-lisp
  (defun bindings|expand-define-prefix (desc key docstr)
    (let* ((descname (symbol-name desc))
           (leader-variable-name (intern (format "%s-leader-key" descname)))
           (infix-variable-name (intern (format "%s-infix-key" descname)))
           (prefix-variable-name-deprecated (intern (format "%s-prefix-key" descname)))
           (mode-leader-variable-name (intern (format "%s-mode-leader-key" descname)))
           (doc (or docstr (symbol-name desc))))
      `(progn
         (defvar ,leader-variable-name (format "%s %s" leader-key ,key)
           ,(format "leader-key + prefix for %s" doc))
         (defvar ,infix-variable-name ,key
           ,(format "infix for %s - use with `pdc|with-leader :infix %s' type commands" doc infix-variable-name))
         (defvar ,prefix-variable-name-deprecated ,infix-variable-name
           ,(format "Obsolete copy of %s" infix-variable-name))
         (make-obsolete ',prefix-variable-name-deprecated ',infix-variable-name "2017-08-27")
         (which-key-add-key-based-replacements ,leader-variable-name ,doc))))


  (defmacro bindings|define-prefix (desc key &optional docstr)
    (declare (indent 1))
    (bindings|expand-define-prefix desc key docstr))

  (defmacro bindings|define-prefix-1 (descvar key docstr)
    (declare (indent 1))
    `(eval (bindings|expand-define-prefix `,,descvar ,key ,docstr)))

#+END_SRC

** Keymap prefixes
The idea is that most of our commands come under a tree of prefixes,
all initiated from the primary leader key. The prefixes are
essentially sparse keymaps, and I've not worked out how to easily
define them on the fly, so we predeclare the major branches of our
tree here.

We use =use-package ... :ensure t= here rather than =req-package= to
ensure that =pdc|with-leader= is avaialable to the =:general= clause
of subsequent calls to =req-package=

#+NAME: prefixes
| name            | keys | description         |
|-----------------+------+---------------------|
| colors          | C    |                     |
| package         | P    |                     |
| rectangle       | R    |                     |
| elisp           | Re   |                     |
| toggle          | T    | toggles             |
| applications    | a    |                     |
| shell           | as   | shells              |
| buffer          | b    | buffers             |
| compile         | c    | compile/comments    |
| files           | f    |                     |
| file-convert    | fC   | files/convert       |
| emacs-d         | fe   | emacs               |
| variable        | fv   | variables           |
| git             | g    | git/version-control |
| help            | h    |                     |
| help-describe   | hd   |                     |
| insertion       | i    |                     |
| jump            | j    | jump/join/split     |
| lisp            | k    |                     |
| delete-backward | kD   |                     |
| hybrid          | k`   |                     |
| delete          | kd   |                     |
| cursor          | m    | marks/cursors       |
| narrow          | n    | narrow/number       |
| org             | o    |                     |
| project         | p    | projects            |
|                 | p$   | projects/shell      |
| replace         | r    |                     |
| search          | s    | searching           |
| transpose       | t    |                     |
| window          | w    | windows             |
| quit            | q    |                     |
|                 |      |                     |

#+BEGIN_SRC emacs-lisp

  (use-package general
    :ensure t
    :config
    (use-package hydra
      :ensure t)
    (use-package which-key
      :ensure t)

    (general-define-key mode-leader-key '(nil :which-key "mode-leader"))
    (general-define-key leader-key '(nil :which-key "leader"))

    (general-create-definer pdc|with-leader
                            :prefix leader-key :keymaps 'global)
    (put 'pdc|with-leader 'lisp-indent-function 'defun)

    (general-create-definer pdc|with-mode-leader
                            :prefix mode-leader-key)
    (put 'pdc|with-mode-leader 'lisp-indent-function 'defun)

    (pdc|with-leader
      "h" (list help-map :which-key "help")))

  (defun pdc/mplist-get (plist prop)
    "Get the values associated to PROP in PLIST, a modified plist.

  A modified plist is one where keys are keywords and values are
  all non-keywords elements that follow it.

  If there are multiple properties with the same keyword, only the first property
  and its values is returned.

  Currently this function infloops when the list is circular."
    (let ((tail plist)
          result)
      (while (and (consp tail) (not (eq prop (car tail))))
        (pop tail))
      ;; pop the found keyword
      (pop tail)
      (while (and (consp tail) (not (keywordp (car tail))))
        (push (pop tail) result))
      (nreverse result)))

  (defun bindings//expand-add-toggle (name props)
    (let* ((wrapper-func (intern (format "toggle|%s"
                                         (symbol-name name))))
           (wrapper-func-on (intern (format "%s-on" wrapper-func)))
           (wrapper-func-off (intern (format "%s-off" wrapper-func)))
           (status (or (plist-get props :status) name))
           ;; (condition (plist-get props :if))
           (doc (plist-get props :documentation))
           (on-body (or (pdc/mplist-get props :on)))
           (off-body (pdc/mplist-get props :off))
           (status-eval `(and (or (and (symbolp ',status) (boundp ',status))
                                  (listp ',status))
                              ,status))
           ;; If we're defined by `define-minor-mode this will toggle
           ;; the mode
           (toggle-body (or (pdc/mplist-get props :toggler)
                            (if (or on-body off-body)
                                `(if ,status-eval ,off-body ,on-body)
                              `(,name 'toggle))))
           (keymaps (pdc/mplist-get props :keymaps))
           (binding (plist-get props :toggle-keys)))
      `(progn
         (defun ,wrapper-func ()
           ,(format "Toggle %s on and off." (symbol-name name))
           (interactive)
           ,toggle-body
           (message (let ((enabled ,status-eval))
                      (format "%s %s." (quote ,name) (if enabled "enabled" "disabled")))))
         ,@(when binding
             `((pdc|with-leader ,@(if keymaps `(:keymaps ',keymaps))
                 ,binding '(,wrapper-func :which-key
                                          ,(or doc (symbol-name name))))))
         ,@(when status
             `((defun ,wrapper-func-on ()
                 ,(format "Toggle %s on" (symbol-name name))
                 (interactive)
                 (unless ,status-eval (,wrapper-func)))
               (defun ,wrapper-func-off ()
                 ,(format "Toggle %s off." (symbol-name name))
                 (interactive)
                 (when ,status-eval (,wrapper-func))))))))

  (defmacro bindings|add-toggle (name &rest props)
    (declare (indent 1))
    (bindings//expand-add-toggle name props))

  (defun pdc/shortdoc (fn)
    (when-let ((doc (documentation fn)))
      (substring doc 0 (string-match "\n" doc))))

  (defun pdc//bind-hydra-spec (spec leader)
    (pcase spec
      (`(,key ,fn ,desc . ,(pred (lambda (props)
                                   (plist-get props :exit))))
       (let ((keys (concat leader key)))
         (general-define-key :prefix leader-key
                             keys (list fn :which-key desc))))
      (`(,key ,_ ,desc . ,(and props
                               (pred (lambda (props)
                                       (not (plist-get props :exit))))))
       (let ((hydra-fn (plist-get props :cmd-name))
             (long-leader (concat leader-key " " leader)))
         (general-define-key :prefix long-leader
                             key (list hydra-fn :which-key desc))))))


  (defmacro pdc|general-bind-hydra
      (name leader &key no-cancel &allow-other-keys &rest specs)
    "Bind a hydra in such a way that others can share the prefix."
    (declare (indent defun))
    (cl-flet
        ((canonicalize-spec (spec)
                            (let* ((key (car spec))
                                   (action (cadr spec))
                                   (tail (cddr spec))
                                   (caption (cond ((stringp (car tail))
                                                   (pop tail))
                                                  ((symbolp action)
                                                   (symbol-name action))
                                                  ((functionp action)
                                                   (pdc/shortdoc action))
                                                  (t "??"))))
                              `(,key ,action ,caption ,@tail
                                     :cmd-name ,(intern
                                                 (format "hydra-%s/%s" name action))))))
      (let ((hydra-key (intern (format "hydra-%s" (symbol-name name))))
            (specs (-map #'canonicalize-spec specs)))
        `(progn
           (defhydra ,hydra-key (nil nil :color red)
             ,(symbol-name name)
             ,@specs
             ,@ (unless no-cancel '(("q" nil "cancel" :color blue))))
           (--each ',specs
             (pdc//bind-hydra-spec it ,leader))))))

  (put 'pdc|general-bind-hydra 'lisp-indent-function 2)

#+END_SRC

#+BEGIN_SRC emacs-lisp :var prefixes=prefixes
  (dolist (it prefixes)
    (pcase-let* ((`(,namestr ,keys ,desc) it)
                 (name (when (not (string= "" namestr))
                         (intern namestr)))
                 (description (if (> (length desc) 0)
                                  desc
                                namestr)))
      (if name
          (bindings|define-prefix-1 name keys description)
        (which-key-add-key-based-replacements keys description))))

#+END_SRC

* Buffer and window handling
** ibuffer
#+BEGIN_SRC emacs-lisp
  (req-package ibuffer
    :config
    (fset 'list-buffers 'ibuffer)
    (defun pdc/list-buffers-int ()
      (interactive)
      (display-buffer (list-buffers-noselect nil))))

#+END_SRC

** ibuffer-vc
#+BEGIN_SRC emacs-lisp
  (req-package ibuffer-vc
    :require ibuffer
    :config
    (setq ibuffer-formats
          '((mark pdc-modified vc-status-mini
                  " " (name 35 35 :left :elide)
                  " " filename-and-process)
            (mark " " (name 16 -1) " " filename)))

    (define-ibuffer-column pdc-modified (:name "M" :inline t)
      (if (buffer-modified-p)
          (propertize "-" 'face '(:foreground "yellow"))
        " ")))
#+END_SRC

** Window numbering
Bouncing around windows using their numbers is fast and
straightforward.

#+BEGIN_SRC emacs-lisp
  (req-package window-numbering
    :requires dash
    :config
    ;; Because we don't want deferred loading here, we move the key
    ;; bindings down into config
    (pdc|with-leader :keymaps 'window-numbering-keymap
     "w1" 'select-window-1
     "w2" 'select-window-2
     "w3" 'select-window-3
     "w4" 'select-window-4
     "w5" 'select-window-5
     "w6" 'select-window-6
     "w7" 'select-window-7
     "w8" 'select-window-8

     "w0" 'bm-next
     "w9" 'bm-previous)
    ;; (defun window-numbering-install-mode-line (&optional position)
    ;;   "Do nothing, the desplay will be handled by spaceline.")
    (--each (number-sequence 0 9)
      (general-define-key :keymaps 'window-numbering-keymap
       (format "M-%s" it) nil))

    (window-numbering-mode 1))
#+END_SRC

** uniquify
Give buffers unique names
#+BEGIN_SRC emacs-lisp
  (req-package uniquify
    :config
    (setq uniquify-buffer-name-style 'post-forward-angle-brackets)
    (setq uniquify-ignore-buffers-re "^\\*")) ; don't muck with special buffers
#+END_SRC

** winner-mode
An undo tree for window configurations. Really handy.
#+BEGIN_SRC emacs-lisp
  (when (fboundp 'winner-mode)
    (winner-mode 1))
#+END_SRC

** Useful commands
- TODO Use window numbers rather than counts where appropriate [%]
  - [ ] =pdc/transpose-windows=

Various commands that affect windows and window layout

=pdc/toggle-window-split=: Toggle the orientation of a single window split.
#+BEGIN_SRC emacs-lisp
  (defun pdc/toggle-window-split ()
    "Switch between a horizontal and vertical split if there are two windows."
    (interactive)
    (when (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                            (car next-win-edges))
                                        (<= (cadr this-win-edges)
                                            (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car next-win-edges))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))
#+END_SRC

=pdc/transpose-windows=: Swap the buffers between two windows
#+BEGIN_SRC emacs-lisp
  (defun pdc/transpose-windows (arg)
    "Transpose the buffers shown in two windows"
    (interactive "p")
    (let ((selector (if (>= arg 0) 'next-window 'previous-window)))
      (while (/= arg 0)
        (let ((this-win (window-buffer))
              (next-win (window-buffer (funcall selector))))
             (set-window-buffer (selected-window) next-win)
             (set-window-buffer (funcall selector) this-win)
             (select-window (funcall selector)))
        (setq arg (if (plusp arg) (1- arg) (1+ arg))))))

  (defun pdc/rotate-windows ()
    "Rotate your windows"
    (interactive)
    (cond
     ((not (> (count-windows) 1))
      (message "You can't rotate a single window!"))
     (t
      (let ((i 1)
            (num-windows (count-windows)))
        (while  (< i num-windows)
          (let* ((w1 (elt (window-list) i))
                 (w2 (elt (window-list) (+ (% i num-windows) 1)))
                 (b1 (window-buffer w1))
                 (b2 (window-buffer w2))
                 (s1 (window-start w1))
                 (s2 (window-start w2)))
            (set-window-buffer w1 b2)
            (set-window-buffer w2 b1)
            (set-window-start w1 s2)
            (set-window-start w2 s1)
            (setq i (1+ i))))))))
#+END_SRC

=pdc/sync-point-all-windows=: Move the point to the same place in all
windows. Not sure I've ever used this. Might disable it.
#+BEGIN_SRC emacs-lisp

  (defun pdc/sync-point-all-windows (&optional buffer pnt)
    "Synchronise the point in all windows"
    (interactive)
    (let ((buffer (or buffer (current-buffer)))
          (pnt (or pnt (point))))
      (dolist (f (frame-list))
        (dolist (w (window-list f))
          (if (eq (window-buffer w) buffer)
              (set-window-point w pnt))))))
#+END_SRC

=pdc/bury-buffer-other-windows=: The highlander function. When called,
it burys the buffer in the current window in all the other windows,
ensuring that the current window is the only one displaying the buffer.
#+BEGIN_SRC emacs-lisp
  (defun pdc/bury-buffer-other-windows (&optional buffer)
    "Bury the current buffer in all windows but the current one."
    (interactive)
    (let ((buffer (or buffer (current-buffer))))
      (save-window-excursion
        (dolist (f (frame-list))
          (dolist (w (window-list f))
            (if (eq (window-buffer w) buffer)
                (unless (window--delete w t t)
                  (set-window-dedicated-p w nil)
                  (switch-to-prev-buffer w 'kill))))))))
#+END_SRC

=pdc/blank-other-frame-windows=: Sets all other windows in all frames
to display a =*blank*= buffer.
#+BEGIN_SRC emacs-lisp
  (defun pdc/blank-other-frame-windows ()
    (interactive)
    (let ((buffer (get-buffer-create "*blank*")))
      (save-window-excursion
        (dolist (f (frame-list))
          (dolist (w (window-list f))
            (unless (window--delete w t t)
              (set-window-dedicated-p w nil)
              (set-window-buffer w buffer)))))))
#+END_SRC



** Support functions


* Basic editing

** Our commands
#+BEGIN_SRC emacs-lisp
  (defun pdc/set-undo-boundary ()
    (interactive)
    (undo-boundary))

  (defun pdc/cap-sentence ()
    (interactive)
    (save-excursion
      (backward-sentence)
      (capitalize-word 1)))

  (defun pdc/quote-region (start end &optional c)
    (interactive "r")
    (let ((c (or c "\"")))
      (save-excursion
        (goto-char start)
        (insert c)
        (goto-char (+ 1 end))
        (insert c))))

  (defun pdc/single-quote-region (start end)
    (interactive "r")
    (pdc/quote-region start end "'"))

  (defun pdc/yank-and-indent ()
    (interactive)
    (yank)
    (call-interactively 'indent-region))


  ;;; Helper lifts from k2
  (defun pdc/mark-whole-line ()
    (interactive)
    (beginning-of-line)
    (set-mark-command nil)
    (end-of-line))


  (defun pdc/kill-whole-line ()
    (interactive)
    (pdc/mark-whole-line)
    (kill-region (region-beginning)
                 (region-end)))

  (defun pdc/copy-whole-line ()
    (interactive)
    (save-excursion
      (pdc/mark-whole-line)
      (kill-ring-save (region-beginning)
                      (region-end))))


  (defun pdc/clone-line ()
    (interactive)
    (beginning-of-line)
    (pdc/copy-whole-line)
    (open-next-line)
    (forward-line)
    (yank)
    (back-to-indentation))

  (defun pdc|goto-line (line)
    "A simplified, single buffer version of the standard command
    that work even if the buffer is narrowed"
    (interactive "nLine:")
    ;; Leave mark at previous position
    (or (region-active-p) (push-mark))
    ;; Move to the specified line number in that buffer.
    (save-restriction
      (goto-char (point-min))
      (if (eq selective-display t)
          (re-search-forward "[\n\C-m]" nil 'end (1- line))
        (forward-line (1- line)))))


  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;; https://github.com/al3x/emacs/blob/master/utilities/slick-copy.el
  (defadvice kill-ring-save (before slick-copy activate compile)
    "When called interactively with no active region, copy a single line instead."
    (interactive
     (if mark-active (list (region-beginning) (region-end))
       (message "Copied line")
       (list (line-beginning-position)
             (line-beginning-position 2)))))

  (defadvice kill-region (before slick-cut activate compile)
    "When called interactively with no active region, kill a single line instead."
    (interactive
     (if mark-active (list (region-beginning) (region-end))
       (list (line-beginning-position)
             (line-beginning-position 2)))))
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defun pdc/apply-to-region (func)
    (when (region-active-p)
      (insert (funcall func (delete-and-extract-region
                             (region-beginning)
                             (region-end))))))

#+END_SRC

** Packages
#+BEGIN_SRC emacs-lisp
  (req-package subword)

  (require 'misc)      ; forward-to-word & backward-to-word

  (req-package visible-mark
    :config
    (global-visible-mark-mode t))

  (req-package undo-tree
    :diminish undo-tree-mode
    :config
    (global-undo-tree-mode))

  (req-package goto-last-change
    :config
    (setq highlight-changes-visibility-initial-state nil))

#+END_SRC

** Bindings
#+BEGIN_SRC emacs-lisp
  (pdc|general-bind-hydra transpose "t"
    ("t" transpose-chars "chars")
    ("C-t" transpose-chars "chars")
    ("l" transpose-lines "lines")
    ("p" transpose-paragraphs "paras")
    ("s" transpose-sexps "sexps")
    ("C-M-t" transpose-sexps "sexps")
    ("w" transpose-words "words")
    ("M-t" transpose-words "words"))

#+END_SRC

** Abbreviations
#+NAME: abbrev
| Base | Expansion                   |
|------+-----------------------------|
| bc   | because                     |
| wo   | without                     |
| wi   | with                        |
| qm   | piers@singingtogether.co.uk |

#+BEGIN_SRC emacs-lisp :var data=abbrev
(mapc (lambda (x) (define-global-abbrev (car x) (cadr x))) (cddr data))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'abbrev-mode)
(diminish 'abbrev-mode " A")
#+END_SRC

** Multiple cursors
#+BEGIN_SRC emacs-lisp
  (req-package multiple-cursors
    :demand t
    :general
    ("s-<mouse-1>" 'mc/add-cursor-on-click)
    :config
    (pdc|general-bind-hydra mc cursor-infix-key
      ("<" mc/mark-previous-like-this)
      (">" mc/mark-next-like-this )
      ("M-<" mc/unmark-previous-like-this)
      ("M->" mc/unmark-next-like-this)
      ("i" mc/insert-numbers)
      ("d" mc/mark-all-symbols-like-this-in-defun :color blue)
      ("r" mc/reverse-regions)
      ("s" mc/sort-regions))
    (pdc|with-leader :infix cursor-infix-key
     "C-a" 'mc/edit-beginnings-of-lines
     "A" 'mc/mark-all-like-this
     "a" 'mc/mark-all-dwim
     "C-e" 'mc/edit-ends-of-lines
     "e" 'mc/edit-lines))
#+END_SRC

* Navigation

** Standard locations
#+BEGIN_SRC emacs-lisp
  (defun pdc/find-config ()
    "Edit the `config.org', in the current window."
    (interactive)
    (find-file-existing my-config-org))

  (defun pdc/find-user-init-file ()
    "Edit the `user-init-file' in the current window."
    (interactive)
    (find-file-existing user-init-file))

  (defun pdc/copy-file ()
    "Write the file under new name."
    (interactive)
    (call-interactively 'write-file))

  (defun pdc//read-file-name (&optional initial-input)
    (ivy-read "File file: " 'read-file-name-internal
              :matcher #'counsel--find-file-matcher
              :initial-input initial-input
              :preselect (when counsel-find-file-at-point
                           (require 'ffap)
                           (let ((f (ffap-guesser)))
                             (when f (expand-file-name f))))
              :history 'file-name-history
              :caller this-command))

  (defun pdc/sudo-edit (&optional initial-input)
    (interactive "P")
    (counsel-find-file-as-root (pdc//read-file-name initial-input)))
  
  (pdc|with-leader :infix emacs-d-infix-key
    "c" '(pdc/find-config :which-key "config.org")
    "i" '(pdc/find-user-init-file :which-key "init.el"))

  (pdc|with-leader :prefix files-leader-key
    "c" '(pdc/copy-file :which-key "copy")
    "g" 'rgrep
    "l" 'find-file-literally
    "E" 'pdc/sudo-edit
    "s" 'save-buffer
    "v" '(:ignore t :which-key "variables")
    "vd" 'add-dir-local-variable
    "vf" 'add-file-local-varihable
    "vp" 'add-file-local-variable-prop-line)
#+END_SRC

** Avy
For jumping to characters and words in the frame
#+BEGIN_SRC emacs-lisp
  (req-package avy
    :general
    (pdc|with-leader
     "jj" 'avy-goto-char-timer
     "jb" 'avy-goto-char
     "j'" 'avy-goto-char-2
     "jw" 'avy-goto-word-1))
#+END_SRC

** Swiper
A better incremental search

#+BEGIN_SRC emacs-lisp
    (req-package swiper
      :pin "melpa"
      :commands (swiper swiper-all)
      :general
      (pdc|with-leader :infix search-infix-key
       "s" 'swiper
       "S" 'swiper-all)
      :config
      (global-set-key [remap isearch-forward] 'swiper)
      (global-set-key [remap isearch-forward-regexp] 'swiper)
      (global-set-key [remap isearch-backward] 'swiper)
      (global-set-key [remap isearch-backward-regexp] 'swiper))


#+END_SRC

** Ivy
A better completing read. Similar to helm but rather less intrusive. 

We define a =pdc-find-file-other-window= function, but it seems the
'proper' ivy based approach is to do =M-o j= once we've selected the
correct file using counsel-find-file. Not sure how to suggest this in
the method itself, short of erroring out and telling the user (me) to
just use the ivy supplied method.
#+BEGIN_SRC emacs-lisp

  (req-package ivy
    :pin "melpa"
    :config
    (defun pdc-find-file-other-window (&optional initial-input)
      "Forward to `find-file-other-window'.
  When INITIAL-INPUT is non-nil, use it in the minibuffer during completion."
      (interactive)
      (ivy-read "Find file: " 'read-file-name-internal
                :matcher #'counsel--find-file-matcher
                :initial-input initial-input
                :action
                (lambda (x)
                  (with-ivy-window
                    (find-file-other-window
                     (expand-file-name x
                                       ivy--directory))))
                :preselect (when counsel-find-file-at-point
                             (require 'ffap)
                             (let ((f (ffap-guesser)))
                               (when f (expand-file-name f))))
                :require-match 'confirm-after-completion
                :history 'file-name-history
                :keymap counsel-find-file-map
                :caller 'counsel-find-file)))
#+END_SRC

** Counsel

Wraps a bunch of common functions with the =ivy= completing read
that's also used by swiper.
#+BEGIN_SRC emacs-lisp
  (req-package colir)

  (req-package counsel
    :require colir
    :demand t
    :diminish " ⓒ"
    :general
    (:prefix files-leader-key
     "f" '(counsel-find-file :which-key "find"))
    (pdc|with-leader
     "g S" '(counsel-git-grep :which-key "git grep")
     "g f" '(counsel-git :which-key "find file in repo")
     "Re L" '(counsel-load-library :which-key "load library")
     "o g" '(counsel-org-goto :which-key "goto")
     "o G" '(counsel-org-goto-all :which-key "goto-all"))
    :init
    (bindings|add-toggle counsel-mode :toggle-keys "Tc")
    :config
    (--each '((apropos . counsel-apropos)
              (org-goto . counsel-org-goto)
              (set-variable . counsel-set-variable)
              (insert-char . counsel-unicode-char))
      (when (fboundp (cdr it))
        (define-key counsel-mode-map (vector 'remap (car it)) (cdr it))))
    (counsel-mode t))
#+END_SRC

* Bindings
Toggles for stuff that's preloaded
#+BEGIN_SRC emacs-lisp
  (bindings|add-toggle auto-fill-mode :toggle-keys "Tf")
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun pdc/execute-extended-command-short (prefixarg &optional function)
    "Massively simplified execute extended command.

  This isn't meant for interactive use by humans, but
  `counsel-M-x', lovely though it is, breaks some of my dictation
  support. This doesn't"
    (interactive "P\nCcommand: ")
    (setq this-command function)
    (setq real-this-command function)
    (let ((prefix-arg prefixarg))
      (command-execute function 'record)))

  ;; Clear up some useless bindings
  (global-unset-key (kbd "C-z"))
  (global-unset-key [insert])

  ;; Set up an options prefix
  (bindings|define-prefix opts "O" "Options")

  ;;
  (general-define-key :prefix window-leader-key
                      "/" 'pdc/toggle-window-split)

  (general-define-key
   "C-x C-m" 'pdc/execute-extended-command-short)

  ;; Command name shorthands. Thanks Steve Yegge
  (defalias 'qrr 'query-replace-regexp)
  (defalias 'rr 'replace-regexp)

  ;; Buffer spruce up - could be cleverer. Per-mode spruce up strategies
  ;; for instance
  (req-package pdc-spruce-up-buffer
    :general
    (:prefix buffer-leader-key
             "T" 'pdc|spruce-up-buffer))

  (general-define-key :prefix buffer-leader-key
                      "y" 'bury-buffer
                      "r" 'revert-buffer)

  ;; Some lispy bindings

  (pdc|with-mode-leader :keymaps 'lisp-mode-shared-map
                        :infix buffer-infix-key
                        "v" '(eval-buffer :which-key "eVal-buffer"))

  (defun pdc|apropos-function (pattern)
    (interactive (list (apropos-read-pattern
                        "command or function")))
    (apropos-command pattern t))


  ;;; An apropos leader
  (pdc|with-leader :infix "h A"
   ""    '(nil :which-key "apropos")
   "A"   'apropos
   "c"   'apropos-command
   "d"   'apropos-documentation
   "f"   'pdc|apropos-function
   "l"   'apropos-library
   "m"   'apropos-mode
   "o"   'apropos-user-option
   "v"   'apropos-variable
   "M-v" 'apropos-local-variable
   "V"   'apropos-value
   "M-V" 'apropos-local-value)

  ;;; A describe-foo leader
  ;; First unbind a bunch of non-menu bindings
  (--each '(;; apropos-*
            "a" 
            ;; describe-*
            "b" "C-c" "C-o" "c" "C" "f" "g" "I"
            "k" "L" "m" "C-w" "P" "o" "s" "v"
            ;; info stuff
            "i" "F" "K" "r" "S")

    (global-unset-key (kbd (format "%c %s" help-char it))))

  (pdc|with-leader :infix "h d"
   ""     '(nil :which-key "describe-*")
   "b" 'describe-bindings
   "B" 'describe-personal-bindings
   "c" 'describe-key-briefly
   "C" 'describe-coding-system "f" 'describe-function
   "F" 'describe-face
   "I" 'describe-input-mode
   "k" 'describe-key
   "o" 'describe-symbol
   "L" 'describe-language-environment
   "m" 'describe-mode
   "P" 'describe-package
   "s" 'describe-syntax
   "t" 'describe-theme
   "v" 'describe-variable
   "C-c" 'describe-current-coding-system)

  (defun info-elisp-manual ()
    "Display the Elisp manual in Info mode."
    (interactive)
    (info "elisp"))

  (pdc|with-leader :infix "h i"
   "" '(nil :which-key "Info")
   "e" 'info-elisp-manual                
   "i" 'info
   "F" 'Info-goto-emacs-command-node
   "K" 'Info-goto-emacs-key-command-node
   "r" 'info-emacs-manual
   "S" 'info-lookup-symbol)

  ;; A vi-like %

  (defun pdc|match-paren (arg)
    "Go to the matching paren if on a paren, otherwise self-insert."
    (interactive "p")
    (let ((prev-char (char-to-string (preceding-char)))
          (next-char (char-to-string (following-char))))
      (cond ((string-match "[[{(<“‘]" next-char) (forward-sexp 1))
            ((string-match "[\]})>’”]" prev-char) (backward-sexp 1))
            (t (self-insert-command (or arg 1))))))

  (general-define-key "%" 'pdc|match-paren)

  (req-package pdc-helpers
    :commands
    pdc|smarter-move-beginning-of-line
    :general
    (pdc|with-leader
     "|"      '(pdc|align :which-key "align")
     "\\"     '(pdc|align :which-key "align")

     "C-M-|"  '(pdc|align-last-sexp :which-key "align last sexp")
     "C-M-\\" '(pdc|align-last-sexp :which-key "align last sexp")

     "'"      '(pdc|quote-behind :which-key "' behind")
     "\""     '(pdc|doublequote-behind :which-key "\" behind")

     ;; operate on file and buffer, so put beneath both leaders
     "f R"    '(pdc|rename-file-and-buffer :which-key "rename file & buffer") 
     "b R"    '(pdc|rename-file-and-buffer :which-key "rename file & buffer")   
     "f M"    '(pdc|move-buffer-file :which-key "move buffer file")
     "b M"    '(pdc|move-buffer-file :which-key "move buffer file")

     "Re i"    '(pdc|visit-ielm :which-key "ielm")
     "Re R"    '(pdc|eval-and-replace :which-key "eval and replace"))
    :init
    (global-set-key [remap move-beginning-of-line]
                    'pdc|smarter-move-beginning-of-line)
    (global-set-key [remap ielm]
                    'pdc|visit-ielm))


  (defun mark-line (&optional arg)
    "Mark the current line.

  If ARG is set, mark that many lines beginning (or ending if arg is negative) with the current one"
    (interactive "p")
    (let* ((arg (or arg 1)))
      (beginning-of-line)
      (let ((here (point)))
        (if (< arg 1)
            (beginning-of-line (1+  arg))
          (end-of-line arg))
        (set-mark (point))
        (goto-char here))))

  (defun mark-sentence (&optional arg)
    (interactive "p")
    (backward-sentence)
    (mark-end-of-sentence arg))


  (pdc|with-leader
   "P l" 'package-list-packages
   "T I" 'toggle-input-method)

  ;;; Jumps
  (pdc|with-leader
   :infix jump-infix-key
   "l" 'pdc|goto-line
   "$" 'move-end-of-line
   ">" 'end-of-buffer
   "<" 'beginning-of-buffer
   "^" 'pdc|smarter-move-beginning-of-line
   "a" 'back-to-indentation)

  ;;; File stuff
  (pdc|with-leader
   :infix buffer-infix-key
   "R" 'recompile
   "S" 'pdc|spruce-up-buffer)

  (pdc|with-leader
   "k" (list
        (defhydra hydra-kill (nil nil :color red)
          "Kill"
          (";" kill-comment "comment")
          ("<tab>" delete-indentation "indentation")
          ("L" kill-whole-line "whole line")
          ("R" kill-rectangle "rectangle" :color blue)
          ("S" kill-sentence "sentence")
          ("l" kill-line "line")
          ("p" kill-paragraph "paragraph")
          ("r" kill-region "region")
          ("s" kill-sexp "sexp")
          ("v" kill-visual-line "visual line")
          ("w" kill-word "word"))
        :which-key "+kill")
   "K" (list kmacro-keymap :which-key "kmacro")

   ;; "r q" 'query-replace-regexp
   "r R" 'replace-rectangle)
#+END_SRC

* Snippets

Snippet systems are the good sort of magical. Insane in many ways, and
for god's sake, don't look at yasnippet's implementation if you value
your sanity. Please, I beg of you don't. But do use them.

** yasnippet

[[https://github.com/joaotavora/yasnippet][Yasnippet]] seems to be winning the snippet tool race now

#+BEGIN_SRC emacs-lisp
  (req-package yasnippet
    :mode ("/\\.emacs\\.d/etc/yasnippet/snippets/" . snippet-mode)
    :demand t
    :diminish yas-minor-mode
    :config
    (yas-load-directory (concat my-user-emacs-directory "etc/yasnippet/snippets/"))
    (yas-global-mode 1))
#+END_SRC

** Snippet like functions

#+BEGIN_SRC emacs-lisp
  (defun my-org-insert-elisp ()
    (interactive)
    (yas-expand-snippet "#+BEGIN_SRC emacs-lisp\n$0\n#+END_SRC\n")
    (org-edit-special))

  (defun pdc/org-split-src ()
    (interactive)
    (let ((element (org-element-at-point)))
      (barf-if-buffer-read-only)
      (pcase (org-element-type element)
        (`src-block
         (let* ((beg (org-element-property :begin element))
                (end (save-excursion
                       (goto-char beg)
                       (line-end-position))))
           (end-of-line)
           (insert "\n#+END_SRC\n\n")
           (insert-buffer-substring (current-buffer) beg end)
           (forward-line -1)))
        (_
         ;; Nothing interesting to split
         (user-error "Don't know how to split this element")))))



  (pdc|with-mode-leader :keymaps 'org-mode-map
                        "s" nil
                        "s e" 'my-org-insert-elisp
                        "s/" 'pdc/org-split-src)

  ;; (with-eval-after-load 'yankpad
  ;;  (bind-key "<f6>e" 'my-org-insert-elisp nil (eq major-mode 'org-mode)))

#+END_SRC

* Programming
** Version Control (Git)
*** Magit
Magit is awesome and I'd hate to be without it
#+BEGIN_SRC emacs-lisp

  (req-package with-editor
    :diminish "")

  (req-package magit
    :require exec-path-from-shell
    :demand t
    :general
    ("M-," 'pdc/vc-status)
    ("C-. g s" 'magit-status)
    (:prefix leader-key
             "g"   '(:ignore t :which-key "git")
             "g s" 'magit-status)
    :init
    (setq magit-last-seen-setup-instructions "1.4.0")
    (setq magit-branch-arguments nil)
    (setq magit-push-always-verify nil)
    :config
    (defun pdc/bookmark-magit-status (bookmark)
      "Run magit-status on the bookmarked file"
      (interactive
       (list (bookmark-completing-read "Status of bookmark"
                                       (bmkp-default-bookmark-name))))
      (magit-status (bookmark-prop-get bookmark 'filename)))
    (defun pdc/vc-status ()
      (interactive)
      (cond ((magit-get-top-dir default-directory)
             (call-interactively 'magit-status))
            (t
             (call-interactively 'dired)))))

#+END_SRC
*** Gist
Manage code samples on github
#+BEGIN_SRC emacs-lisp
  (req-package gist
    :init
    (setq gist-authenticate-function 'gist-oauth2-authentication)
    :general
    (pdc|with-leader
     "g G" 'gist-region-or-buffer))

#+END_SRC

*** Helpful gutters/fringes
The fringe is a very handy bit of interface, especially when it knows
about the git status of things.
#+BEGIN_SRC emacs-lisp
  (req-package git-gutter+
    :require magit
    :diminish git-gutter+-mode
    :init
    (bindings|add-toggle git-gutter+-mode :toggle-keys "Tg")
    :config
    (global-git-gutter+-mode 1))

  (req-package git-gutter-fringe+
    :config
    (git-gutter-fr+-minimal))

#+END_SRC

*** DISABLED magithub
Apparently has useful integration with github, but I need to look into
how to configure it properly.
#+BEGIN_SRC emacs-lisp
  (req-package magithub :require magit)
#+END_SRC

*** git-timemachine
Speculatively installed. Need to work out if I really need it.
#+BEGIN_SRC emacs-lisp
  (req-package git-timemachine)
#+END_SRC


** Programming languages

*** Lisps

There are multiple lispy modes, and we want many of them to be
initialized the same way. So we'll set up some variables to assist
with this
#+BEGIN_SRC emacs-lisp
  (defvar lisp-modes '(emacs-lisp-mode
                       inferior-emacs-lisp-mode
                       ielm-mode
                       lisp-mode
                       inferior-lisp-mode
                       lisp-interaction-mode
                       extempore-mode)
    "A list of Lisp style modes")

  (defvar lisp-mode-hooks
    (--map (intern (concat (symbol-name it) "-hook"))
           lisp-modes)
    "The hook variables associated with our lisp-modes")
#+END_SRC

Configure our base Lisp mode
#+BEGIN_SRC emacs-lisp
  ;; Helpers (move targets)
  (defun pdc/display-syntax (syntax-type)
    (eq syntax-type (syntax-ppss-context (syntax-ppss))))

  (defun pdc/in-syntax-p (syntax-type)
    "This only answers if you're in a comment or string at the moment."
    (eq syntax-type (syntax-ppss-context (syntax-ppss))))

  (defun pdc/in-string-p ()
    (pdc/in-syntax-p 'string))

  (defun pdc/in-comment-p ()
    (pdc/in-syntax-p 'comment))

  (defun pdc/blank-line-p ()
    "Return non-nil iff current line is blank."
    (save-excursion
      (beginning-of-line)
      (looking-at "\\s-*$")))

  (defun pdc/beginning-of-string ()
    "Go to beginning of string around point.
  Do nothing if not in string."
    ;; from loveshack's python-beginning-of-string
    (interactive)
    (if (and (not (pdc/in-string-p))
             (save-excursion
               (backward-char)
               (pdc/in-string-p)))
        (backward-char))
    (let ((state (syntax-ppss)))
      (when (eq 'string (syntax-ppss-context state))
        (goto-char (nth 8 state)))))

  (defun pdc/end-of-string ()
    (interactive)
    (if (and (not (pdc/in-string-p))
             (save-excursion
               (forward-char)
               (pdc/in-string-p)))
        (forward-char))
    (if (pdc/in-string-p)
        (progn
          (pdc/beginning-of-string)
          (forward-sexp))))

  (defun pdc/mark-string ()
    (interactive)
    (if (pdc/in-string-p)
        (progn
          (pdc/beginning-of-string)
          (forward-char)
          (push-mark nil nil t)
          (pdc/end-of-string)
          (backward-char))))

  (defun pdc/forward-string (&optional backward)
    (interactive)
    (if (pdc/in-string-p)
        (pdc/end-of-string))
    (while (not (pdc/in-string-p))
      (if backward
          (backward-char)
        (forward-char))))

  (defun pdc/backward-string ()
    (interactive)
    (if (pdc/in-string-p)
        (pdc/beginning-of-string))
    (pdc/forward-string t)
    (pdc/beginning-of-string)
    (forward-char))

  (defun pdc/out-sexp (&optional level forward syntax)
    "Skip out of any nested brackets.
   Skip forward if FORWARD is non-nil, else backward.
   If SYNTAX is non-nil it is the state returned by `syntax-ppss' at point.
   Return non-nil if and only if skipping was done."
    (interactive)
    (if (pdc/in-string-p)
        (pdc/beginning-of-string))
    (progn
      (let* ((depth (syntax-ppss-depth (or syntax (syntax-ppss))))
             (level (or level depth))
             (forward (if forward -1 1)))
        (unless (zerop depth)
          (if (> depth 0)
              ;; Skip forward out of nested brackets.
              (condition-case ()            ; beware invalid syntax
                  (progn (backward-up-list (* forward level)) t)
                (error nil))
            ;; Invalid syntax (too many closed brackets).
            ;; Skip out of as many as possible.
            (let (done)
              (while (condition-case ()
                         (progn (backward-up-list forward)
                                (setq done t))
                       (error nil)))
              done))))))

  (defun pdc/flash-region (beg end)
    (interactive "r")
    (let ((ovl (make-overlay beg end))
          (was-mark-active mark-active))
      (setq mark-active nil)
      (overlay-put ovl 'face 'highlight)
      (run-with-timer 0.5 nil
                      (lambda (ovl was-mark-active)
                        (delete-overlay ovl)
                        (setq mark-active was-mark-active))
                      ovl was-mark-active)))

  (defun pdc/indent-sexp ()
    "http://mihai.bazon.net/projects/editing-javascript-with-emacs-js2-mode
    can be used from any coding major mode"
    (interactive)
    (save-restriction
      (save-excursion
        (widen)
        (let* ((inhibit-point-motion-hooks t)
               (parse-status (syntax-ppss (point)))
               (beg (nth 1 parse-status))
               (end-marker (make-marker))
               (end (progn (goto-char beg) (forward-list) (point))))
          (pdc/flash-region beg end)
          (set-marker end-marker end)
          (goto-char beg)
          (while (< (point) (marker-position end-marker))
            ;; don't reindent blank lines so we don't set the "buffer
            ;; modified" property for nothing
            (beginning-of-line)
            (unless (looking-at "\\s-*$")
              (indent-according-to-mode))
            (forward-line))))))

  (req-package autoinsert)
  (req-package finder)

  (req-package auto-compile
    :init (setq load-prefer-newer t)
    :config (auto-compile-on-load-mode))

  (req-package lisp-mode
    :require finder paredit
    :demand t
    :config

    (defun pdc/goto-match-paren (arg)
      "Go to the matching parenthesis if on parenthesis. Else go up to the opening parenthesis one level up."
      (interactive "p")
      (cond ((looking-at "\\s(") (forward-list 1))
            (t
             (backward-char 1)
             (cond ((looking-at "\\s\)")
                    (forward-char 1)
                    (backward-list 1))
                   (t
                    (while (not (looking-at "\\s\)"))
                      (backward-char 1)
                      (cond ((looking-at "\\s\)")
                             (backward-char 1)
                             (when (looking-at "\\s\)")
                               (forward-char 1)
                               (backward-list 1)
                               (backward-char 1))))))))))

    (defun pdc/replace-sexp ()
      (interactive)
      (if (pdc/in-string-p)
          (pdc/mark-string)
        (mark-sexp))
      (delete-region (point) (mark))
      (yank))


    (defun my-lisp-mode-hook ()
      (auto-fill-mode -1)
      (paredit-mode +1)
      ;; (redshank-mode 1)
      ;; (elisp-slime-nav-mode 1)
      (add-hook 'after-save-hook 'check-parens
                nil t)
      (yas-minor-mode 1))

    (hook-into-modes 'my-lisp-mode-hook lisp-mode-hooks))

  (req-package eldoc
    :diminish eldoc-mode)

  (req-package elisp-mode
    :require lisp-mode
    :demand t
    :general
    (pdc|with-leader
     "e c" 'finder-commentary
     "e e" 'view-echo-area-messages
     "e f" 'find-function
     "e F" 'find-face-definition)
     :config
     (defun pdc/elisp-mode-hook ()
       (eldoc-mode 1)
       (setq mode-name "EL"))
     (add-hook 'emacs-lisp-mode-hook 'pdc/elisp-mode-hook ())
     (setq emacs-lisp-mode-hook (-remove-item 'lexbind-mode emacs-lisp-mode-hook)))


  (req-package paredit
    :commands paredit-mode
    :demand t
    :diminish " Ⓟ"
    :bind
    (:map paredit-mode-map
          ("DEL" . pdc/paredit-backward-delete)
          ("M-RET" . pdc/indent-defun)
          ("C-M-l" . paredit-recentre-on-sexp)
          ("C-M-s" . paredit-backward-up)
          ("C-M-k" . paredit-forward-slurp-sexp)
          ("C-M-j" . paredit-backward-slurp-sexp)
          ("C-M-\\" . pdc/indent-then-snap-to-indent)
          ("M-o" . pdc/paredit-open-line)
          ("C-M-y" . pdc/replace-sexp)
          ("C-M-y" . pdc/replace-sexp)
          ("C-y" . pdc/paredit-yank)
          ("(" . pdc/paredit-open-parenthesis)
          (";" . pdc/paredit-semicolon)
          ("M-w" . pdc/paredit-kill-ring-save)
          (")" . paredit-close-round-and-newline)
          ("M-)" . paredit-close-round)
          ("M-k" . paredit-raise-sexp)
          ("M-I" . paredit-splice-sexp)
          )
    :general
    (pdc|with-mode-leader :keymaps 'paredit-mode-map
     "d" 'paredit-forward-down
     "B" 'paredit-splice-sexp-killing-backward
     "C" 'paredit-convolute-sexp
     "F" 'paredit-splice-sexp-killing-forward
     "a" 'paredit-add-to-next-list
     "A" 'paredit-add-to-previous-list
     "j" 'paredit-join-with-next-list
     "J" 'paredit-join-with-previous-list)

    :init
    (bindings|add-toggle paredit-mode :toggle-keys "Tp")

    :config
    (defun pdc/indent-defun ()
      (interactive)
      (save-excursion
        (pdc/out-sexp)
        (forward-char)
        (pdc/indent-sexp)))

    (defun pdc/paredit-backward-delete ()
      (interactive)
      (if mark-active
          (call-interactively 'delete-region)
        (paredit-backward-delete)))

    (defun pdc/indent-defun-or-region ()
      (interactive)
      (if mark-active
          (call-interactively 'indent-region)
        (pdc/indent-defun)))

    (defun pdc/indent-then-snap-to-indent ()
      (interactive)
      (pdc/indent-defun-or-region)
      (back-to-indentation))

    (defun pdc/paredit-yank ()
      (interactive)
      (call-interactively 'yank)
      (unless mark-active
        (when (and (looking-back "\)" 1)
                   (looking-at "\("))
          (reindent-then-newline-and-indent)
          (when (looking-at-p "^")
            (newline))))
      (condition-case nil (pdc/indent-defun)))

    (defun pdc/paredit-open-line ()
      (interactive)
      (save-excursion
        (reindent-then-newline-and-indent))
      (indent-according-to-mode))

    (defun pdc/paredit-kill-ring-save ()
      (interactive)
      (if (not mark-active)
          (save-excursion
            (when (looking-at-p " +\(")
              (search-forward "(")
              (backward-char))
            (mark-sexp)
            (call-interactively 'kill-ring-save))
        (call-interactively 'kill-ring-save)))

    (defun pdc/paredit-open-parenthesis (&optional n)
      (interactive "P") 
      (cond ((and (looking-back "\(" 1)
                  (looking-at "\)"))
             (paredit-open-parenthesis n))
            ((equal last-command this-command)
             (undo)
             (insert " ")
             (backward-char 1)
             (paredit-open-parenthesis n))
            ((and (not (or mark-active (pdc/in-string-p)))
                  (looking-at-p "[\(a-z\"#\\[{]"))
             (mark-sexp)
             (paredit-open-parenthesis n)
             (when (looking-at-p "[\(\"#\\[{]")
               (save-excursion (insert " "))))
            (t (paredit-open-parenthesis n))))

    (defun pdc/paredit-semicolon (&optional n)
      (interactive "P")
      (when (looking-at-p "  +\(")
        (search-forward "(")
        (backward-char))
      (cond ((or (looking-back ";" 1)
                 (looking-at-p "[[:blank:]]*$"))
             (self-insert-command 1))
            ((equal last-command this-command)
             (undo)
             (self-insert-command 1))
            ((and (not mark-active) 
                  (looking-at-p "^[[:blank:]]*$"))
             (insert ";;; "))
            ((and (not mark-active)
                  (save-excursion
                    (beginning-of-line)
                    (looking-at-p "[[:blank:]]*$")))
             (insert ";; "))
            (t (paredit-semicolon n))))

    (unbind-key "M-r" paredit-mode-map)
    (unbind-key "M-s" paredit-mode-map)

    (defun pdc/in-slime-repl-p ()
      (equal mode-name "REPL")))
#+END_SRC

*** Emacs Lisp
#+BEGIN_SRC emacs-lisp
  (req-package macrostep
    :general
    (pdc|with-leader :infix elisp-infix-key
     "m" 'macrostep-expand)
    (pdc|with-mode-leader :keymaps 'emacs-lisp-mode-map
     "e" 'macrostep-expand))

#+END_SRC


* Org-mode
Yeah, yeah, org-mode. Everyone raves.

** Org-journal
#+BEGIN_SRC emacs-lisp
  (req-package org-journal
    :requires (org autoinsert)
    :init
    (defun pdc/journal-title ()
      "The journal heading based on the file's name"
      (let* ((year (string-to-number (substring (buffer-name) 0 4)))
             (month (string-to-number (substring (buffer-name) 4 6)))
             (day (string-to-number (substring (buffer-name) 6 8)))
             (datim (encode-time 0 0 0 day month year)))
        (format-time-string org-journal-date-format datim)))

    (defun pdc|journal-file-insert ()
      "Insert the heading based on the file's name."
      (interactive)
      (insert (journal-title))
      (insert "\n\n")

      (when (equal (file-name-base (buffer-file-name))
                   (format-time-string "%Y%m%d"))
        (when (file-exists-p "journal-dailies-end.org")
          (insert-file-contents "journal-dailies-end.org")
          (insert "\n"))

        (let ((weekday-template (downcase (format-time-string)
                                          "journal-%a.org")))
          (when (file-exists-p weekday-template)
            (insert-file-contents weekday-template)))
        (when (file-exists-p "journal-dailies.org")
          (insert-file-contents "journal-dailies.org"))
        (previous-line 2)))

    :config
    (define-auto-insert "/[0-9]\\{8\\}$" [pdc|journal-file-insert]))

#+END_SRC

** Org-mode

Load org and set up bindings under our leader keys. Includes some utility commands under `init`

#+BEGIN_SRC emacs-lisp
  (use-package org
#+END_SRC
#+BEGIN_SRC emacs-lisp
  :requires counsel
  :diminish org-indent
  :general
  (pdc|with-leader :infix "o"
                   "a" 'org-agenda
                   "b" 'org-switchb
                   "c" '(org-capture :which-key "capture")
                   "j" '(org-journal-new-entry :which-key "new journal entry")
                   "l" 'org-store-link)

  (pdc|with-mode-leader :keymaps '(org-mode-map)
                        "h" '(:ignore t :which-key "structure")
                        "h n" '(org-insert-heading-respect-content :which-key "new")
                        "h s" 'org-insert-subheading

                        "c" '(:ignore t :which-key "clock")
                        "c i" '(org-clock-in :which-key "in")
                        "c i" '(org-clock-in :which-key "in")
                        "c o" '(org-clock-out :which-key "out")
                        "c d" '(org-clock-mark-default-task :which-key "clock-mark-default-task")
                        "c ." '(org-time-stamp :which-key "time-stamp")
                        "c c" '(org-clock-cancel :which-key "cancel")
                        "c _" '(org-clock-select-task :which-key "select-task")
                        "c -" '(org-clock-goto :which-key "goto")
                        "c '" '(pdc|org-goto-select-task :which-key "goto-select-task")
                        "c g" '(pdc|org-refile-goto :which-key "refile-goto")
                        "c l" '(pdc|org-refile-goto-last :which-key "goto-last-refile")

                        "r" '(pdc|org-reload-compiled :which-key "Reload org-mode (after update)")
                        "R" '(pdc|org-reload-uncompiled :which-key "Reload org-mode uncompiled"))
  :init
  (defun pdc|org-goto-select-task ()
    (interactive)
    (org-clock-goto '(4)))
  (defun pdc|org-refile-goto ()
    (interactive)
    (org-refile '(4)))
  (defun pdc|org-refile-goto-last ()
    (interactive)
    (org-refile '(16)))
  (defun pdc|org-reload-uncompiled ()
    (interactive)
    (org-reload '(4)))
  (defun pdc|org-reload-compiled ()
    (interactive)
    (org-reload))

  (setq org-directory (expand-file-name "~/Dropbox"))
#+END_SRC

*** Babel

#+BEGIN_SRC emacs-lisp
    :config
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (shell . t)
       (perl . t)
       (haskell . t)))
    (setq org-confirm-babel-evaluate nil
          org-src-fontify-natively t
          org-src-tab-acts-natively t
          org-iswitchb-completing-read 'ivy-completing-read)
#+END_SRC

*** Capture
#+BEGIN_SRC emacs-lisp
  (require 'org-contacts)
  (setq org-default-notes-file (concat org-directory "/notes.org"))
  (setq org-capture-templates
        `(("t" "Todo" entry (file+headline ,(concat org-directory "/gtd.org") "Tasks")
               "* TODO %?\n  %i\n  %a")
          ("F" "Folk contacts")
          ("Ff" "Festival" entry (file+datetree+prompt ,(concat org-directory "/gig-contacts.org") "Festivals")
           (file ,(concat org-directory "/capture-templates/festival.otpl")))
          ))
#+END_SRC

*** Agenda
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files `(,org-directory "~/Documents/journal"))
#+END_SRC



*** Close the req-package

It's ugly lisp, but it keeps paredit relatively happy with our fragments. 

#+BEGIN_SRC emacs-lisp
)
#+END_SRC

*** Org exporters

#+BEGIN_SRC emacs-lisp
  (req-package ox-gfm
    :requires org)

  (req-package autoinsert)
#+END_SRC

