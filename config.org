# -*- mode: org; coding: utf-8 -*-
#+TODO: ACTIVE | DISABLED
#+TODO: TODO CURRENT | DONE
#+STARTUP: indent

This is the Emacs config file of Piers Cawley.

This file is named =config.org=. =init.el= contains bootstrap code
that tangles (only) the Elisp blocks into =config.el=, which is
interpreted by Emacs on startup.

Note that all Elisp blocks which are part of a =DISABLED= heading, or
which are marked with =:tangle no= won't be tangled to the =config.el=
file. This will also make the invisible to Github's Org-mode
rendering, so the best place to read this is within Emacs.

This approach is shamelessly lifted from [[https://github.com/novoid/dot-emacs/][Novoid's dot-emacs]]. 

* Roadmap

Some near-future plans for =config.org=:

- [X] yasnippet setup (life is too short to type =#+BEGIN_SRC
  emacs-lisp= everywhere
- [X] Leader key based keymaps
- [X] req-package based configuration and installation
- Prog-modes
  - [ ] Perl
  - [1/3] Lisps
    - [X] Emacs Lisp
    - [ ] Scheme
    - [ ] Extempore
  - [ ] Javascript
- Blogging
  - [ ] Multi-hugo support
  - Maybe blogging from org-mode?
- Navigation
  - [X] Avy-jump
  - [X] Swiper
  - [ ] Bookmarks
- Org mode
  - [ ] Sort out a workflow
  - Stick to it

* General settings and bootstrapping

profiling:
#+BEGIN_SRC emacs-lisp
  (defvar my-config-el-start-time (current-time)
    "Time when config.el was started")
#+END_SRC

Turn off backup files
#+BEGIN_SRC emacs-lisp
(setq backup-inhibited t)
#+END_SRC

set start of week to Monday (not sunday) http://sunsite.univie.ac.at/textbooks/emacs/emacs_33.html
#+BEGIN_SRC emacs-lisp
(setq calendar-week-start-day 1)
#+END_SRC

don't indent with tabs
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

set warning of opening large files to 100MB
#+BEGIN_SRC emacs-lisp
(setq large-file-warning-threshold 100000000)
#+END_SRC

do not add double space after periods [[http://www.reddit.com/r/emacs/comments/2l5gtz/real_sentence_in_emacs/][Real sentence in Emacs : emacs]]
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

inhibit the startup screen
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t)
#+END_SRC

I'm okay with narrowing
#+BEGIN_SRC emacs-lisp
(put 'narrow-to-region 'disabled nil)
#+END_SRC

Add a nice short alias for ~with-eval-after-load~

#+BEGIN_SRC emacs-lisp
  (defalias 'after-loading 'with-eval-after-load)
#+END_SRC

** Finding Emacs lisp

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (concat my-user-emacs-directory "vendor/"))
(add-to-list 'load-path (concat my-user-emacs-directory "elisp/"))
#+END_SRC

** Support functions

*** hook-into-modes
#+BEGIN_SRC emacs-lisp
(defmacro hook-into-modes (func modes)
  `(--each ,modes (add-hook it ,func)))
#+END_SRC

** Package

Configure the package manager

=package-user-dir= holds the directory where ELPA installs its local
copies of the packages:

#+BEGIN_SRC emacs-lisp
(setq package-user-dir (concat my-user-emacs-directory "elpa"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (package-initialize)
  (add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/"))
  ;; unstable
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))
  (add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/packages/"))

  (setq package-archive-priorities
        '(("melpa-stable" . 10)
          ("melpa" . 5)
          ("org" . 15)
          ("gnu" . 0)))

  (package-refresh-contents)
#+END_SRC

Initialize our package managment and key binding:

#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (progn
      (setq package-enable-at-startup nil)
      (require 'pdc-leader)
      (require 'general)
      (require 'use-package)
      (use-package req-package
        :init
        (add-hook 'after-init-hook (lambda () (req-package-finish)))
        :config
        (progn
          (req-package--log-enable-messaging)
          (req-package--log-enable-debugging)))

      (require 'req-package)
      (require 'cl)))

  (setq use-package-verbose t)
  (use-package diminish
    :ensure t)
  (use-package bind-key
    :ensure t)
#+END_SRC

*** Basic libraries

Some libraries just make life easier so we should just load them up
unconditionally and not worry about dealing with dependencies on them
and fencing some of our helper functions in calls to =req-package= to
ensure that the prereqs are required.

**** dash.el
A modern lisp manipulation library
#+BEGIN_SRC emacs-lisp
  (use-package dash
    :ensure t)
  (eval-when-compile (require 'dash))
#+END_SRC

**** s.el
A modern string manipulation library
#+BEGIN_SRC emacs-lisp
  (use-package s
    :ensure t)
  (eval-when-compile (require 's))
#+END_SRC

**** kv.el
A modern library for messing with dictionaries
#+BEGIN_SRC emacs-lisp
  (use-package kv
    :ensure t)
  (eval-when-compile (require 'kv))
#+END_SRC

** Get the environment from the shell
#+BEGIN_SRC emacs-lisp
  (when (memq window-system '(mac-ns ns))
    (use-package exec-path-from-shell
      :ensure t
      :init
      (setq exec-path-from-shell-arguments (list "-l"))
      (exec-path-from-shell-initialize)))
#+END_SRC

** Never type "yes" when "y" will do

=yes-or-no-p= can die in a fire

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Eliminate duplicates from the minibuffer history

#+BEGIN_SRC emacs-lisp
(setq history-delete-duplicates t)
#+END_SRC

** no-littering

From:
- [[http://manuel-uberti.github.io/programming/2017/06/17/nolittering/][Manuel Uberti: Keeping your .emacs.d clean]]
- https://github.com/tarsius/no-littering

It sets some default paths in order to separate automatically created
files and directories.

#+BEGIN_SRC emacs-lisp
  (use-package no-littering
    :ensure t
    :config
    ;; Don't shit autosave files all over the place
    (setq auto-save-file-name-transforms
          `(("\\`/[^/]*:\\([^/]*/\\)*\\([^/]*\\)\\'" ,(no-littering-expand-var-file-name "auto-save/\\2") t)
            (".*" ,(no-littering-expand-var-file-name "auto-save/") t))))
#+END_SRC

* Styling

Making emacs look nice

Show current column:
#+BEGIN_SRC emacs-lisp
(setq column-number-mode t)
#+END_SRC

Cursor settings:
#+BEGIN_SRC emacs-lisp
;; Prevent the cursor from blinking
(blink-cursor-mode 0)
#+END_SRC

Turn off the visible bell:
#+BEGIN_SRC emacs-lisp
(setq visible-bell nil)
#+END_SRC

Make sure we have more emoji
#+BEGIN_SRC emacs-lisp
    (use-package emoji-fontset
      :ensure t
      :config
      (setq emoji-fontset-check-version 'force)
      (emoji-fontset-enable "Symbola")
      ;(emoji-fontset-enable "Apple Color Emoji")
      )
#+END_SRC

Turn off the toolbar
#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
#+END_SRC



** Spaceline
#+BEGIN_SRC emacs-lisp
  (use-package which-func :ensure t)

  (use-package powerline :ensure t
    :config
    (defun pdc/customize-powerline-faces ()
      "Alter powerline faces to make them work with more themes"
      (set-face-attribute 'powerline-inactive2 nil
                          :inherit 'font-lock-comment-face))
    (pdc/customize-powerline-faces))

  (use-package spaceline :ensure t
    :commands spaceline-compile
    :init
    (setq powerline-default-separator (if (display-graphic-p) 'brace 'utf-8)
          powerline-height 24)
    (spaceline-compile)
  
    :config
    (require 'spaceline-config)

    (defun pdc//restore-powerline (buffer)
      "Restore the powerline in buffer"
      (with-current-buffer buffer
        (setq-local mode-line-format (default-value 'mode-line-format))
        (powerline-set-selected-window)
        (powerline-reset)))

    (setq spaceline-org-clock-p nil)

    (setq spaceline-window-numbers-unicode t
          spaceline-workspace-numbers-unicode t)

    (defun pdc//prepare-diminish ()
      (when spaceline-minor-modes-p
        (setq spaceline-minor-modes-separator
              (if (display-graphic-p) "" " "))))
    (add-hook 'spaceline-pre-hook 'pdc//prepare-diminish)
    (spaceline-toggle-hud-on)
    (spaceline-toggle-line-column-off)
    (spaceline-emacs-theme))

#+END_SRC

** Diminish some modes
#+BEGIN_SRC emacs-lisp
  (diminish 'auto-fill-function " Ⓕ")
  (req-package autorevert :ensure t
  :diminish (auto-revert-mode . " ⎌"))

  ;;; These will be moved to org-mode config when we have an org-mode
  ;;; config section
  (after-loading 'org-src
    (diminish 'org-src-mode " ⓞ")
    (setq org-src-window-setup 'current-window))
  (after-loading 'org-indent
    (diminish 'org-indent-mode))
#+END_SRC


** Themes

Zenburn, it's the only way to be sure!

#+BEGIN_SRC emacs-lisp
  (use-package zenburn-theme
    :ensure t
    :init
    (load-theme 'zenburn t))
#+END_SRC

** Only one window on startup

#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-startup-hook 'delete-other-windows t)
#+END_SRC

** Pretty symbols
#+BEGIN_SRC emacs-lisp
  (global-prettify-symbols-mode)
#+END_SRC

** Font sizes

#+BEGIN_SRC emacs-lisp
  (use-package default-text-scale :ensure t
    :general
    (pdc|with-leader
      "+" 'default-text-scale-increase
      "=" 'default-text-scale-increase
      "-" 'default-text-scale-decrease))
#+END_SRC
** Highlight TODO etc in comments and strings
#+BEGIN_SRC emacs-lisp
  (use-package hl-todo :ensure t
    :init
    (hook-into-modes 'hl-todo-mode '(text-mode-hook prog-mode-hook)))

#+END_SRC
** Display battery info in modeline
#+BEGIN_SRC emacs-lisp
  (use-package fancy-battery :ensure t
    :init
    (bindings|add-toggle mode-line-battery
      :mode fancy-battery-mode
      :documentation "Display battery info in mode-line"
      :toggle-keys  "Tb"))

#+END_SRC


* UTF-8 and codings

Activate UTF-8 mode:
#+BEGIN_SRC emacs-lisp
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)

  (set-clipboard-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+END_SRC

* Leader key based bindings

** Leader keys and maps
#+BEGIN_SRC emacs-lisp :tangle no
  (defvar leader-map (make-sparse-keymap))
  (defvar leader-key "M-m")
  ;(global-set-key (kbd leader-key) nil)

  (defvar mode-leader-key "M-,"
    "Prefix for mode specific leader")
#+END_SRC

** Supporting packages
which-key:
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package which-key
    :diminish " Ⓚ"
    :init
    (bindings|add-toggle which-key-mode :toggle-keys "TK")
    (which-key-mode)
    :config
    (let ((new-descriptions
           '(("select-window-\\"0-9 "\\)" . "window \\1")
             ("avy-goto-word-or-subword-1" . "avy»word")
             ("shell-command" . "shell cmd")
             ("universal-argument" . "universal arg")
             ("er/expand-region" . "expand region"))))
      (dolist (nd new-descriptions)
        (push (cons (concat "\\`" (car nd) "\\'") (cdr nd))
              which-key-description-replacement-alist)))
    (setq which-key-special-keys nil
          which-key-echo-keystrokes 0.02
          which-key-max-description-length 32
          which-key-sort-order 'which-key-key-order-alpha
          which-key-idle-delay 0.4))
#+END_SRC

hydra:
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package hydra :ensure t
    :commands defhydra
    :init
    (setq hydra-head-format "%s → ")
    :config)
#+END_SRC


** Supporting macros
These define space keymaps under the leader key
#+BEGIN_SRC emacs-lisp :tangle no
  (defun bindings|expand-define-prefix (desc key docstr)
    (let* ((descname (symbol-name desc))
           (leader-variable-name (intern (format "%s-leader-key" descname)))
           (infix-variable-name (intern (format "%s-infix-key" descname)))
           (prefix-variable-name-deprecated (intern (format "%s-prefix-key" descname)))
           (doc (or docstr (symbol-name desc))))
      `(progn
         (defvar ,leader-variable-name (format "%s %s" leader-key ,key)
           ,(format "leader-key + prefix for %s" doc))
         (defvar ,infix-variable-name ,key
           ,(format "infix for %s - use with `pdc|with-leader :infix %s' type commands" doc infix-variable-name))
         (defvar ,prefix-variable-name-deprecated ,infix-variable-name
           ,(format "Obsolete copy of %s" infix-variable-name))
         (make-obsolete ',prefix-variable-name-deprecated ',infix-variable-name "2017-08-27")
         (which-key-add-key-based-replacements ,leader-variable-name ,doc))))


  (defmacro bindings|define-prefix (desc key &optional docstr)
    (declare (indent 1))
    (bindings|expand-define-prefix desc key docstr))

  (defmacro bindings|define-prefix-1 (descvar key docstr)
    (declare (indent 1))
    `(eval (bindings|expand-define-prefix `,,descvar ,key ,docstr)))

#+END_SRC

** Keymap prefixes

The idea is that most of our commands come under a tree of prefixes,
all initiated from the primary leader key. The prefixes are
essentially sparse keymaps, and I've not worked out how to easily
define them on the fly, so we predeclare the major branches of our
tree here.

We use =use-package ... :ensure t= here rather than =req-package= to
ensure that =pdc|with-leader= is avaialable to the =:general= clause
of subsequent calls to =req-package=

*** Our prefixes

#+NAME: prefixes
| name            | keys | description            |
|-----------------+------+------------------------|
|                 | C-t  | other-toggles          |
| color           | C    | colours                |
| package         | P    | packages               |
| elisp           | Re   |                        |
| pcre            | Rp   |                        |
|                 | T    | UI toggles/themes      |
| applications    | a    | apps                   |
| shell           | as   | shells                 |
| buffer          | b    | buffers                |
|                 | c    | compile/comments       |
| error           | e    | errors                 |
| file            | f    | files                  |
| file-convert    | fC   | files/convert          |
| emacs-d         | fe   | emacs                  |
| variable        | fv   | variables              |
| git             | g    | git/version-control    |
| help            | h    |                        |
|                 | hA   | apropos                |
| help-describe   | hd   | describe               |
| insertion       | i    |                        |
| jump            | j    | jump/join/split        |
| lisp            | k    |                        |
| delete-backward | kD   |                        |
| hybrid          | k`   |                        |
| delete          | kd   |                        |
| cursor          | m    | marks/cursors          |
| narrow          | n    | narrow/number          |
| org             | o    |                        |
| project         | p    | projects               |
|                 | p$   | projects/shell         |
| quit            | q    |                        |
| replace         | r    | registers/rings/resume |
| search          | s    | search/symbol          |
| ag              | sa   |                        |
| grep            | sg   |                        |
| ack             | sk   |                        |
| pt              | st   |                        |
| web             | sw   |                        |
|                 | t    | toggles                |
|                 | t    | toggles                |
|                 | tC   | colours                |
|                 | th   | highlight              |
|                 | tm   | modeline               |
| window          | w    | windows                |
|                 | wp   | popup                  |
|                 | x    | text                   |
|                 | xa   | align                  |
|                 | xd   | delete                 |
|                 | xg   | google-translate       |
|                 | xl   | lines                  |
|                 | xm   | move                   |
|                 | xt   | transpose              |
|                 | xw   | words                  |
|                 | z    | zoom                   |

*** Support prefix declaration and access

We used to use a bunch of poorly namespaced variables to track our
leader key prefix declarations, but this risks name clashes and has
made macro writing a wee bit tricky. A better approach seems to be to
manage our own prefix registry

**** TODO Roadmap [0/3]
- [ ] Similar support for mode leader prefixes
- [ ] Sweetener for =general-define-key=
- [ ] Better toggles

*** Load general keybinding support

We load =general.el= using =(use-package :ensure t ...)= here because
=general= needs to be loaded and working in order for =req-package= to
handle the =:general= clauses we use for our keybindings. 

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package general
    :ensure t
    :config
    (use-package hydra
      :ensure t)
    (use-package which-key
      :ensure t)

    (general-define-key mode-leader-key '(nil :which-key "mode-leader"))
    (general-define-key leader-key '(nil :which-key "leader"))

    (general-create-definer pdc/with-leader
                            :prefix leader-key :keymaps 'global)
    (put 'pdc/with-leader 'lisp-indent-function 'defun)

    (general-create-definer pdc|with-mode-leader
                            :prefix mode-leader-key)
    (put 'pdc|with-mode-leader 'lisp-indent-function 'defun)

    (pdc|with-leader
      "h" (list help-map :which-key "help")))

  (defun pdc/mplist-get (plist prop)
    "Get the values associated to PROP in PLIST, a modified plist.

  A modified plist is one where keys are keywords and values are
  all non-keywords elements that follow it.

  If there are multiple properties with the same keyword, only the first property
  and its values is returned.

  Currently this function infloops when the list is circular."
    (let ((tail plist)
          result)
      (while (and (consp tail) (not (eq prop (car tail))))
        (pop tail))
      ;; pop the found keyword
      (pop tail)
      (while (and (consp tail) (not (keywordp (car tail))))
        (push (pop tail) result))
      (nreverse result)))

  (defvar bindings-toggles '()
    "List of all declared toggles.
  The strucutre of an element is a property list (name :func FUNCTION :doc STRING :key STRING).")

  (defun bindings//expand-add-toggle (name props)
    (let* ((docstr (if (stringp (car props))
                            (pop props)))
           (mode (plist-get props :mode) )
           (wrapper-func (intern (format "toggle|%s"
                                         (symbol-name name))))
           (wrapper-func-on (intern (format "%s-on" wrapper-func)))
           (wrapper-func-off (intern (format "%s-off" wrapper-func)))
           (wrapper-func-status (intern (format "%s-status" wrapper-func)))
           (status (or (plist-get props :status) mode name))
           (doc (or (plist-get props :documentation)
                    docstr))
           (on-body (if mode `((,mode)) (pdc/mplist-get props :on)))
           (off-body (if mode `((,mode -1)) (pdc/mplist-get props :off)))
           (prefix-arg-var (plist-get props :prefix))
           (on-message (plist-get props :on-message))
           (condition (plist-get props :if))

           (status-eval `(and (or (and (symbolp ',status) (boundp ',status))
                                  (listp ',status))
                              ,status))
           ;; If we're defined by `define-minor-mode this will toggle
           ;; the mode
           (toggle-body (or (pdc/mplist-get props :toggler)
                            (if (or on-body off-body)
                                `(if ,status-eval
                                     (progn ,@off-body)
                                   ,@on-body)
                              `(,name 'toggle))))
           (keymaps (pdc/mplist-get props :keymaps))
           (binding (plist-get props :toggle-keys)))
      `(progn

         (push (append '(,name)
                       '(:function ,wrapper-func
                                   :predicate ,wrapper-func-status)
                       ',props)
               bindings-toggles)

         ;; toggle function
         (defun ,wrapper-func ,(if prefix-arg-var (list prefix-arg-var) ())
           ,(format "Toggle %s on and off." (symbol-name name))
           (interactive ,@(when prefix-arg-var (list prefix-arg-var)))
           (if (or (null ',condition)
                   (and (or (and (symbolp ',condition) (boundp ',condition))
                            (listp ',condition))
                        ,condition))
               (progn
                 ,toggle-body
                 ,(if on-message
                      `(message (if ,status-eval on-message (format "%s disabled." ,(symbol-name name))))
                    `(message (let ((enabled ,status-eval))
                                (format "%s %s." (quote ,name) (if ,status-eval "enabled" "disabled"))))))
             (message "This toggle is not supported")))

         (defun ,wrapper-func-status ()
           ,status-eval)

         ,@(when status
             `((defun ,wrapper-func-on ()
                 ,(format "Toggle %s on" (symbol-name name))
                 (interactive)
                 (unless ,status-eval (,wrapper-func)))
               (defun ,wrapper-func-off ()
                 ,(format "Toggle %s off." (symbol-name name))
                 (interactive)
                 (when ,status-eval (,wrapper-func)))))
         ,@(when binding
             `((pdc|with-leader ,@(if keymaps `(:keymaps ',keymaps))
                 ,binding '(,wrapper-func :which-key
                                          ,(or doc (symbol-name name)))))))))


  (defmacro bindings|add-toggle (name &rest props)
    (declare (indent 1))
    (bindings//expand-add-toggle name props))

  (defun pdc/shortdoc (fn)
    (when-let* ((doc (documentation fn)))
      (substring doc 0 (string-match "\n" doc))))

  (defun pdc//bind-hydra-spec (spec leader)
    (pcase spec
      (`(,key ,fn ,desc . ,(pred (lambda (props)
                                   (plist-get props :exit))))
       (let ((keys (concat leader " " key)))
         (general-define-key :prefix leader-key
                             keys (list fn :which-key desc))))
      (`(,key ,_ ,desc . ,(and props
                               (pred (lambda (props)
                                       (not (plist-get props :exit))))))
       (let ((hydra-fn (plist-get props :cmd-name))
             (long-leader (concat leader-key " " leader)))
         (general-define-key :prefix long-leader
                             key (list hydra-fn :which-key desc))))))


  (defmacro pdc|general-bind-hydra
      (name leader &key no-cancel &allow-other-keys &rest specs)
    "Bind a hydra in such a way that others can share the prefix."
    (declare (indent defun))
    (cl-flet
        ((canonicalize-spec (spec)
                            (let* ((key (car spec))
                                   (action (cadr spec))
                                   (tail (cddr spec))
                                   (caption (cond ((stringp (car tail))
                                                   (pop tail))
                                                  ((symbolp action)
                                                   (symbol-name action))
                                                  ((functionp action)
                                                   (pdc/shortdoc action))
                                                  (t "??"))))
                              `(,key ,action ,caption ,@tail
                                     :cmd-name ,(intern
                                                 (format "hydra-%s/%s" name action))))))
      (let ((hydra-key (intern (format "hydra-%s" (symbol-name name))))
            (specs (-map #'canonicalize-spec specs)))
        `(progn
           (defhydra ,hydra-key (nil nil :color red)
             ,(symbol-name name)
             ,@specs
             ,@ (unless no-cancel '(("q" nil "cancel" :color blue))))
           (--each ',specs
             (pdc//bind-hydra-spec it ,leader))))))

  (put 'pdc|general-bind-hydra 'lisp-indent-function 2)

#+END_SRC


*** Declare the prefixes
#+BEGIN_SRC emacs-lisp :var prefixes=prefixes
  (dolist (it prefixes)
    (pcase-let* ((`(,namestr ,keys ,desc) it)
                 (name (when (not (string= "" namestr))
                         (intern namestr)))
                 (description (if (> (length desc) 0)
                                  desc
                                namestr)))
      (bindings//declare-prefix keys (s-join "/" (list namestr desc)))))

#+END_SRC

*** Initial bindings

**** Universal argument
#+BEGIN_SRC emacs-lisp
  (pdc|with-leader "u" 'universal-argument)

  (define-key universal-argument-map
    (kbd (concat leader-key " u"))
    'universal-argument-more)

#+END_SRC

**** More
#+BEGIN_SRC emacs-lisp
  (pdc|with-leader "!" 'shell-command)

  (pdc|with-leader :infix (:apps)
    "c" 'calc-dispatch
    "p" 'list-processes
    "P" 'proced
    "u" 'undo-tree-visualize)

  (use-package pdc-buffer-helpers
    :config
    (pdc|with-leader "TAB" 'pdc/alternate-buffer)
    (pdc|with-leader :infix (:buffers)
      "C-d" 'pdc/kill-matching-buffers-rudely
      "d" 'pdc/kill-this-buffer
      "e" 'pdc/safe-erase-buffer
      "m" 'pdc/kill-other-buffers
      "n" 'next-buffer
      "N" 'pdc/new-empty-buffer
      "P" 'pdc/copy-clipboard-to-whole-buffer
      "p" 'previous-buffer
      "R" 'pdc/safe-revert-buffer
      "s" 'pdc/switch-to-scratch-buffer
      "w" 'read-only-mode
      "Y" 'pdc/copy-whole-buffer-to-clipboard)
    (cl-loop for n from 1 to 9
             do (pdc|with-leader :infix (:buffers)
                  (format "%i" n)
                  (intern (format "buffer-to-window-%i" n)))))

  (use-package pdc-error-helpers
    :general
    (pdc|with-leader :infix (:errors)
      "n" 'pdc/next-error
      "N" 'pdc/previous-error
      "p" 'pdc/previous-error))


#+END_SRC


* Buffer and window handling
** ibuffer
#+BEGIN_SRC emacs-lisp
  (use-package ibuffer :ensure t
    :config
    (fset 'list-buffers 'ibuffer)
    (defun pdc/list-buffers-int ()
      (interactive)
      (display-buffer (list-buffers-noselect nil))))

#+END_SRC

** ibuffer-vc
#+BEGIN_SRC emacs-lisp
  (use-package ibuffer-vc :ensure t
    :config
    (setq ibuffer-formats
          '((mark pdc-modified vc-status-mini
                  " " (name 35 35 :left :elide)
                  " " filename-and-process)
            (mark " " (name 16 -1) " " filename)))

    (define-ibuffer-column pdc-modified (:name "M" :inline t)
      (if (buffer-modified-p)
          (propertize "-" 'face '(:foreground "yellow"))
        " ")))
#+END_SRC

** Window numbering
Bouncing around windows using their numbers is fast and
straightforward.

#+BEGIN_SRC emacs-lisp
  (use-package winum :ensure t
    :config
    (setq winum-auto-assign-0-to-minibuffer t
          winum-auto-setup-mode-line nil
          winum-ignored-buffers '(" *which-key*"))
    (pdc|with-leader
      "`" 'winum-select-window-by-number
      "0" 'winum-select-window-0-or-10
      "1" 'winum-select-window-1
      "2" 'winum-select-window-2
      "3" 'winum-select-window-3
      "4" 'winum-select-window-4
      "5" 'winum-select-window-5
      "6" 'winum-select-window-6
      "7" 'winum-select-window-7
      "8" 'winum-select-window-8
      "9" 'winum-select-window-9)
  
    ;; (defun window-numbering-install-mode-line (&optional position)
    ;;   "Do nothing, the desplay will be handled by spaceline.")
    (dolist (it (number-sequence 0 9))
      (general-define-key :keymaps 'winum-keymap
                          (format "M-%s" it) nil))

    (winum-mode t))
#+END_SRC

** uniquify
Give buffers unique names
#+BEGIN_SRC emacs-lisp
  (use-package uniquify
    :config
    (setq uniquify-buffer-name-style 'post-forward-angle-brackets)
    (setq uniquify-ignore-buffers-re "^\\*")) ; don't muck with special buffers
#+END_SRC

** winner-mode
An undo tree for window configurations. Really handy.
#+BEGIN_SRC emacs-lisp
  (when (fboundp 'winner-mode)
    (winner-mode 1))
#+END_SRC

** Useful commands
- TODO Use window numbers rather than counts where appropriate [%]
  - [ ] =pdc/transpose-windows=

Various commands that affect windows and window layout

=pdc/toggle-window-split=: Toggle the orientation of a single window split.
#+BEGIN_SRC emacs-lisp
  (defun pdc/toggle-window-split ()
    "Switch between a horizontal and vertical split if there are two windows."
    (interactive)
    (when (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                            (car next-win-edges))
                                        (<= (cadr this-win-edges)
                                            (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car next-win-edges))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))
#+END_SRC

=pdc/transpose-windows=: Swap the buffers between two windows
#+BEGIN_SRC emacs-lisp
  (defun pdc/transpose-windows (arg)
    "Transpose the buffers shown in two windows"
    (interactive "p")
    (let ((selector (if (>= arg 0) 'next-window 'previous-window)))
      (while (/= arg 0)
        (let ((this-win (window-buffer))
              (next-win (window-buffer (funcall selector))))
             (set-window-buffer (selected-window) next-win)
             (set-window-buffer (funcall selector) this-win)
             (select-window (funcall selector)))
        (setq arg (if (plusp arg) (1- arg) (1+ arg))))))

  (defun pdc/rotate-windows ()
    "Rotate your windows"
    (interactive)
    (cond
     ((not (> (count-windows) 1))
      (message "You can't rotate a single window!"))
     (t
      (let ((i 1)
            (num-windows (count-windows)))
        (while  (< i num-windows)
          (let* ((w1 (elt (window-list) i))
                 (w2 (elt (window-list) (+ (% i num-windows) 1)))
                 (b1 (window-buffer w1))
                 (b2 (window-buffer w2))
                 (s1 (window-start w1))
                 (s2 (window-start w2)))
            (set-window-buffer w1 b2)
            (set-window-buffer w2 b1)
            (set-window-start w1 s2)
            (set-window-start w2 s1)
            (setq i (1+ i))))))))
#+END_SRC

=pdc/sync-point-all-windows=: Move the point to the same place in all
windows. Not sure I've ever used this. Might disable it.
#+BEGIN_SRC emacs-lisp

  (defun pdc/sync-point-all-windows (&optional buffer pnt)
    "Synchronise the point in all windows"
    (interactive)
    (let ((buffer (or buffer (current-buffer)))
          (pnt (or pnt (point))))
      (dolist (f (frame-list))
        (dolist (w (window-list f))
          (if (eq (window-buffer w) buffer)
              (set-window-point w pnt))))))
#+END_SRC

=pdc/bury-buffer-other-windows=: The highlander function. When called,
it burys the buffer in the current window in all the other windows,
ensuring that the current window is the only one displaying the buffer.
#+BEGIN_SRC emacs-lisp
  (defun pdc/bury-buffer-other-windows (&optional buffer)
    "Bury the current buffer in all windows but the current one."
    (interactive)
    (let ((buffer (or buffer (current-buffer))))
      (save-window-excursion
        (dolist (f (frame-list))
          (dolist (w (window-list f))
            (if (eq (window-buffer w) buffer)
                (unless (window--delete w t t)
                  (set-window-dedicated-p w nil)
                  (switch-to-prev-buffer w 'kill))))))))
#+END_SRC

=pdc/blank-other-frame-windows=: Sets all other windows in all frames
to display a =*blank*= buffer.
#+BEGIN_SRC emacs-lisp
  (defun pdc/blank-other-frame-windows ()
    (interactive)
    (let ((buffer (get-buffer-create "*blank*")))
      (save-window-excursion
        (dolist (f (frame-list))
          (dolist (w (window-list f))
            (unless (window--delete w t t)
              (set-window-dedicated-p w nil)
              (set-window-buffer w buffer)))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;;; Lifted from spacemacs
  (defun pdc/split-window-below-and-focus ()
    "Split the window vertically and focus the new window."
    (interactive)
    (split-window-below)
    (windmove-down)
    (when (and (boundp 'golden-ratio-mode)
               (symbol-value golden-ratio-mode))
      (golden-ratio)))

  (defun pdc/split-window-right-and-focus ()
    "Split the window horizontally and focus the new window."
    (interactive)
    (split-window-right)
    (windmove-right)
    (when (and (boundp 'golden-ratio-mode)
               (symbol-value 'golden-ratio-mode))
      (golden-ratio)))

  (defun pdc/layout-double-columns ()
    "Set the layout to double columns"
    (interactive)
    (delete-other-windows)
    (split-window-right))


  (defun pdc/layout-triple-columns ()
    "Set the layout to triple columns"
    (interactive)
    (delete-other-windows)
    (dotimes (i 2) (split-window-right))
    (balance-windows))

  (defun pdc/switch-to-minibuffer-window ()
    "Switch to minibuffer window (if active)"
    (interactive)
    (when-let* ((target (active-minibuffer-window)))
      (selete-window target)))

  (defun pdc/delete-window (&optional arg)
    "Delete the current window.

  If the universal prefix argument is used, then kill the buffer too."
    (interactive "P")
    (if (equal '(4) arg)
        (kill-buffer-and-window)
      (delete-window)))

  ;;; TODO Pinch some window motion stuff from Evil

  (defun pdc/toggle-maximize-buffer ()
    "Maximize buffer"
    (interactive)
    (if (and (= 1 (length (window-list))
                (assoc ?_ register-alist)))
        (jump-to-register ?_)
      (window-configuration-to-register ?_)
      (delete-other-windows)))

  (defun pdc/rotate-windows (count)
    "Rotate each window forwards.
  A negative prefix argument rotates each window backwards.
  Dedicated (locked) windows are left untouched."
    (interactive "p")
    (let* ((non-dedicated-windows (remove-if 'window-dedicated-p (window-list)))
           (num-windows (length non-dedicated-windows))
           (i 0)
           (step (+ num-windows count)))
      (cond ((not (> num-windows 1))
             (message "You can't rotate a single window!"))
            (t
             (dotimes (counter (- num-windows 1))
               (let* ((next-i (% (+1 step) num-windows))

                      (w1 (elt non-dedicated-windows i))
                      (w2 (elt non-dedicated-windows next-i))

                      (b1 (window-buffer w1))
                      (b2 (window-buffer w2))

                      (s1 (window-start w1))
                      (s2 (window-start w2)))
                 (set-window-buffer w1 b2)
                 (set-window-buffer w2 b1)
                 (set-window-start w1 s2)
                 (set-window-start w2 s2)
                 (setq i next-i)))))))

  (defun pdc/rotate-windows-backward (count)
    "Rotate each window backwards.
  Dedicated (locked) windows are left untouched."
    (interactive "p")
    (spacemacs/rotate-windows (* -1 count)))

  (defun pdc/maximize-horizontally ()
    "Delete all windwos left or right of the current window."
    (interactive)
    (require 'windmove)
    (save-excursion
      (while (condition-case nil (windmove-left (error nil)))
        (delete-window))
      (while (condition-case nil (windmove-right (error nil)))
        (delete-window))))

#+END_SRC

** Window Keybindings

#+BEGIN_SRC emacs-lisp
  ;;; For the 'evil-window-*' commands. Lift these into the config later
  ;;; since we don't use Evil.

  (use-package evil :ensure t
    :init 
    (require 'evil-commands))
  (pdc|with-leader :infix :windows
    "2" 'pdc/layout-double-columns
    "3" 'pdc/layout-triple-columns
    "b" 'pdc/switch-to-minibuffer-window
    "d" 'pdc/delete-window
    "f" 'follow-mode
    "F" 'make-frame
    ;; To be replaced with non-evil functions
    "H"  'evil-window-move-far-left
    "<S-left>"  'evil-window-move-far-left
    "h"  'evil-window-left
    "<left>"  'evil-window-left
    "J"  'evil-window-move-very-bottom
    "<S-down>"  'evil-window-move-very-bottom
    "j"  'evil-window-down
    "<down>"  'evil-window-down
    "K"  'evil-window-move-very-top
    "<S-up>"  'evil-window-move-very-top
    "k"  'evil-window-up
    "<up>"  'evil-window-up
    "L"  'evil-window-move-far-right
    "<S-right>"  'evil-window-move-far-right
    "l"  'evil-window-right
    "<right>"  'evil-window-right
    "m" 'pdc/toggle-maximize-buffer
    "o" 'other-frame
    "r" 'pdc/rotate-windows
    "R" 'pdc/rotate-windows-backward
    "s" 'split-window-below
    "S" 'pdc/split-window-below-and-focus
    "-" 'split-window-below
    "U" 'winner-redo
    "u" 'winner-undo
    "v" 'split-window-right
    "V" 'pdc/split-window-right-and-focus
    "/" 'split-window-right
    "w" 'other-window
    "=" 'balance-windows
    "_" 'pdc/maximize-horizontally)
#+END_SRC

** Text keybindings

#+BEGIN_SRC emacs-lisp

  (defalias 'count-region 'count-words-region)

  (defun pdc/align-repeat (start end regexp &optional justify right after)
    "Repeat alignment with respect to the given regular expression.
  If JUSTIFY-RIGHT is non nil justify to the right instead of the
  left. If AFTER is non-nil, add whitespace to the left instead of
  the right."
    (interactive "r\nsAlign regexp: ")
    (let* ((ws-regexp (if (string-empty-p regexp)
                          "\\(\\s-+\\)"
                        "\\(\\s-*\\)"))
           (complete-regexp (if after
                                (concat regexp ws-regexp)
                              (concat ws-regexp regexp)))
           (group (if justify-right -1 1)))
      (message "%S" complete-regexp)
      (align-regexp start end complete-regexp group 1 t)))

  (defun pdc/align-repeat-decimal (start end)
    "Align a table of numbers on decimal points and dollar signs (both optional)"
    (interactive "r")
    (require 'align)
    (align-regexp start end nil
                  '((nil (regexp . "\\([\t ]*\\)\\$?\\([\t ]+[0-9]+\\)\\.?")
                         (repeat . t)
                         (group 1 2)
                         (spacing 1 1)
                         (justify nil t)))
                  nil))

  (defmacro pdc|create-align-repeat-x (name regexp &optional justify-right default-after)
    (let ((new-func (intern (concat "pdc|align-repeat-" name))))
      `(defun ,new-func (start end switch)
         (interactive "r\nP")
         (let ((after (not (eq (if switch t nil) (if ,default-after t nil)))))
           (pdc/align-repeat start end ,regexp ,justify-right after)))))

  (pdc|create-align-repeat-x "comma" "," nil t)
  (pdc|create-align-repeat-x "semicolon" ";" nil t)
  (pdc|create-align-repeat-x "colon" ":" nil t)
  (pdc|create-align-repeat-x "equal" "=")
  (pdc|create-align-repeat-x "math-oper" "[+\\-*/]")
  (pdc|create-align-repeat-x "ampersand" "&")
  (pdc|create-align-repeat-x "bar" "|")
  (pdc|create-align-repeat-x "left-paren" "(")
  (pdc|create-align-repeat-x "right-paren" ")" t)
  (pdc|create-align-repeat-x "backslash" "\\\\")

  (defun pdc/uniquify-lines ()
    "Remove duplicate adjacent lines in region or current buffer"
    (interactive)
    (save-excursion
      (save-restriction
        (let ((beg (if (region-active-p) (region-beginning) (point-min)))
              (end (if (region-active-p) (region-end) (point-max))))
          (goto-char beg)
          (while (re-search-forward "^\\(.*\n\\)\\1+" end t)
            (replace-match "\\1"))))))

  (defun pdc/sort-lines ()
    "Sort lines in region or current buffer"
    (interactive)
    (let ((beg (if (region-active-p) (region-beginning) (point-min)))
          (end (if (region-active-p) (region-end) (point-max))))
      (sort-lines nil beg end)))


  (defun pdc/count-words-analysis (start end)
    "Count how many times each word is used in the region.
   Punctuation is ignored."
    (interactive "r")
    (let (words alist_words_compare (formated ""))
      (save-excursion
        (goto-char start)
        (while (re-search-forward "\\w+" end t)
          (let* ((word (intern (match-string 0)))
                 (cell (assq word words)))
            (if cell
                (setcdr cell (1+ (cdr cell)))
              (setq words (cons (cons word 1) words))))))
      (defun alist_words_compare (a b)
        "Compare elements from an associative list of words count.
  Compare them on count first,and in case of tie sort them alphabetically."
        (let ((a_key (car a))
              (a_val (cdr a))
              (b_key (car b))
              (b_val (cdr b)))
          (if (eq a_val b_val)
              (string-lessp a_key b_key)
            (> a_val b_val))))
      (setq words (cl-sort words 'alist_words_compare))
      (while words
        (let* ((word (pop words))
               (name (car word))
               (count (cdr word)))
          (setq formated (concat formated (format "[%s: %d], " name count)))))
      (when (interactive-p)
        (if (> (length formated) 2)
            (message (substring formated 0 -2))
          (message "No words.")))
      words))

  (pdc|with-leader :infix :text
    "a&" 'pdc/align-repeat-ampersand
    "a(" 'pdc/align-repeat-left-paren
    "a)" 'pdc/align-repeat-right-paren
    "a," 'pdc/align-repeat-comma
    "a." 'pdc/align-repeat-decimal
    "a:" 'pdc/align-repeat-colon
    "a;" 'pdc/align-repeat-semicolon
    "a=" 'pdc/align-repeat-equal
    "a\\" 'pdc/align-repeat-backslash
    "aa" 'align
    "ac" 'align-current
    "am" 'pdc/align-repeat-math-oper
    "ar" 'pdc/align-repeat
    "a|" 'pdc/align-repeat-bar
    "c" 'count-region
    "dw" 'delete-trailing-whitespace
    "jc" 'set-justification-center
    "jf" 'set-justification-full
    "jl" 'set-justification-left
    "jn" 'set-justification-none
    "jr" 'set-justification-right
    "ls" 'pdc/sort-lines
    "lu" 'pdc/uniquify-lines
    "tc" 'transpose-chars
    "tl" 'transpose-lines
    "tw" 'transpose-words
    "U" 'upcase-region
    "u" 'downcase-region
    "wc" 'pdc/count-words-analysis
    "TAB" 'indent-rigidly)
#+END_SRC
* Basic editing

** Our commands
#+BEGIN_SRC emacs-lisp
  (defun pdc/set-undo-boundary ()
    (interactive)
    (undo-boundary))

  (defun pdc/cap-sentence ()
    (interactive)
    (save-excursion
      (backward-sentence)
      (capitalize-word 1)))

  (defun pdc/quote-region (start end &optional c)
    (interactive "r")
    (let ((c (or c "\"")))
      (save-excursion
        (goto-char start)
        (insert c)
        (goto-char (+ 1 end))
        (insert c))))

  (defun pdc/single-quote-region (start end)
    (interactive "r")
    (pdc/quote-region start end "'"))

  (defun pdc/yank-and-indent ()
    (interactive)
    (yank)
    (call-interactively 'indent-region))


  ;;; Helper lifts from k2
  (defun pdc/mark-whole-line ()
    (interactive)
    (beginning-of-line)
    (set-mark-command nil)
    (end-of-line))


  (defun pdc/kill-whole-line ()
    (interactive)
    (pdc/mark-whole-line)
    (kill-region (region-beginning)
                 (region-end)))

  (defun pdc/copy-whole-line ()
    (interactive)
    (save-excursion
      (pdc/mark-whole-line)
      (kill-ring-save (region-beginning)
                      (region-end))))


  (defun pdc/clone-line ()
    (interactive)
    (beginning-of-line)
    (pdc/copy-whole-line)
    (open-next-line)
    (forward-line)
    (yank)
    (back-to-indentation))

  (defun pdc|goto-line (line)
    "A simplified, single buffer version of the standard command
    that work even if the buffer is narrowed"
    (interactive "nLine:")
    ;; Leave mark at previous position
    (or (region-active-p) (push-mark))
    ;; Move to the specified line number in that buffer.
    (save-restriction
      (goto-char (point-min))
      (if (eq selective-display t)
          (re-search-forward "[\n\C-m]" nil 'end (1- line))
        (forward-line (1- line)))))


  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;; https://github.com/al3x/emacs/blob/master/utilities/slick-copy.el
  (defadvice kill-ring-save (before slick-copy activate compile)
    "When called interactively with no active region, copy a single line instead."
    (interactive
     (if mark-active (list (region-beginning) (region-end))
       (message "Copied line")
       (list (line-beginning-position)
             (line-beginning-position 2)))))

  (defadvice kill-region (before slick-cut activate compile)
    "When called interactively with no active region, kill a single line instead."
    (interactive
     (if mark-active (list (region-beginning) (region-end))
       (list (line-beginning-position)
             (line-beginning-position 2)))))
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defun pdc/apply-to-region (func)
    (when (region-active-p)
      (insert (funcall func (delete-and-extract-region
                             (region-beginning)
                             (region-end))))))

#+END_SRC

** Packages
#+BEGIN_SRC emacs-lisp
  (use-package subword :ensure t)

  (require 'misc)      ; forward-to-word & backward-to-word

  (use-package visible-mark :ensure t
    :commands (global-visible-mark-mode)
    :init
    (global-visible-mark-mode t))

  (use-package undo-tree :ensure t
    :commands (global-undo-tree-mode)
    :diminish undo-tree-mode
    :init
    (global-undo-tree-mode))

  (use-package goto-last-change :ensure t
    :config
    (setq highlight-changes-visibility-initial-state nil))

#+END_SRC

** Bindings
#+BEGIN_SRC emacs-lisp
  (pdc|general-bind-hydra transpose "t"
    ("t" transpose-chars "chars")
    ("C-t" transpose-chars "chars")
    ("l" transpose-lines "lines")
    ("p" transpose-paragraphs "paras")
    ("s" transpose-sexps "sexps")
    ("C-M-t" transpose-sexps "sexps")
    ("w" transpose-words "words")
    ("M-t" transpose-words "words"))

#+END_SRC

** Abbreviations
#+NAME: abbrev
| Base | Expansion                   |
|------+-----------------------------|
| bc   | because                     |
| wo   | without                     |
| wi   | with                        |
| qm   | piers@singingtogether.co.uk |

#+BEGIN_SRC emacs-lisp :var data=abbrev
(mapc (lambda (x) (define-global-abbrev (car x) (cadr x))) (cddr data))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'abbrev-mode)
(diminish 'abbrev-mode "")
#+END_SRC

** Multiple cursors
#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors :ensure t
    :config
    (general-define-key "s-<mouse-1>" 'mc/add-cursor-on-click)
    (pdc|general-bind-hydra mc (bindings//prefix :cursor)
      ("<" mc/mark-previous-like-this)
      (">" mc/mark-next-like-this )
      ("M-<" mc/unmark-previous-like-this)
      ("M->" mc/unmark-next-like-this)
      ("i" mc/insert-numbers)
      ("d" mc/mark-all-symbols-like-this-in-defun :color blue)
      ("r" mc/reverse-regions)
      ("s" mc/sort-regions))
    (pdc|with-leader :infix (:cursor)
     "C-a" 'mc/edit-beginnings-of-lines
     "A" 'mc/mark-all-like-this
     "a" 'mc/mark-all-dwim
     "C-e" 'mc/edit-ends-of-lines
     "e" 'mc/edit-lines))
#+END_SRC
** Auto completion
#+BEGIN_SRC emacs-lisp
  (use-package auto-complete :ensure t
    :diminish " ⓐ"
    :init
    (ac-config-default)
    (global-auto-complete-mode t))
#+END_SRC
** Expanding the region
#+BEGIN_SRC emacs-lisp
  (use-package expand-region :ensure t
    :general
    (pdc|with-leader
      "v" 'er/expand-region))

#+END_SRC

* Navigation

** Standard locations
#+BEGIN_SRC emacs-lisp
  (defun pdc/find-config ()
    "Edit the `config.org', in the current window."
    (interactive)
    (find-file-existing my-config-org))

  (defun pdc/find-user-init-file ()
    "Edit the `user-init-file' in the current window."
    (interactive)
    (find-file-existing user-init-file))

  (defun pdc/copy-file ()
    "Write the file under new name."
    (interactive)
    (call-interactively 'write-file))

  (defun pdc//read-file-name (&optional initial-input)
    (ivy-read "File file: " 'read-file-name-internal
              :matcher #'counsel--find-file-matcher
              :initial-input initial-input
              :preselect (when counsel-find-file-at-point
                           (require 'ffap)
                           (let ((f (ffap-guesser)))
                             (when f (expand-file-name f))))
              :history 'file-name-history
              :caller this-command))

  (defun pdc/sudo-edit (&optional initial-input)
    (interactive "P")
    (counsel-find-file-as-root (pdc//read-file-name initial-input)))
  
  (pdc|with-leader :infix (:emacs-d)
    "c" '(pdc/find-config :which-key "config.org")
    "i" '(pdc/find-user-init-file :which-key "init.el"))

  (pdc|with-leader :prefix (:files)
    "c" '(pdc/copy-file :which-key "copy")
    "g" 'rgrep
    "l" 'find-file-literally
    "E" 'pdc/sudo-edit
    "s" 'save-buffer
    "v" '(:ignore t :which-key "variables")
    "vd" 'add-dir-local-variable
    "vf" 'add-file-local-varihable
    "vp" 'add-file-local-variable-prop-line)
#+END_SRC

** Avy
For jumping to characters and words in the frame
#+BEGIN_SRC emacs-lisp
  (use-package avy :ensure t
    :general
    (pdc|with-leader :infix (:jump)
     "j" 'avy-goto-char-timer
     "b" 'avy-goto-char
     "'" 'avy-goto-char-2
     "w" 'avy-goto-word-1))
#+END_SRC

** Swiper
A better incremental search

#+BEGIN_SRC emacs-lisp
    (use-package swiper :ensure t
      :pin "melpa"
      :commands (swiper swiper-all)
      :general
      (pdc|with-leader :infix (:search)
       "s" 'swiper
       "S" 'swiper-all)
      :config
      (global-set-key [remap isearch-forward] 'swiper)
      (global-set-key [remap isearch-forward-regexp] 'swiper)
      (global-set-key [remap isearch-backward] 'swiper)
      (global-set-key [remap isearch-backward-regexp] 'swiper))


#+END_SRC

** Ivy
A better completing read. Similar to helm but rather less intrusive. 

We define a =pdc-find-file-other-window= function, but it seems the
'proper' ivy based approach is to do =M-o j= once we've selected the
correct file using counsel-find-file. Not sure how to suggest this in
the method itself, short of erroring out and telling the user (me) to
just use the ivy supplied method.
#+BEGIN_SRC emacs-lisp

  (use-package ivy :ensure t
    :pin "melpa"
    :diminish " 🍃"
    :init
    (ivy-mode 1)
    (bindings|add-toggle ivy-mode :toggle-keys "Ti")
    :config
    (defun pdc-find-file-other-window (&optional initial-input)
      "Forward to `find-file-other-window'.
  When INITIAL-INPUT is non-nil, use it in the minibuffer during completion."
      (interactive)
      (ivy-read "Find file: " 'read-file-name-internal
                :matcher #'counsel--find-file-matcher
                :initial-input initial-input
                :action
                (lambda (x)
                  (with-ivy-window
                    (find-file-other-window
                     (expand-file-name x
                                       ivy--directory))))
                :preselect (when counsel-find-file-at-point
                             (require 'ffap)
                             (let ((f (ffap-guesser)))
                               (when f (expand-file-name f))))
                :require-match 'confirm-after-completion
                :history 'file-name-history
                :keymap counsel-find-file-map
                :caller 'counsel-find-file))

    (defun ivy-pdc-help//toggle-candidates ()
      "Return the sorted cnadidates for toggle source."
      (let (result)
        (dolist (toggle bindings-toggles)
          (let* ((toggle-symbol (symbol-name (car toggle)))
                 (toggle-status (funcall (plist-get (cdr toggle) :predicate)))
                 (toggle-name (capitalize (replace-regexp-in-string "-" " " toggle-symbol)))
                 (toggle-doc (format "(%s) %s: %s"
                                     (if toggle-status "+" "-")
                                     toggle-name
                                     (propertize
                                      (or (plist-get (cdr toggle) :documentation) "")
                                      'face 'font-lock-doc-face))))
            (when (plist-member (cdr toggle) :toggle-keys)
              (let* ((key (plist-get (cdr toggle) :toggle-keys))
                     (key (key-description
                           (kbd (if (listp key)
                                    (apply 'bindings//leader key)
                                  (concat leader-key " " key))))))
                (setq toggle-doc
                      (format "%s (%s)"
                              toggle-doc
                              (propertize key 'face 'font-lock-keyword-face)))))
            (if (plist-member (cdr toggle) :documentation)
                (push `(,toggle-doc . ,toggle-symbol) result)
              (push `(,toggle-name . ,toggle-symbol) result))))
        (setq result (cl-sort result 'string< :key 'car))
        result))

    (defun ivy-pdc-help//toggle (candidate)
      "Toggle candidate."
      (when-let* ((toggle (assq (intern (cdr candidate)) bindings-toggles)))
        (funcall (plist-get (cdr toggle) :function))))

    (defun ivy-pdc-help/toggles ()
      (interactive)
      (ivy-read "Toggles: "
                (ivy-pdc-help//toggle-candidates)
                :action 'ivy-pdc-help//toggle))
  
    )

#+END_SRC

** Counsel

Wraps a bunch of common functions with the =ivy= completing read
that's also used by swiper.
#+BEGIN_SRC emacs-lisp
  (use-package  counsel :ensure t
    :commands (counsel-mode)
    :diminish counsel-mode
    :general
    (pdc|with-leader
      (:files "f") '(counsel-find-file :which-key "find") 
      (:git "S") '(counsel-git-grep :which-key "git grep")
      (:git "f") '(counsel-git :which-key "find file in repo")
      (:elisp "L") '(counsel-load-library :which-key "load library")
      (:org "g") '(counsel-org-goto :which-key "goto")
      (:org "G") '(counsel-org-goto-all :which-key "goto-all"))
    :init
    (bindings|add-toggle counsel-mode :toggle-keys "Tc")
    :config
    (--each '((apropos . counsel-apropos)
              (org-goto . counsel-org-goto)
              (set-variable . counsel-set-variable))
      (when (fboundp (cdr it))
        (define-key counsel-mode-map (vector 'remap (car it)) (cdr it))))
    (counsel-mode t))
#+END_SRC

* Bindings
** Toggles for stuff that's preloaded
#+BEGIN_SRC emacs-lisp

  (bindings|add-toggle auto-fill-mode
    :status auto-fill-function
    :toggle-keys "Tf")

  (use-package hl-line :ensure t
    :diminish hl-highlight-mode
    :commands (global-hl-line-mode hl-line-mode)
    :init
    (bindings|add-toggle highlight-current-line-globally
     :mode global-hl-line-mode
     :documentation "Globally highlight the current line"
     :toggle-keys "thh"))

  (bindings|add-toggle truncate-lines
    :status truncate-lines
    :on (toggle-truncate-lines)
    :off (toggle-truncate-lines -1)
    :documentation "Truncate long lines (no wrap)."
    :toggle-keys "tl")

  (bindings|add-toggle visual-line-navigation
    "Move point according to visual lines."
    :mode visual-line-mode
    :toggle-keys "tL")
  (diminish 'visual-line-mode " Ⓛ")

  (bindings|add-toggle debug-on-error
    "Display backtrace when an error happens."
    :status debug-on-error
    :on (setq debug-on-error t)
    :off (setq debug-on-error nil)
    :toggle-keys "tD")


  (bindings|add-toggle fringe
    "Display the fringe in GUI mode"
    :status (not (equal fringe-mode 0))
    :on (call-interactively 'fringe-mode)
    :off (fringe-mode 0)
    :toggle-keys "Tf")

  (bindings|add-toggle fullscreen-frame
    "Display the current frame in full screen."
    :status (memq (frame-parameter nil 'fullscreen) '(fullscreen fullboth))
    :on (toggle-frame-fullscreen)
    :off (toggle-frame-fullscreen)
    :toggle-keys "TF")


  (bindings|add-toggle maximize-frame
    "Maximize the current frame"
    :status (eq (frame-parameter nil 'fullscreen) 'maximized)
    :on (toggle-frame-maximized)
    :off (toggle-frame-maximized)
    :toggle-keys "TM")

  (bindings|add-toggle mode-line
    "Toggle the visibility of modeline."
    :status (not hidden-mode-line-mode)
    :on (hidden-mode-line-mode -1)
    :off (hidden-mode-line-mode)
    :toggle-keys "tmt")

  (bindings|add-toggle tool-bar
    "Display the toolbar in GUI mode."
    :if window-system
    :mode tool-bar-mode
    :toggle-keys "Tt")

  (bindings|add-toggle menu-bar
    "Display the menu bar"
    :if window-system
    :mode menu-bar-mode
    :toggle-keys "Tm")


#+END_SRC
** Quitting emacs
#+BEGIN_SRC emacs-lisp
  (defun pdc/frame-killer ()
    "Kill server buffer and hide the main Emacs window"
    (interactive)
    (condition-case-unless-debug nil
        (delete-frame nil 1)
      (error (make-frame-invisible nil 1))))


  (pdc|with-leader :infix :quit
    "s" 'save-buffers-kill-emacs
    "q" 'save-buffers-kill-terminal
    "Q" 'kill-emacs
    "z" 'pdc/frame-killer)

#+END_SRC

** Other bindings
#+BEGIN_SRC emacs-lisp
  (defun pdc/execute-extended-command-short (prefixarg &optional function)
    "Massively simplified execute extended command.

  This isn't meant for interactive use by humans, but
  `counsel-M-x', lovely though it is, breaks some of my dictation
  support. This doesn't"
    (interactive "P\nCcommand: ")
    (setq this-command function)
    (setq real-this-command function)
    (let ((prefix-arg prefixarg))
      (command-execute function 'record)))

  ;; Clear up some useless bindings
  (global-unset-key (kbd "C-z"))
  (global-unset-key [insert])

  ;; Set up an options prefix
  (bindings|define-prefix opts "O" "Options")

  ;;
  (pdc|with-leader (:window "/") 'pdc/toggle-window-split)

  (general-define-key
   "C-x C-m" 'pdc/execute-extended-command-short)

  ;; Command name shorthands. Thanks Steve Yegge
  (defalias 'qrr 'query-replace-regexp)
  (defalias 'rr 'replace-regexp)

  ;; Buffer spruce up - could be cleverer. Per-mode spruce up strategies
  ;; for instance
  (use-package pdc-spruce-up-buffer
    :general
    ((bindings//leader :buffer "T") 'pdc|spruce-up-buffer))

  (pdc|with-leader :infix (:buffer)
    "y" 'bury-buffer
    "r" 'revert-buffer)

  ;; Some lispy bindings

  (pdc|with-mode-leader :keymaps 'lisp-mode-shared-map
    :infix "b"
    "v" '(eval-buffer :which-key "eVal-buffer"))

  (defun pdc|apropos-function (pattern)
    (interactive (list (apropos-read-pattern
                        "command or function")))
    (apropos-command pattern t))


  ;;; An apropos leader
  (pdc|with-leader :infix (:apropos)
    ""    '(nil :which-key "apropos")
    "A"   'apropos
    "c"   'apropos-command
    "d"   'apropos-documentation
    "f"   'pdc|apropos-function
    "l"   'apropos-library
    "m"   'apropos-mode
    "o"   'apropos-user-option
    "v"   'apropos-variable
    "M-v" 'apropos-local-variable
    "V"   'apropos-value
    "M-V" 'apropos-local-value)

  ;;; A describe-foo leader
  ;; First unbind a bunch of non-menu bindings
  (--each '(;; apropos-*
            "a" 
            ;; describe-*
            "b" "C-c" "C-o" "c" "C" "f" "g" "I"
            "k" "L" "m" "C-w" "P" "o" "s" "v"
            ;; info stuff
            "i" "F" "K" "r" "S")

    (global-unset-key (kbd (format "%c %s" help-char it))))

  (pdc|with-leader :infix "h d"
    ""     '(nil :which-key "describe-*")
    "b" 'describe-bindings
    "B" 'describe-personal-bindings
    "c" 'describe-key-briefly
    "C" 'describe-coding-system "f" 'describe-function
    "F" 'describe-face
    "I" 'describe-input-mode
    "k" 'describe-key
    "o" 'describe-symbol
    "L" 'describe-language-environment
    "m" 'describe-mode
    "P" 'describe-package
    "s" 'describe-syntax
    "t" 'describe-theme
    "v" 'describe-variable
    "C-c" 'describe-current-coding-system)

  (defun info-elisp-manual ()
    "Display the Elisp manual in Info mode."
    (interactive)
    (info "elisp"))

  (pdc|with-leader :infix "h i"
    "" '(nil :which-key "Info")
    "e" 'info-elisp-manual                
    "i" 'info
    "F" 'Info-goto-emacs-command-node
    "K" 'Info-goto-emacs-key-command-node
    "r" 'info-emacs-manual
    "S" 'info-lookup-symbol)

  ;; A vi-like %

  (defun pdc|match-paren (arg)
    "Go to the matching paren if on a paren, otherwise self-insert."
    (interactive "p")
    (let ((prev-char (char-to-string (preceding-char)))
          (next-char (char-to-string (following-char))))
      (cond ((string-match "[[{(<“‘]" next-char) (forward-sexp 1))
            ((string-match "[\]})>’”]" prev-char) (backward-sexp 1))
            (t (self-insert-command (or arg 1))))))

  (general-define-key "%" 'pdc|match-paren)

  (use-package pdc-helpers
    :commands
    pdc|smarter-move-beginning-of-line
    :general
    (pdc|with-leader
      "|"      '(pdc|align :which-key "align")
      "\\"     '(pdc|align :which-key "align")

      "C-M-|"  '(pdc|align-last-sexp :which-key "align last sexp")
      "C-M-\\" '(pdc|align-last-sexp :which-key "align last sexp")

      "'"      '(pdc|quote-behind :which-key "' behind")
      "\""     '(pdc|doublequote-behind :which-key "\" behind")

      ;; operate on file and buffer, so put beneath both leaders
      "f R"    '(pdc|rename-file-and-buffer :which-key "rename file & buffer") 
      "b R"    '(pdc|rename-file-and-buffer :which-key "rename file & buffer")   
      "f M"    '(pdc|move-buffer-file :which-key "move buffer file")
      "b M"    '(pdc|move-buffer-file :which-key "move buffer file")

      "Re i"    '(pdc|visit-ielm :which-key "ielm")
      "Re R"    '(pdc|eval-and-replace :which-key "eval and replace"))
    :init
    (global-set-key [remap move-beginning-of-line]
                    'pdc|smarter-move-beginning-of-line)
    (global-set-key [remap ielm]
                    'pdc|visit-ielm))


  (defun mark-line (&optional arg)
    "Mark the current line.

  If ARG is set, mark that many lines beginning (or ending if arg is negative) with the current one"
    (interactive "p")
    (let* ((arg (or arg 1)))
      (beginning-of-line)
      (let ((here (point)))
        (if (< arg 1)
            (beginning-of-line (1+  arg))
          (end-of-line arg))
        (set-mark (point))
        (goto-char here))))

  (defun mark-sentence (&optional arg)
    (interactive "p")
    (backward-sentence)
    (mark-end-of-sentence arg))


  (pdc|with-leader
    "P l" 'package-list-packages
    "T I" 'toggle-input-method)

  ;;; Jumps
  (pdc|with-leader
    :infix (:jump)
    "l" 'pdc|goto-line
    "$" 'move-end-of-line
    ">" 'end-of-buffer
    "<" 'beginning-of-buffer
    "^" 'pdc|smarter-move-beginning-of-line
    "a" 'back-to-indentation)

  ;;; File stuff
  (pdc|with-leader
    :infix (:buffer)
    "R" 'recompile
    "S" 'pdc|spruce-up-buffer)

  (pdc|with-leader
    "k" (list
         (defhydra hydra-kill (nil nil :color red)
           "Kill"
           (";" kill-comment "comment")
           ("<tab>" delete-indentation "indentation")
           ("L" kill-whole-line "whole line")
           ("R" kill-rectangle "rectangle" :color blue)
           ("S" kill-sentence "sentence")
           ("l" kill-line "line")
           ("p" kill-paragraph "paragraph")
           ("r" kill-region "region")
           ("s" kill-sexp "sexp")
           ("v" kill-visual-line "visual line")
           ("w" kill-word "word"))
         :which-key "+kill")
    "K" (list kmacro-keymap :which-key "kmacro")
  
    ;; "r q" 'query-replace-regexp
    "r R" 'replace-rectangle)
#+END_SRC

* Snippets

Snippet systems are the good sort of magical. Insane in many ways, and
for god's sake, don't look at yasnippet's implementation if you value
your sanity. Please, I beg of you don't. But do use them.

** yasnippet

[[https://github.com/joaotavora/yasnippet][Yasnippet]] seems to be winning the snippet tool race now

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet :ensure t
    :mode ("/\\.emacs\\.d/etc/yasnippet/snippets/" . snippet-mode)
    :diminish (yas-minor-mode . " ⓨ")
    :config
    (yas-load-directory (concat my-user-emacs-directory "etc/yasnippet/snippets/"))
    (yas-global-mode 1))
#+END_SRC

** Snippet like functions

#+BEGIN_SRC emacs-lisp
  (defun my-org-insert-elisp ()
    (interactive)
    (yas-expand-snippet "#+BEGIN_SRC emacs-lisp\n$0\n#+END_SRC\n")
    (org-edit-special))

  (defun pdc/org-split-src ()
    (interactive)
    (let ((element (org-element-at-point)))
      (barf-if-buffer-read-only)
      (pcase (org-element-type element)
        (`src-block
         (let* ((beg (org-element-property :begin element))
                (end (save-excursion
                       (goto-char beg)
                       (line-end-position))))
           (end-of-line)
           (insert "\n#+END_SRC\n\n")
           (insert-buffer-substring (current-buffer) beg end)
           (forward-line -1)))
        (_
         ;; Nothing interesting to split
         (user-error "Don't know how to split this element")))))



  (pdc|with-mode-leader :keymaps 'org-mode-map
                        "s" nil
                        "s e" 'my-org-insert-elisp
                        "s/" 'pdc/org-split-src)

  ;; (with-eval-after-load 'yankpad
  ;;  (bind-key "<f6>e" 'my-org-insert-elisp nil (eq major-mode 'org-mode)))

#+END_SRC

* Programming
** Project management
We use Projectile here (which I should learn)
#+BEGIN_SRC emacs-lisp
  (use-package projectile :ensure t
    :commands (projectile-mode global-projectile-mode)
    :diminish projectile-mode
    :init
    (projectile-global-mode)
    (setq projectile-completion-system 'ivy))

  (use-package counsel-projectile  :ensure t
    :config
    (counsel-projectile-on))
#+END_SRC

** Version Control (Git)
*** Magit
Magit is awesome and I'd hate to be without it
#+BEGIN_SRC emacs-lisp

  (use-package with-editor :ensure t
    :diminish "")

  (use-package magit :ensure t
    :commands (magit-get-top-dir magit-status)
    :general
    ("M-," 'pdc/vc-status)
    ("C-. g s" 'magit-status)
    (:prefix leader-key
             "g"   '(:ignore t :which-key "git")
             "g s" 'magit-status)
    :init
    (setq magit-last-seen-setup-instructions "1.4.0")
    (setq magit-branch-arguments nil)
    (setq magit-push-always-verify nil)
    :config
    (defun pdc/bookmark-magit-status (bookmark)
      "Run magit-status on the bookmarked file"
      (interactive
       (list (bookmark-completing-read "Status of bookmark"
                                       (bmkp-default-bookmark-name))))
      (magit-status (bookmark-prop-get bookmark 'filename)))
    (defun pdc/vc-status ()
      (interactive)
      (cond ((magit-get-top-dir default-directory)
             (call-interactively 'magit-status))
            (t
             (call-interactively 'dired)))))

#+END_SRC
*** Gist
Manage code samples on github
#+BEGIN_SRC emacs-lisp
  (use-package gist :ensure t
    :init
    (setq gist-authenticate-function 'gist-oauth2-authentication)
    :general
    (pdc|with-leader
     "g G" 'gist-region-or-buffer))

#+END_SRC

*** Helpful gutters/fringes
The fringe is a very handy bit of interface, especially when it knows
about the git status of things.
#+BEGIN_SRC emacs-lisp
  (use-package git-gutter+ :ensure t
    :diminish git-gutter+-mode
    :diminish git-gutter-mode
    :init
    (bindings|add-toggle git-gutter :mode git-gutter+-mode :toggle-keys "Tg")
    (global-git-gutter+-mode 1))

  (use-package git-gutter-fringe+ :ensure t
    :config
    (git-gutter-fr+-minimal))

#+END_SRC

*** DISABLED magithub
Apparently has useful integration with github, but I need to look into
how to configure it properly.
#+BEGIN_SRC emacs-lisp
  (use-package magithub :ensure t)
#+END_SRC

*** git-timemachine
Speculatively installed. Need to work out if I really need it.
#+BEGIN_SRC emacs-lisp
  (req-package git-timemachine)
#+END_SRC

** Flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck :ensure t
    :commands global-flycheck-mode
    :diminish " ⓢ"
    :init

    (global-flycheck-mode t))
#+END_SRC

** Auto-compile
#+BEGIN_SRC emacs-lisp
  (use-package auto-compile :ensure t
    :commands (auto-compile-on-load-mode auto-compile-on-save-mode)
    :init
    (auto-compile-on-load-mode)
    (auto-compile-on-save-mode)
    (setq auto-compile-display-buffer nil)
    (setq auto-compile-mode-line-counter t))
#+END_SRC

** Programming languages

*** Lisps

There are multiple lispy modes, and we want many of them to be
initialized the same way. So we'll set up some variables to assist
with this
#+BEGIN_SRC emacs-lisp
  (defvar lisp-modes '(emacs-lisp-mode
                       inferior-emacs-lisp-mode
                       ielm-mode
                       lisp-mode
                       inferior-lisp-mode
                       lisp-interaction-mode
                       extempore-mode)
    "A list of Lisp style modes")

  (defvar lisp-mode-hooks
    (--map (intern (concat (symbol-name it) "-hook"))
           lisp-modes)
    "The hook variables associated with our lisp-modes")
#+END_SRC

Configure our base Lisp mode
#+BEGIN_SRC emacs-lisp
  ;; Helpers (move targets)
  (defun pdc/display-syntax (syntax-type)
    (eq syntax-type (syntax-ppss-context (syntax-ppss))))

  (defun pdc/in-syntax-p (syntax-type)
    "This only answers if you're in a comment or string at the moment."
    (eq syntax-type (syntax-ppss-context (syntax-ppss))))

  (defun pdc/in-string-p ()
    (pdc/in-syntax-p 'string))

  (defun pdc/in-comment-p ()
    (pdc/in-syntax-p 'comment))

  (defun pdc/blank-line-p ()
    "Return non-nil iff current line is blank."
    (save-excursion
      (beginning-of-line)
      (looking-at "\\s-*$")))

  (defun pdc/beginning-of-string ()
    "Go to beginning of string around point.
  Do nothing if not in string."
    ;; from loveshack's python-beginning-of-string
    (interactive)
    (if (and (not (pdc/in-string-p))
             (save-excursion
               (backward-char)
               (pdc/in-string-p)))
        (backward-char))
    (let ((state (syntax-ppss)))
      (when (eq 'string (syntax-ppss-context state))
        (goto-char (nth 8 state)))))

  (defun pdc/end-of-string ()
    (interactive)
    (if (and (not (pdc/in-string-p))
             (save-excursion
               (forward-char)
               (pdc/in-string-p)))
        (forward-char))
    (if (pdc/in-string-p)
        (progn
          (pdc/beginning-of-string)
          (forward-sexp))))

  (defun pdc/mark-string ()
    (interactive)
    (if (pdc/in-string-p)
        (progn
          (pdc/beginning-of-string)
          (forward-char)
          (push-mark nil nil t)
          (pdc/end-of-string)
          (backward-char))))

  (defun pdc/forward-string (&optional backward)
    (interactive)
    (if (pdc/in-string-p)
        (pdc/end-of-string))
    (while (not (pdc/in-string-p))
      (if backward
          (backward-char)
        (forward-char))))

  (defun pdc/backward-string ()
    (interactive)
    (if (pdc/in-string-p)
        (pdc/beginning-of-string))
    (pdc/forward-string t)
    (pdc/beginning-of-string)
    (forward-char))

  (defun pdc/out-sexp (&optional level forward syntax)
    "Skip out of any nested brackets.
   Skip forward if FORWARD is non-nil, else backward.
   If SYNTAX is non-nil it is the state returned by `syntax-ppss' at point.
   Return non-nil if and only if skipping was done."
    (interactive)
    (if (pdc/in-string-p)
        (pdc/beginning-of-string))
    (progn
      (let* ((depth (syntax-ppss-depth (or syntax (syntax-ppss))))
             (level (or level depth))
             (forward (if forward -1 1)))
        (unless (zerop depth)
          (if (> depth 0)
              ;; Skip forward out of nested brackets.
              (condition-case ()            ; beware invalid syntax
                  (progn (backward-up-list (* forward level)) t)
                (error nil))
            ;; Invalid syntax (too many closed brackets).
            ;; Skip out of as many as possible.
            (let (done)
              (while (condition-case ()
                         (progn (backward-up-list forward)
                                (setq done t))
                       (error nil)))
              done))))))

  (defun pdc/flash-region (beg end)
    (interactive "r")
    (let ((ovl (make-overlay beg end))
          (was-mark-active mark-active))
      (setq mark-active nil)
      (overlay-put ovl 'face 'highlight)
      (run-with-timer 0.5 nil
                      (lambda (ovl was-mark-active)
                        (delete-overlay ovl)
                        (setq mark-active was-mark-active))
                      ovl was-mark-active)))

  (defun pdc/indent-sexp ()
    "http://mihai.bazon.net/projects/editing-javascript-with-emacs-js2-mode
    can be used from any coding major mode"
    (interactive)
    (save-restriction
      (save-excursion
        (widen)
        (let* ((inhibit-point-motion-hooks t)
               (parse-status (syntax-ppss (point)))
               (beg (nth 1 parse-status))
               (end-marker (make-marker))
               (end (progn (goto-char beg) (forward-list) (point))))
          (pdc/flash-region beg end)
          (set-marker end-marker end)
          (goto-char beg)
          (while (< (point) (marker-position end-marker))
            ;; don't reindent blank lines so we don't set the "buffer
            ;; modified" property for nothing
            (beginning-of-line)
            (unless (looking-at "\\s-*$")
              (indent-according-to-mode))
            (forward-line))))))

  (use-package autoinsert :ensure t)
  (use-package finder :ensure t)

  (req-package auto-compile
    :init (setq load-prefer-newer t)
    :config (auto-compile-on-load-mode))

  (req-package lisp-mode
    :config

    (defun pdc/goto-match-paren (arg)
      "Go to the matching parenthesis if on parenthesis. Else go up to the opening parenthesis one level up."
      (interactive "p")
      (cond ((looking-at "\\s(") (forward-list 1))
            (t
             (backward-char 1)
             (cond ((looking-at "\\s\)")
                    (forward-char 1)
                    (backward-list 1))
                   (t
                    (while (not (looking-at "\\s\)"))
                      (backward-char 1)
                      (cond ((looking-at "\\s\)")
                             (backward-char 1)
                             (when (looking-at "\\s\)")
                               (forward-char 1)
                               (backward-list 1)
                               (backward-char 1))))))))))

    (defun pdc/replace-sexp ()
      (interactive)
      (if (pdc/in-string-p)
          (pdc/mark-string)
        (mark-sexp))
      (delete-region (point) (mark))
      (yank))


    (defun my-lisp-mode-hook ()
      (auto-fill-mode -1)
      (require 'lispy)
      (lispy-mode +1)
      ;; (paredit-mode +1)
      ;; (redshank-mode 1)
      ;; (elisp-slime-nav-mode 1)
      (add-hook 'after-save-hook 'check-parens
                nil t)
      (yas-minor-mode 1))

    (hook-into-modes 'my-lisp-mode-hook lisp-mode-hooks))

  (req-package eldoc
    :diminish eldoc-mode)

  (req-package elisp-mode
    :general
    (pdc|with-leader :infix (:elisp)
     "c" 'finder-commentary
     "m" 'view-echo-area-messages
     "f" 'find-function
     "F" 'find-face-definition)
     :config
     (defun pdc/elisp-mode-hook ()
       (eldoc-mode 1)
       (setq mode-name "EL"))
     (add-hook 'emacs-lisp-mode-hook 'pdc/elisp-mode-hook ())
     (setq emacs-lisp-mode-hook (-remove-item 'lexbind-mode emacs-lisp-mode-hook)))

  (req-package lispy
    :diminish " Ⓛ"
    :init
    (bindings|add-toggle lispy-mode :toggle-keys "Tl")
    :config
    (lispy-set-key-theme '(paredit special c-digits))
    (unbind-key "M-m" lispy-mode-map-lispy))

  (req-package paredit
    :commands paredit-mode
    :diminish " Ⓟ"
    :bind
    (:map paredit-mode-map
          ("DEL" . pdc/paredit-backward-delete)
          ("M-RET" . pdc/indent-defun)
          ("C-M-l" . paredit-recentre-on-sexp)
          ("C-M-s" . paredit-backward-up)
          ("C-M-k" . paredit-forward-slurp-sexp)
          ("C-M-j" . paredit-backward-slurp-sexp)
          ("C-M-\\" . pdc/indent-then-snap-to-indent)
          ("M-o" . pdc/paredit-open-line)
          ("C-M-y" . pdc/replace-sexp)
          ("C-M-y" . pdc/replace-sexp)
          ("C-y" . pdc/paredit-yank)
          ("(" . pdc/paredit-open-parenthesis)
          (";" . pdc/paredit-semicolon)
          ("M-w" . pdc/paredit-kill-ring-save)
          (")" . pdc-paredit/close-round-and-newline)
          ("M-)" . paredit-close-round)
          ("M-k" . paredit-raise-sexp)
          ("M-I" . paredit-splice-sexp))
    :general
    (pdc|with-mode-leader :keymaps 'paredit-mode-map
      "d" 'paredit-forward-down
      "B" 'paredit-splice-sexp-killing-backward
      "C" 'paredit-convolute-sexp
      "F" 'paredit-splice-sexp-killing-forward
      "a" 'paredit-add-to-next-list
      "A" 'paredit-add-to-previous-list
      "j" 'paredit-join-with-next-list
      "J" 'paredit-join-with-previous-list)

    :init
    (bindings|add-toggle paredit-mode :toggle-keys "Tp")

    :config
    (defun pdc/indent-defun ()
      (interactive)
      (save-excursion
        (pdc/out-sexp)
        (forward-char)
        (pdc/indent-sexp)))

    (defun pdc/paredit-backward-delete ()
      (interactive)
      (if mark-active
          (call-interactively 'delete-region)
        (paredit-backward-delete)))

    (defun pdc/indent-defun-or-region ()
      (interactive)
      (if mark-active
          (call-interactively 'indent-region)
        (pdc/indent-defun)))

    (defun pdc/indent-then-snap-to-indent ()
      (interactive)
      (pdc/indent-defun-or-region)
      (back-to-indentation))

    (defun pdc/paredit-yank ()
      (interactive)
      (call-interactively 'yank)
      (unless mark-active
        (when (and (looking-back "\)" 1)
                   (looking-at "\("))
          (reindent-then-newline-and-indent)
          (when (looking-at-p "^")
            (newline))))
      (condition-case nil (pdc/indent-defun)))

    (defun pdc/paredit-open-line ()
      (interactive)
      (save-excursion
        (reindent-then-newline-and-indent))
      (indent-according-to-mode))

    (defun pdc/paredit-kill-ring-save ()
      (interactive)
      (if (not mark-active)
          (save-excursion
            (when (looking-at-p " +\(")
              (search-forward "(")
              (backward-char))
            (mark-sexp)
            (call-interactively 'kill-ring-save))
        (call-interactively 'kill-ring-save)))

    (defun pdc/paredit-open-parenthesis (&optional n)
      (interactive "P") 
      (cond ((and (looking-back "\(" 1)
                  (looking-at "\)"))
             (paredit-open-parenthesis n))
            ((equal last-command this-command)
             (undo)
             (insert " ")
             (backward-char 1)
             (paredit-open-parenthesis n))
            ((and (not (or mark-active (pdc/in-string-p)))
                  (looking-at-p "[\(a-z\"#\\[{]"))
             (mark-sexp)
             (paredit-open-parenthesis n)
             (when (looking-at-p "[\(\"#\\[{]")
               (save-excursion (insert " "))))
            (t (paredit-open-parenthesis n))))

    (defun pdc/paredit-semicolon (&optional n)
      (interactive "P")
      (when (looking-at-p "  +\(")
        (search-forward "(")
        (backward-char))
      (cond ((or (looking-back ";" 1)
                 (looking-at-p "[[:blank:]]*$"))
             (self-insert-command 1))
            ((equal last-command this-command)
             (undo)
             (self-insert-command 1))
            ((and (not mark-active) 
                  (looking-at-p "^[[:blank:]]*$"))
             (insert ";;; "))
            ((and (not mark-active)
                  (save-excursion
                    (beginning-of-line)
                    (looking-at-p "[[:blank:]]*$")))
             (insert ";; "))
            (t (paredit-semicolon n))))

    (defvar pdc-paredit--post-close-keymap (make-sparse-keymap))
    (general-define-key :keymaps '(pdc-paredit--post-close-keymap)
                        "SPC" (lambda () (interactive) (just-one-space -1)))

    (defun pdc-paredit/close-round-and-newline ()
      (interactive)
      (paredit-move-past-close-and-newline ")")
      (set-transient-map pdc-paredit--post-close-keymap))

    (unbind-key "M-r" paredit-mode-map)
    (unbind-key "M-s" paredit-mode-map)

    (defun pdc/in-slime-repl-p ()
      (equal mode-name "REPL")))
#+END_SRC

*** Emacs Lisp
#+BEGIN_SRC emacs-lisp
  (req-package macrostep
    :general
    (pdc|with-leader :infix (:elisp)
     "m" 'macrostep-expand)
    (pdc|with-mode-leader :keymaps 'emacs-lisp-mode-map
     "e" 'macrostep-expand))

#+END_SRC

* Diary/calendar

** Relative dates
Folk festivals and the like are often scheduled around floating dates,
e.g. Chippenham runs from the Friday before the last Monday in May
every year. Specifying the end date with a timestamp's easy (though it
doesn't display terriby well) but specifying the start date isn't
currently supported by =diary-lib.el=. So we'll lift some ideas from
diary-remind and see where that gets us.

#+BEGIN_SRC emacs-lisp
  (defvar date)
  (defvar entry)

  (with-eval-after-load 'calendar
    (calendar-set-date-style 'iso))


  (cl-defun pdc//diary-search-from (start-date needle-sexp &key deltas limit direction inclusive)
    (let* ((direction (cond (direction (/ direction (abs direction)))
                            (limit (/ limit (abs limit)))
                            (t +1)))
           (limit (or limit (* direction 6)))
           (deltas (or deltas
                       (number-sequence (if inclusive 0 direction) limit direction))))
    
      (unless (= (* direction limit)
                 (abs limit))
        (error ":limit and :direction must have the same sign"))
      (cl-flet ((start-date+ (days)
                             (calendar-gregorian-from-absolute
                              (+ (calendar-absolute-from-gregorian start-date) days))))
        (cl-loop for delta in deltas
                 for date = (start-date+ delta)
                 when (eval needle-sexp)
                 return date))))



  (cl-defun pdc/diary-relative (sexp count &key mark interval dayname)
    (cl-flet ((date+ (days)
                     (calendar-gregorian-from-absolute
                      (+ (calendar-absolute-from-gregorian date) days))))
      (when-let*
          ((date (cond ((and interval dayname) nil)
                       (dayname
                        (when (= dayname (calendar-day-of-week date))
                          (let* ((direction (- (/ count (abs count))))
                                 (weeks (- (+ count direction)))
                                 (start-date (date+ (* 7 weeks))))
                            (pdc//diary-search-from start-date sexp :direction direction))))
                       (t (date+ (* count (or interval 1)))))))
        (when-let* ((diary-entry (eval sexp)))
          (cons mark (if (consp diary-entry)
                             (cdr diary-entry)
                           diary-entry))))))

  (with-eval-after-load 'ert 
    (require 'diary-lib)
    (ert-deftest pdc//diary-stuff ()
      (let ((entry "Diary search test")
            (date '(8 25 2017))
            (earlier-date '(8 18 2017))
            (august-bank-holiday '(diary-float 8 1 -1)))


        (should (org-date 2017 8 25))
        (should (equal '(8 28 2017)
                       (pdc//diary-search-from date august-bank-holiday)))
        (should (equal date
                       (pdc//diary-search-from date '(org-date 2017 8 25) :inclusive t)))
        (should-not (pdc//diary-search-from date '(org-date 2017 8 25)))

        (should-error (pdc//diary-search-from date august-bank-holiday :direction -1 :limit 22))

        (should (pdc/diary-relative august-bank-holiday -1 :dayname 5)))))

#+END_SRC

* Blogging & Web
I blog with Hugo, so try out easy-hugo mode. It's mostly annoying me at the moment.
#+BEGIN_SRC emacs-lisp
  (req-package easy-hugo
    :init
    (setq easy-hugo-basedir "~/Documents/singingtogether/")
    (setq easy-hugo-postdir "content/gig"))
#+END_SRC

I use prodigy to start and stop local Hugo servers running to preview our changes.

#+BEGIN_SRC emacs-lisp
  (req-package prodigy
    :config
    (prodigy-define-service
      :name "blog-serve"
      :command "hugo"
      :args '("serve" "-w")
      :cwd "~/Documents/bofh.org.uk/"
      :tags '(hugo blog)
      :stop-signal 'sigkill
      :kill-process-buffer-on-stop t))

#+END_SRC

** Web mode
#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :ensure t
    :pin melpa
    :mode "\\.html?\\'"
    :mode "\\.vue?\\'"
    :init
    (setq web-mode-enable-auto-closing t)
    (setq web-mode-enable-auto-quoting t)
    :config
    (add-to-list 'web-mode-engines-alist '("gtl" . "\\.html\'"))
    (add-to-list 'web-mode-engines-alist '("css" . (ac-source-css-property)))
    (add-to-list 'web-mode-engines-alist '("html" . (ac-source-words-in-buffer ac-source-abbrev))))

#+END_SRC

** Javascript
#+BEGIN_SRC emacs-lisp
  (use-package ac-js2 :ensure t)

  (use-package js2-mode
    :ensure t
    :mode "\\.js\\'"
    :init
    (add-hook 'js-mode-hook 'js2-minor-mode)
    (add-hook 'js2-mode-hook 'ac-js2-mode))

  (use-package js2-refactor
    :ensure t
    :config
    (js2r-add-keybindings-with-prefix "C-, m")
    (add-hook 'js2-mode-hook #'js2-refactor-mode))

  (req-package tern-auto-complete
    :ensure t)

  (req-package tern
    :ensure t
    :diminish tern-mode
    :config
    (add-hook 'js-mode-hook (lambda () (tern-mode t)))
    (add-hook 'js2-mode-hook (lambda () (tern-mode t)))
    (tern-ac-setup))

#+END_SRC

* Org-mode
Yeah, yeah, org-mode. Everyone raves.

** Org-bullets
#+BEGIN_SRC emacs-lisp
  (after-loading 'org
    (use-package org-bullets
      :config
      (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))))
#+END_SRC

** Org-ac
#+BEGIN_SRC emacs-lisp
  (after-loading 'org
    (message "Loading org-ac")
    (use-package org-ac
      :ensure t
      :commands (org-ac/config-default)
      :init
      (org-ac/config-default)))
#+END_SRC

** Org-journal
#+BEGIN_SRC emacs-lisp
  (after-loading 'org
    (after-loading 'autoinsert
      (message "Loadin org-journal")
      (use-package org-journal
       :ensure t
       :commands (org-journal-new-entry)
       :init
       (defun pdc//journal-title ()
         "The journal heading based on the file's name"
         (let* ((year (string-to-number (substring (buffer-name) 0 4)))
                (month (string-to-number (substring (buffer-name) 4 6)))
                (day (string-to-number (substring (buffer-name) 6 8)))
                (datim (encode-time 0 0 0 day month year)))
           (format-time-string org-journal-date-format datim)))

       (defun pdc/journal-file-insert ()
         "Insert the heading based on the file's name."
         (interactive)
         (insert (journal-title))
         (insert "\n\n")

         (when (equal (file-name-base (buffer-file-name))
                      (format-time-string "%Y%m%d"))
           (when (file-exists-p "journal-dailies-end.org")
             (insert-file-contents "journal-dailies-end.org")
             (insert "\n"))

           (let ((weekday-template (downcase (format-time-string)
                                             "journal-%a.org")))
             (when (file-exists-p weekday-template)
               (insert-file-contents weekday-template)))
           (when (file-exists-p "journal-dailies.org")
             (insert-file-contents "journal-dailies.org"))
           (previous-line 2)))

       :config
       (define-auto-insert "/[0-9]\\{8\\}$" [pdc|journal-file-insert]))))

#+END_SRC

** Org-mode

Load org and set up bindings under our leader keys. Includes some utility commands under `init`

#+BEGIN_SRC emacs-lisp
  (use-package org
    :diminish org-indent
    :mode
    ("\\.org\\'" . org-mode)
    :general
    (pdc|with-leader :infix "o"
      "a" 'org-agenda
      "b" 'org-switchb
      "c" '(org-capture :which-key "capture")
      "j" '(org-journal-new-entry :which-key "new journal entry")
      "l" 'org-store-link)

    (pdc|with-mode-leader :keymaps '(org-mode-map)
      "h" '(:ignore t :which-key "structure")
      "h n" '(org-insert-heading-respect-content :which-key "new")
      "h s" 'org-insert-subheading

      "c" '(:ignore t :which-key "clock")
      "c i" '(org-clock-in :which-key "in")
      "c i" '(org-clock-in :which-key "in")
      "c o" '(org-clock-out :which-key "out")
      "c d" '(org-clock-mark-default-task :which-key "clock-mark-default-task")
      "c ." '(org-time-stamp :which-key "time-stamp")
      "c c" '(org-clock-cancel :which-key "cancel")
      "c _" '(org-clock-select-task :which-key "select-task")
      "c -" '(org-clock-goto :which-key "goto")
      "c '" '(pdc|org-goto-select-task :which-key "goto-select-task")
      "c g" '(pdc|org-refile-goto :which-key "refile-goto")
      "c l" '(pdc|org-refile-goto-last :which-key "goto-last-refile")

      "r" '(pdc|org-reload-compiled :which-key "Reload org-mode (after update)")
      "R" '(pdc|org-reload-uncompiled :which-key "Reload org-mode uncompiled"))
    :init
    (defun pdc|org-goto-select-task ()
      (interactive)
      (org-clock-goto '(4)))
    (defun pdc|org-refile-goto ()
      (interactive)
      (org-refile '(4)))
    (defun pdc|org-refile-goto-last ()
      (interactive)
      (org-refile '(16)))
    (defun pdc|org-reload-uncompiled ()
      (interactive)
      (org-reload '(4)))
    (defun pdc|org-reload-compiled ()
      (interactive)
      (org-reload))

    (setq org-directory (expand-file-name "~/Dropbox/org"))

    :config
    (add-to-list 'Info-directory-list
                 (expand-file-name "../doc" (org-find-library-dir "org")))

    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (shell . t)
       (perl . t)
       (haskell . t)))

    (setq org-confirm-babel-evaluate nil
          org-src-fontify-natively t
          org-src-tab-acts-natively t
          org-iswitchb-completing-read 'ivy-completing-read)

    (require 'org-contacts)
    (setq org-default-notes-file (concat org-directory "/notes.org"))
    (setq org-capture-templates
          `(("t" "Todo" entry (file+headline ,(concat org-directory "/gtd.org") "Tasks")
                 "* TODO %?\n  %i\n  %a")
            ("F" "Folk contacts")
            ("Ff" "Festival" entry (file+datetree+prompt ,(concat org-directory "/gig-contacts.org") "Festivals")
             (file ,(concat org-directory "/capture-templates/festival.otpl")))
            ("D" "D&D")
            ("DB" "Bil Brewster" entry (file+datetree ,(concat org-directory "/bil-brewster.org" "Sessions"))
             " Session at %^{Location} 
    :PROPERTIES:
    :XP_delta:  %^{XP earned}
    :Gold_delta: %^Gold earned
    :DM:
    :Title:
    :Adventure_session_no:
    :END:
    ,** Party members
      - Bil Brewster
      -
      -
      -
    ,** Writeup
    ")))
    :ensure t)

#+END_SRC

*** Org exporters

#+BEGIN_SRC emacs-lisp
  (after-loading 'org
    (use-package ox-gfm
      :ensure t))


  (use-package autoinsert :ensure t)
#+END_SRC

** Org-agenda
#+BEGIN_SRC emacs-lisp
(use-package diary-lib)
(use-package org-agenda
  :demand t
  :init
  (setq org-agenda-files `(,org-directory "~/Documents/journal")))
#+END_SRC
