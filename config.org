# -*- mode: org; coding: utf-8 -*-
#+TODO: ACTIVE | DISABLED
#+STARTUP: indent

This is the Emacs config file of Piers Cawley.

This file is named =config.org=. =init.el= contains bootstrap code
that tangles (only) the Elisp blocks into =config.el=, which is
interpreted by Emacs on startup.

Note that all Elisp blocks which are part of a =DISABLED= heading, or
which are marked with =:tangle no= won't be tangled to the =config.el=
file. This will also make the invisible to Github's Org-mode
rendering, so the best place to read this is within Emacs.

This approach is shamelessly lifted from [[https://github.com/novoid/dot-emacs/][Novoid's dot-emacs]]. 

* Roadmap

Some near-future plans for =config.org=:

- [X] yasnippet setup (life is too short to type =#+BEGIN_SRC
  emacs-lisp= everywhere
- [ ] Leader key based keymaps
- [X] req-package based configuration and installation
- Prog-modes
  - [ ] Perl
  - [1/3] Lisps
    - [X] Emacs Lisp
    - [ ] Scheme
    - [ ] Extempore
  - [ ] Javascript
- Blogging
  - [ ] Multi-hugo support
  - Maybe blogging from org-mode?
- Navigation
  - [ ] Avy-jump
  - [ ] Swiper
  - [ ] Bookmarks
- Org mode
  - [ ] Sort out a workflow
  - Stick to it

* General settings and bootstrapping

profiling:
#+BEGIN_SRC emacs-lisp
  (defvar my-config-el-start-time (current-time)
    "Time when config.el was started")
#+END_SRC

Turn off backup files
#+BEGIN_SRC emacs-lisp
(setq backup-inhibited t)
#+END_SRC

set start of week to Monday (not sunday) http://sunsite.univie.ac.at/textbooks/emacs/emacs_33.html
#+BEGIN_SRC emacs-lisp
(setq calendar-week-start-day 1)
#+END_SRC

don't indent with tabs
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

set warning of opening large files to 100MB
#+BEGIN_SRC emacs-lisp
(setq large-file-warning-threshold 100000000)
#+END_SRC

do not add double space after periods [[http://www.reddit.com/r/emacs/comments/2l5gtz/real_sentence_in_emacs/][Real sentence in Emacs : emacs]]
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

inhibit the startup screen
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t)
#+END_SRC

** Support functions

*** hook-into-modes
#+BEGIN_SRC emacs-lisp
(defmacro hook-into-modes (func modes)
  `(--each ,modes (add-hook it ,func)))
#+END_SRC

** Package

Configure the package manager

=package-user-dir= holds the directory where ELPA installs its local
copies of the packages:

#+BEGIN_SRC emacs-lisp
(setq package-user-dir (concat my-user-emacs-directory "elpa"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (package-initialize)
  (add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/"))
  ;; unstable
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))
  (add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/packages/"))
  (add-to-list 'package-archives '("elpy" . "https://jorgenschaefer.github.io/packages/"))
  (package-refresh-contents)
#+END_SRC

Initialize our package managment and key binding:

#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (progn
      (setq package-enable-at-startup nil)
      (unless (package-installed-p 'req-package)
        (package-refresh-contents)
        (package-install 'req-package))
      (require 'use-package)
      (use-package req-package
        :init
        (add-hook 'after-init-hook (lambda () (req-package-finish)))
        :config
        (progn
          (req-package--log-enable-messaging)
          (req-package--log-enable-debugging)))

      (require 'req-package)
      (require 'cl)))

  (req-package diminish
    :force t)
  (req-package bind-key
    :force t)
#+END_SRC

*** Basic libraries

Some libraries just make life easier so we should just load them up
unconditionally and not worry about dealing with dependencies on them
and fencing some of our helper functions in calls to =req-package= to
ensure that the prereqs are required.

**** dash.el
A modern lisp manipulation library
#+BEGIN_SRC emacs-lisp
  (use-package dash
    :ensure t)
  (eval-when-compile (require 'dash))
#+END_SRC

**** s.el
A modern string manipulation library
#+BEGIN_SRC emacs-lisp
  (use-package s
    :ensure t)
#+END_SRC

**** kv.el
A modern library for messing with dictionaries
#+BEGIN_SRC emacs-lisp
  (use-package kv
    :ensure t)
#+END_SRC

** =yes-or-no-p= can die in a fire

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Eliminate duplicates from the minibuffer history

#+BEGIN_SRC emacs-lisp
(setq history-delete-duplicates t)
#+END_SRC

** Finding Emacs lisp

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (concat my-user-emacs-directory "vendor/"))
#+END_SRC

* no-littering

From:
- [[http://manuel-uberti.github.io/programming/2017/06/17/nolittering/][Manuel Uberti: Keeping your .emacs.d clean]]
- https://github.com/tarsius/no-littering

It sets some default paths in order to separate automatically created
files and directories.

#+BEGIN_SRC emacs-lisp
  (req-package no-littering)
#+END_SRC

* Styling

Making emacs look nice

Show current column:
#+BEGIN_SRC emacs-lisp
(setq column-number-mode t)
#+END_SRC

Cursor settings:
#+BEGIN_SRC emacs-lisp
;; Prevent the cursor from blinking
(blink-cursor-mode 0)
(set-cursor-color "IndianRed")
#+END_SRC

** TODO Powerline

** Themes

Zenburn, it's the only way to be sure!

#+BEGIN_SRC emacs-lisp
(load-theme 'zenburn t)
#+END_SRC

** Only one window on startup

#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-startup-hook 'delete-other-windows t)
#+END_SRC

** Font sizes


- 2011-04-20: increase/set font size
  - http://www.emacswiki.org/emacs/SetFonts

#+BEGIN_SRC emacs-lisp
(defun my-increase-fontsize ()
  (interactive)
  "Sets the font to bigger size"
  (set-face-attribute 'default (selected-frame) :height 130)
  )
(defun my-normal-fontsize ()
  (interactive)
  "Sets the font to normal size"
  (set-face-attribute 'default (selected-frame) :height 100)
  )
#+END_SRC


* UTF-8 and codings

Activate UTF-8 mode:
#+BEGIN_SRC emacs-lisp
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)

  (set-clipboard-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+END_SRC

* Leader key based bindings

** Leader keys and maps
#+BEGIN_SRC emacs-lisp
  (defvar leader-map (make-sparse-keymap))
  (defvar leader-key "M-m")
  ;(global-set-key (kbd leader-key) nil)

  (defvar mode-leader-key "M-,"
    "Prefix for mode specific leader")
#+END_SRC

** Supporting packages
which-key:
#+BEGIN_SRC emacs-lisp
  (req-package which-key
    :diminish " Ⓚ"
    :config
    (let ((new-descriptions
           '(("select-window-\\"0-9 "\\)" . "window \\1")
             ("avy-goto-word-or-subword-1" . "avy»word")
             ("shell-command" . "shell cmd")
             ("universal-argument" . "universal arg")
             ("er/expand-region" . "expand region"))))
      (dolist (nd new-descriptions)
        (push (cons (concat "\\`" (car nd) "\\'") (cdr nd))
              which-key-description-replacement-alist)))
    (setq which-key-special-keys nil
          which-key-echo-keystrokes 0.02
          which-key-max-description-length 32
          which-key-sort-order 'which-key-key-order-alpha
          which-key-idle-delay 0.4)
    (which-key-mode))
#+END_SRC

hydra:
#+BEGIN_SRC emacs-lisp
  (req-package ivy)
  (req-package ibuffer)
  (req-package hydra
    :requires (ibyffer ivy)
    :commands defhydra
    :init
    (setq hydra-head-format "%s → "))
#+END_SRC


** Supporting macros
These define space keymaps under the leader key
#+BEGIN_SRC emacs-lisp

  (defun bindings|expand-define-prefix (desc key docstr)
    (let* ((variable-name (intern (format "%s-leader-key" (symbol-name desc))))
           (doc (or docstr (symbol-name desc))))
      `(progn
         (defvar ,variable-name (format "%s %s" leader-key ,key)
           ,(format "Prefix for %s" doc))
         (general-define-key ,variable-name '(nil :which-key ,(symbol-name desc))))))

  (defmacro bindings|define-prefix (desc key &optional docstr)
    (declare (indent 1))
    (bindings|expand-define-prefix desc key docstr))
#+END_SRC

** Keymap prefixes
The idea is that most of our commands come under a tree of prefixes,
all initiated from the primary leader key. The prefixes are
essentially sparse keymaps, and I've not worked out how to easily
define them on the fly, so we predeclare the major branches of our
tree here.

We use =use-package ... :ensure t= here rather than =req-package= to
ensure that =pdc|with-leader= is avaialable to the =:general= clause
of subsequent calls to =req-package=

#+BEGIN_SRC emacs-lisp

  (use-package general
    :ensure t
    :config
    (use-package hydra
      :ensure t)
    (use-package which-key
      :ensure t)

    (general-define-key mode-leader-key '(nil :which-key "mode-leader"))
    (general-define-key leader-key '(nil :which-key "leader"))

    (bindings|define-prefix jump "j" "jumping around")
    (bindings|define-prefix search "s" "searching")
    (bindings|define-prefix files "f")
    (bindings|define-prefix window "w" "windows")
    (bindings|define-prefix buffer "b" "buffers")
    (bindings|define-prefix org "o")
    (bindings|define-prefix toggle "t" "toggles")

    (general-create-definer pdc|with-leader
                            :prefix leader-key :keymaps 'global)
    (general-create-definer pdc|with-mode-leader
                            :prefix mode-leader-key)

    (defun pdc/mplist-get (plist prop)
      "Get the values associated to PROP in PLIST, a modified plist.

  A modified plist is one where keys are keywords and values are
  all non-keywords elements that follow it.

  If there are multiple properties with the same keyword, only the first property
  and its values is returned.

  Currently this function infloops when the list is circular."
      (let ((tail plist)
            result)
        (while (and (consp tail) (not (eq prop (car tail))))
          (pop tail))
        ;; pop the found keyword
        (pop tail)
        (while (and (consp tail) (not (keywordp (car tail))))
          (push (pop tail) result))
        (nreverse result)))

    (defun bindings//expand-add-toggle (name props)
      (let* ((wrapper-func (intern (format "toggle|%s"
                                           (symbol-name name))))
             (wrapper-func-on (intern (format "%s-on" wrapper-func)))
             (wrapper-func-off (intern (format "%s-off" wrapper-func)))
             (status (plist-get props :status))
             (condition (plist-get props :if))
             (doc (plist-get props :documentation))
             (on-body (pdc/mplist-get props :on))
             (off-body (pdc/mplist-get props :off))
             (keymaps (pdc/mplist-get props :keymaps))
             (binding (plist-get props :toggle-keys))
             (status-eval `(and (or (and (symbolp ',status) (boundp ',status))
                                    (listp ',status))
                                ,status)))
        `(progn
           (defun ,wrapper-func ()
             ,(format "Toggle %s on and off." (symbol-name name))
             (interactive)
             (if (or (null ',condition)
                     (and (or (and (symbolp ',condition) (boundp ',condition))
                              (listp ',condition))
                          ,condition))
                 (if ,status-eval
                     (progn ,@off-body
                            (message ,(format "%s disabled." name)))
                   ,@on-body
                   (message ,(format "%s enabled." name)))
               (message "This toggle is not supported.")))
           ,@(when binding
               `((pdc|with-leader ,@(if keymaps `(:keymaps ',keymaps))
                                  ,binding '(,wrapper-func :which-key
                                                           ,(or doc (symbol-name name))))))
           ,@(when status
               `((defun ,wrapper-func-on ()
                   ,(format "Toggle %s on" (symbol-name name))
                   (interactive)
                   (unless ,status-eval (,wrapper-func)))
                 (defun ,wrapper-func-off ()
                   ,(format "Toggle %s off." (symbol-name name))
                   (interactive)
                   (when ,status-eval (,wrapper-func))))))))

    (defmacro bindings|add-toggle (name &rest props)
      (declare (indent 1))
      (bindings//expand-add-toggle name props))

    (defun pdc/shortdoc (fn)
      (when-let ((doc (documentation fn)))
        (substring doc 0 (string-match "\n" doc))))


    (defmacro pdc|general-bind-hydra
        (name leader &rest specs &key no-cancel &allow-other-keys)
      "Bind a hydra in such a way that others can share the prefix."
      (declare (indent defun))
      (cl-flet
          ((canonicalize-spec (spec)
                              (let* ((key (car spec))
                                     (action (cadr spec))
                                     (tail (cddr spec))
                                     (caption (cond ((stringp (car tail))
                                                     (pop tail))
                                                    ((symbolp action)
                                                     (symbol-name action))
                                                    ((functionp action)
                                                     (pdc/shortdoc action))
                                                    (t "??"))))
                                `(,key ,action ,caption ,@tail))))
        (let ((hydra-key (intern (format "hydra-%s" (symbol-name name))))
              (specs (-map #'canonicalize-spec specs)))
          `(progn
             (defhydra ,hydra-key (nil nil :color red)
               ,(symbol-name name)
               ,@specs
               ,@ (unless no-cancel '(("q" nil "cancel" :color blue))))
             (--each ',specs
               (pcase it
                 (`(,key ,fn ,desc . ,(pred (lambda (props)
                                              (plist-get props :exit))))
                  (let ((keys (concat ,leader key)))
                    (general-define-key :prefix leader-key
                                        keys (list fn :which-key desc))))
                 (`(,key ,fn ,desc . ,(and props
                                           (pred (lambda (props)
                                                   (not (plist-get props :exit))))))
                  (let ((hydra-fn (plist-get props :cmd-name))
                        (keys (concat ,leader key)))
                    (general-define-key :prefix leader-key
                                        keys (list hydra-fn :which-key desc))))))))))
    (put 'pdc|general-bind-hydra 'lisp-indent-function 2))
#+END_SRC



* Buffer and window handling
** ibuffer
#+BEGIN_SRC emacs-lisp
  (req-package ibuffer
    :config
    (fset 'list-buffers 'ibuffer)
    (defun pdc/list-buffers-int ()
      (interactive)
      (display-buffer (list-buffers-noselect nil))))

#+END_SRC

** ibuffer-vc
#+BEGIN_SRC emacs-lisp
  (req-package ibuffer-vc
    :require ibuffer
    :config
    (setq ibuffer-formats
          '((mark pdc-modified vc-status-mini
                  " " (name 35 35 :left :elide)
                  " " filename-and-process)
            (mark " " (name 16 -1) " " filename)))

    (define-ibuffer-column pdc-modified (:name "M" :inline t)
      (if (buffer-modified-p)
          (propertize "-" 'face '(:foreground "yellow"))
        " ")))
#+END_SRC

** Window numbering
Bouncing around windows using their numbers is fast and
straightforward.

#+BEGIN_SRC emacs-lisp
  (req-package window-numbering
    :requires dash
    :config
    ;; Because we don't want deferred loading here, we move the key
    ;; bindings down into config
    (pdc|with-leader :keymaps 'window-numbering-keymap
     "w1" 'select-window-1
     "w2" 'select-window-2
     "w3" 'select-window-3
     "w4" 'select-window-4
     "w5" 'select-window-5
     "w6" 'select-window-6
     "w7" 'select-window-7
     "w8" 'select-window-8

     "w0" 'bm-next
     "w9" 'bm-previous)
    ;; (defun window-numbering-install-mode-line (&optional position)
    ;;   "Do nothing, the desplay will be handled by spaceline.")
    (--each (number-sequence 0 9)
      (general-define-key :keymaps 'window-numbering-keymap
       (format "M-%s" it) nil))

    (window-numbering-mode 1))
#+END_SRC

** uniquify
Give buffers unique names
#+BEGIN_SRC emacs-lisp
  (req-package uniquify
    :config
    (setq uniquify-buffer-name-style 'post-forward-angle-brackets)
    (setq uniquify-ignore-buffers-re "^\\*")) ; don't muck with special buffers
#+END_SRC

** winner-mode
An undo tree for window configurations. Really handy.
#+BEGIN_SRC emacs-lisp
  (when (fboundp 'winner-mode)
    (winner-mode 1))
#+END_SRC

** Useful commands
- TODO Use window numbers rather than counts where appropriate [%]
  - [ ] =pdc/transpose-windows=

Various commands that affect windows and window layout

=pdc/toggle-window-split=: Toggle the orientation of a single window split.
#+BEGIN_SRC emacs-lisp
  (defun pdc/toggle-window-split ()
    "Switch between a horizontal and vertical split if there are two windows."
    (interactive)
    (when (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                            (car next-win-edges))
                                        (<= (cadr this-win-edges)
                                            (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car next-win-edges))
                  'split-window-horizontally
                'split-window-vertically))
             (delete-other-windows)
             (let ((first-win (selected-window)))
               (funcall splitter)
               (if this-win-2nd (other-window 1))
               (set-window-buffer (selected-window) this-win-buffer)
               (set-window-buffer (next-window) next-win-buffer)
               (select-window first-win)
               (if this-win-2nd (other-window 1)))))))
#+END_SRC

=pdc/transpose-windows=: Swap the buffers between two windows
#+BEGIN_SRC emacs-lisp
  (defun pdc/transpose-windows (arg)
    "Transpose the buffers shown in two windows"
    (interactive "p")
    (let ((selector (if (>= arg 0) 'next-window 'previous-window)))
      (while (/= arg 0)
        (elt ((this-win (window-buffer))
              (next-win (window-buffer (funcall selector))))
             (set-window-buffer (selected-window) next-win)
             (set-window-buffer (funcall selector) this-win)
             (select-window (funcall selector)))
        (setq arg (if (plusp arg) (1- arg) (1+ arg))))))

  (defun pdc/rotate-windows ()
    "Rotate your windows"
    (interactive)
    (cond
     ((not (> (count-windows) 1))
      (message "You can't rotate a single window!"))
     (t
      (let ((i 1)
            (num-windows (count-windows)))
        (while  (< i num-windows)
          (let* ((w1 (elt (window-list) i))
                 (w2 (elt (window-list) (+ (% i num-windows) 1)))
                 (b1 (window-buffer w1))
                 (b2 (window-buffer w2))
                 (s1 (window-start w1))
                 (s2 (window-start w2)))
            (set-window-buffer w1 b2)
            (set-window-buffer w2 b1)
            (set-window-start w1 s2)
            (set-window-start w2 s1)
            (setq i (1+ i))))))))
#+END_SRC

=pdc/sync-point-all-windows=: Move the point to the same place in all
windows. Not sure I've ever used this. Might disable it.
#+BEGIN_SRC emacs-lisp

  (defun pdc/sync-point-all-windows (&optional buffer pnt)
    "Synchronise the point in all windows"
    (interactive)
    (let ((buffer (or buffer (current-buffer)))
          (pnt (or pnt (point))))
      (dolist (f (frame-list))
        (dolist (w (window-list f))
          (if (eq (window-buffer w) buffer)
              (set-window-point w pnt))))))
#+END_SRC

=pdc/bury-buffer-other-windows=: The highlander function. When called,
it burys the buffer in the current window in all the other windows,
ensuring that the current window is the only one displaying the buffer.
#+BEGIN_SRC emacs-lisp
  (defun pdc/bury-buffer-other-windows (&optional buffer pnt)
    "Bury the current buffer in all windows but the current one."
    (interactive)
    (let ((buffer (or buffer (current-buffer))))
      (save-window-excursion
        (dolist (f (frame-list))
          (dolist (w (window-list f))
            (if (eq (window-buffer w) buffer)
                (unless (window--delete w t t)
                  (set-window-dedicated-p w nil)
                  (switch-to-prev-buffer w 'kill))))))))
#+END_SRC

=pdc/blank-other-frame-windows=: Sets all other windows in all frames
to display a =*blank*= buffer.
#+BEGIN_SRC emacs-lisp
  (defun pdc/blank-other-frame-windows ()
    (interactive)
    (let ((buffer (get-buffer-create "*blank*")))
      (save-window-excursion
        (dolist (f (frame-list))
          (dolist (w (window-list f))
            (unless (window--delete w t t)
              (set-window-dedicated-p w nil)
              (set-window-buffer w buffer)))))))
#+END_SRC



** Support functions


* Snippets

Snippet systems are the good sort of magical. Insane in many ways, and
for god's sake, don't look at yasnippet's implementation if you value
your sanity. Please, I beg of you don't. But do use them.

** yasnippet

[[https://github.com/joaotavora/yasnippet][Yasnippet]] seems to be winning the snippet tool race now

#+BEGIN_SRC emacs-lisp
  (req-package yasnippet
    :mode ("/\\.emacs\\.d/etc/yasnippet/snippets/" . snippet-mode)
    :demand t
    :diminish yas-minor-mode
    :config
    (yas-load-directory (concat my-user-emacs-directory "etc/yasnippet/snippets/"))
    (yas-global-mode 1))
#+END_SRC

** Snippet like functions

#+BEGIN_SRC emacs-lisp
  (defun my-org-insert-elisp ()
    (interactive)
    (yas-expand-snippet "#+BEGIN_SRC emacs-lisp\n$0\n#+END_SRC\n")
    (org-edit-special))

  (bindings|define-prefix snippet "S" "snippets")
  (bind-key (concat leader-key " S e") 'my-org-insert-elisp nil (eq major-mode 'org-mode))


  ;; (with-eval-after-load 'yankpad
  ;;  (bind-key "<f6>e" 'my-org-insert-elisp nil (eq major-mode 'org-mode)))

#+END_SRC

* Programming
** Version Control (Git)

#+BEGIN_SRC emacs-lisp

  (req-package with-editor
    :diminish "")

  (req-package exec-path-from-shell)

  (req-package magit
    :require exec-path-from-shell
    :demand t
    :general
    ("M-," 'pdc/vc-status)
    ("C-. g s" 'magit-status)
    (:prefix leader-key
             "g"   '(:ignore t :which-key "git")
             "g s" 'magit-status)
    :init
    (setq magit-last-seen-setup-instructions "1.4.0")
    (setq magit-branch-arguments nil)
    (setq magit-push-always-verify nil)
    :config
    (defun pdc/bookmark-magit-status (bookmark)
      "Run magit-status on the bookmarked file"
      (interactive
       (list (bookmark-completing-read "Status of bookmark"
                                       (bmkp-default-bookmark-name))))
      (magit-status (bookmark-prop-get bookmark 'filename)))
    (defun pdc/vc-status ()
      (interactive)
      (cond ((magit-get-top-dir default-directory)
             (call-interactively 'magit-status))
            (t
             (call-interactively 'dired)))))

  (req-package gist
    :init
    (setq gist-authenticate-function 'gist-oauth2-authentication)
    :general
    (pdc|with-leader
     "g G" 'gist-region-or-buffer))

  (req-package git-gutter+
    :require magit
    :diminish git-gutter+-mode
    :config
    (global-git-gutter+-mode 1))

  (req-package git-gutter-fringe+
    :config
    (git-gutter-fr+-minimal))

  (req-package magithub :require magit)

  (req-package git-timemachine)
#+END_SRC


** Programming languages

*** Lisps

There are multiple lispy modes, and we want many of them to be
initialized the same way. So we'll set up some variables to assist
with this
#+BEGIN_SRC emacs-lisp
  (defvar lisp-modes '(emacs-lisp-mode
                       inferior-emacs-lisp-mode
                       lisp-mode
                       lisp-interaction-mode
                       extempore-mode)
    "A list of Lisp style modes")

  (defvar lisp-mode-hooks
    (--map (intern (concat (symbol-name it) "-hook"))
           lisp-modes)
    "The hook variables associated with our lisp-modes")
#+END_SRC

Configure our base Lisp mode
#+BEGIN_SRC emacs-lisp
  ;; Helpers (move targets)
  (defun pdc/display-syntax (syntax-type)
    (eq syntax-type (syntax-ppss-context (syntax-ppss))))

  (defun pdc/in-syntax-p (syntax-type)
    "This only answers if you're in a comment or string at the moment."
    (eq syntax-type (syntax-ppss-context (syntax-ppss))))

  (defun pdc/in-string-p ()
    (pdc/in-syntax-p 'string))

  (defun pdc/in-comment-p ()
    (pdc/in-syntax-p 'comment))

  (defun pdc/blank-line-p ()
    "Return non-nil iff current line is blank."
    (save-excursion
      (beginning-of-line)
      (looking-at "\\s-*$")))

  (defun pdc/beginning-of-string ()
    "Go to beginning of string around point.
  Do nothing if not in string."
    ;; from loveshack's python-beginning-of-string
    (interactive)
    (if (and (not (pdc/in-string-p))
             (save-excursion
               (backward-char)
               (pdc/in-string-p)))
        (backward-char))
    (let ((state (syntax-ppss)))
      (when (eq 'string (syntax-ppss-context state))
        (goto-char (nth 8 state)))))

  (defun pdc/end-of-string ()
    (interactive)
    (if (and (not (pdc/in-string-p))
             (save-excursion
               (forward-char)
               (pdc/in-string-p)))
        (forward-char))
    (if (pdc/in-string-p)
        (progn
          (pdc/beginning-of-string)
          (forward-sexp))))

  (defun pdc/mark-string ()
    (interactive)
    (if (pdc/in-string-p)
        (progn
          (pdc/beginning-of-string)
          (forward-char)
          (push-mark nil nil t)
          (pdc/end-of-string)
          (backward-char))))

  (defun pdc/forward-string (&optional backward)
    (interactive)
    (if (pdc/in-string-p)
        (pdc/end-of-string))
    (while (not (pdc/in-string-p))
      (if backward
          (backward-char)
        (forward-char))))

  (defun pdc/backward-string ()
    (interactive)
    (if (pdc/in-string-p)
        (pdc/beginning-of-string))
    (pdc/forward-string t)
    (pdc/beginning-of-string)
    (forward-char))

  (defun pdc/out-sexp (&optional level forward syntax)
    "Skip out of any nested brackets.
   Skip forward if FORWARD is non-nil, else backward.
   If SYNTAX is non-nil it is the state returned by `syntax-ppss' at point.
   Return non-nil if and only if skipping was done."
    (interactive)
    (if (pdc/in-string-p)
        (pdc/beginning-of-string))
    (progn
      (let* ((depth (syntax-ppss-depth (or syntax (syntax-ppss))))
             (level (or level depth))
             (forward (if forward -1 1)))
        (unless (zerop depth)
          (if (> depth 0)
              ;; Skip forward out of nested brackets.
              (condition-case ()            ; beware invalid syntax
                  (progn (backward-up-list (* forward level)) t)
                (error nil))
            ;; Invalid syntax (too many closed brackets).
            ;; Skip out of as many as possible.
            (let (done)
              (while (condition-case ()
                         (progn (backward-up-list forward)
                                (setq done t))
                       (error nil)))
              done))))))

  (defun pdc/flash-region (beg end)
    (interactive "r")
    (let ((ovl (make-overlay beg end))
          (was-mark-active mark-active))
      (setq mark-active nil)
      (overlay-put ovl 'face 'highlight)
      (run-with-timer 0.5 nil
                      (lambda (ovl was-mark-active)
                        (delete-overlay ovl)
                        (setq mark-active was-mark-active))
                      ovl was-mark-active)))

  (defun pdc/indent-sexp ()
    "http://mihai.bazon.net/projects/editing-javascript-with-emacs-js2-mode
    can be used from any coding major mode"
    (interactive)
    (save-restriction
      (save-excursion
        (widen)
        (let* ((inhibit-point-motion-hooks t)
               (parse-status (syntax-ppss (point)))
               (beg (nth 1 parse-status))
               (end-marker (make-marker))
               (end (progn (goto-char beg) (forward-list) (point))))
          (pdc/flash-region beg end)
          (set-marker end-marker end)
          (goto-char beg)
          (while (< (point) (marker-position end-marker))
            ;; don't reindent blank lines so we don't set the "buffer
            ;; modified" property for nothing
            (beginning-of-line)
            (unless (looking-at "\\s-*$")
              (indent-according-to-mode))
            (forward-line))))))

  (req-package autoinsert)
  (req-package finder)


  (req-package lisp-mode
    :require (finder paredit)
    :demand t
    :general
    (pdc|with-leader
     "e" '(nil :which-key "elisp"))
    :config

    (defun my-byte-recompile-file ()
      (save-excursion
        (byte-recompile-file buffer-file-name)))


    (defun emacs-lisp-rebuild-associated-elc ()
      "If you're saving an elisp file, the .elc is probably now invalid"
      (make-local-variable 'after-save-hook)
      (add-hook 'after-save-hook 'my-byte-recompile-file))

    (add-hook-exec 'emacs-lisp-mode-hook 'emacs-lisp-rebuild-associated-elc)

    (defun pdc/goto-match-paren (arg)
      "Go to the matching parenthesis if on parenthesis. Else go up to the opening parenthesis one level up."
      (interactive "p")
      (cond ((looking-at "\\s(") (forward-list 1))
            (t
             (backward-char 1)
             (cond ((looking-at "\\s\)")
                    (forward-char 1)
                    (backward-list 1))
                   (t
                    (while (not (looking-at "\\s\)"))
                      (backward-char 1)
                      (cond ((looking-at "\\s\)")
                             (backward-char 1)
                             (when (looking-at "\\s\)")
                               (forward-char 1)
                               (backward-list 1)
                               (backward-char 1))))))))))

    (defun pdc/replace-sexp ()
      (interactive)
      (if (pdc/in-string-p)
          (pdc/mark-string)
        (mark-sexp))
      (delete-region (point) (mark))
      (yank))


    (defun my-lisp-mode-hook ()
      (auto-fill-mode 1)
      (paredit-mode +1)
      ;; (redshank-mode 1)
      ;; (elisp-slime-nav-mode 1)
      (add-hook 'after-save-hook 'check-parens
                nil t)
      (yas-minor-mode 1))

    (hook-into-modes 'my-lisp-mode-hook lisp-mode-hooks))



  (req-package elisp-mode
    :require lisp-mode
    :demand t
    :config
    (pdc|with-leader
     "e c" 'finder-commentary
     "e e" 'view-echo-area-messages
     "e f" 'find-function
     "e F" 'find-face-definition)

    (defun pdc/elisp-mode-hook ()
      (eldoc-mode 1)
      (setq mode-name "EL"))
    (add-hook 'emacs-lisp-mode-hook 'pdc/elisp-mode-hook ())
    (setq emacs-lisp-mode-hook (-remove-item 'lexbind-mode emacs-lisp-mode-hook)))


  (req-package paredit
    :commands paredit-mode
    :demand t
    :diminish " Ⓟ"
    :bind
    (:map paredit-mode-map
          ("DEL" . pdc/paredit-backward-delete)
          ("M-RET" . pdc/indent-defun)
          ("C-M-l" . paredit-recentre-on-sexp)
          ("C-M-s" . paredit-backward-up)
          ("C-M-k" . paredit-forward-slurp-sexp)
          ("C-M-j" . paredit-backward-slurp-sexp)
          ("C-M-\\" . pdc/indent-then-snap-to-indent)
          ("M-o" . pdc/paredit-open-line)
          ("C-M-y" . pdc/replace-sexp)
          ("C-M-y" . pdc/replace-sexp)
          ("C-y" . pdc/paredit-yank)
          ("(" . pdc/paredit-open-parenthesis)
          (";" . pdc/paredit-semicolon)
          ("M-w" . pdc/paredit-kill-ring-save)
          (")" . paredit-close-round-and-newline)
          ("M-)" . paredit-close-round)
          ("M-k" . paredit-raise-sexp)
          ("M-I" . paredit-splice-sexp)
          ("C-. d" . paredit-forward-down)
          ("C-. B" . paredit-splice-sexp-killing-backward)
          ("C-. C" . paredit-convolute-sexp)
          ("C-. F" . paredit-splice-sexp-killing-forward)
          ("C-. a" . paredit-add-to-next-list)
          ("C-. A" . paredit-add-to-previous-list)
          ("C-. j" . paredit-join-with-next-list)
          ("C-. J" . paredit-join-with-previous-list))
    :config
    (defun pdc/indent-defun ()
      (interactive)
      (save-excursion
        (pdc/out-sexp)
        (forward-char)
        (pdc/indent-sexp)))

    (defun pdc/paredit-backward-delete ()
      (interactive)
      (if mark-active
          (call-interactively 'delete-region)
        (paredit-backward-delete)))

    (defun pdc/indent-defun-or-region ()
      (interactive)
      (if mark-active
          (call-interactively 'indent-region)
        (pdc/indent-defun)))

    (defun pdc/indent-then-snap-to-indent ()
      (interactive)
      (pdc/indent-defun-or-region)
      (back-to-indentation))

    (defun pdc/paredit-yank ()
      (interactive)
      (call-interactively 'yank)
      (unless mark-active
        (when (and (looking-back "\)" 1)
                   (looking-at "\("))
          (reindent-then-newline-and-indent)
          (when (looking-at-p "^")
            (newline))))
      (condition-case nil (pdc/indent-defun)))

    (defun pdc/paredit-open-line ()
      (interactive)
      (save-excursion
        (reindent-then-newline-and-indent))
      (indent-according-to-mode))

    (defun pdc/paredit-kill-ring-save ()
      (interactive)
      (if (not mark-active)
          (save-excursion
            (when (looking-at-p " +\(")
              (search-forward "(")
              (backward-char))
            (mark-sexp)
            (call-interactively 'kill-ring-save))
        (call-interactively 'kill-ring-save)))

    (defun pdc/paredit-open-parenthesis (&optional n)
      (interactive "P") 
      (cond ((and (looking-back "\(" 1)
                  (looking-at "\)"))
             (paredit-open-parenthesis n))
            ((equal last-command this-command)
             (undo)
             (insert " ")
             (backward-char 1)
             (paredit-open-parenthesis n))
            ((and (not (or mark-active (pdc/in-string-p)))
                  (looking-at-p "[\(a-z\"#\\[{]"))
             (mark-sexp)
             (paredit-open-parenthesis n)
             (when (looking-at-p "[\(\"#\\[{]")
               (save-excursion (insert " "))))
            (t (paredit-open-parenthesis n))))

    (defun pdc/paredit-semicolon (&optional n)
      (interactive "P")
      (when (looking-at-p "  +\(")
        (search-forward "(")
        (backward-char))
      (cond ((or (looking-back ";" 1)
                 (looking-at-p "[[:blank:]]*$"))
             (self-insert-command 1))
            ((equal last-command this-command)
             (undo)
             (self-insert-command 1))
            ((and (not mark-active) 
                  (looking-at-p "^[[:blank:]]*$"))
             (insert ";;; "))
            ((and (not mark-active)
                  (save-excursion
                    (beginning-of-line)
                    (looking-at-p "[[:blank:]]*$")))
             (insert ";; "))
            (t (paredit-semicolon n))))

    (unbind-key "M-r" paredit-mode-map)
    (unbind-key "M-s" paredit-mode-map)

    (defun pdc/in-slime-repl-p ()
      (equal mode-name "REPL")))

#+END_SRC

*** Emacs Lisp

