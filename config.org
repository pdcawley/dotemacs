# -*- mode: org; coding: utf-8 -*-
#+TODO: ACTIVE | DISABLED
#+STARTUP: indent

This is the Emacs config file of Piers Cawley.

This file is named =config.org=. =init.el= contains bootstrap code
that tangles (only) the Elisp blocks into =config.el=, which is
interpreted by Emacs on startup.

Note that all Elisp blocks which are part of a =DISABLED= heading, or
which are marked with =:tangle no= won't be tangled to the =config.el=
file. This will also make the invisible to Github's Org-mode
rendering, so the best place to read this is within Emacs.

This approach is shamelessly lifted from [[https://github.com/novoid/dot-emacs/][Novoid's dot-emacs]]. 

* Roadmap

Some near-future plans for =config.org=:

- [X] yasnippet setup (life is too short to type =#+BEGIN_SRC
  emacs-lisp= everywhere
- [ ] Leader key based keymaps
- [X] req-package based configuration and installation
- Prog-modes
  - [ ] Perl
  - [1/3] Lisps
    - [X] Emacs Lisp
    - [ ] Scheme
    - [ ] Extempore
  - [ ] Javascript
- Blogging
  - [ ] Multi-hugo support
  - Maybe blogging from org-mode?
- Navigation
  - [ ] Avy-jump
  - [ ] Swiper
  - [ ] Bookmarks
- Org mode
  - [ ] Sort out a workflow
  - Stick to it

* General settings and bootstrapping

profiling:
#+BEGIN_SRC emacs-lisp
  (defvar my-config-el-start-time (current-time)
    "Time when config.el was started")
#+END_SRC

Turn off backup files
#+BEGIN_SRC emacs-lisp
(setq backup-inhibited t)
#+END_SRC

set start of week to Monday (not sunday) http://sunsite.univie.ac.at/textbooks/emacs/emacs_33.html
#+BEGIN_SRC emacs-lisp
(setq calendar-week-start-day 1)
#+END_SRC

don't indent with tabs
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

set warning of opening large files to 100MB
#+BEGIN_SRC emacs-lisp
(setq large-file-warning-threshold 100000000)
#+END_SRC

do not add double space after periods [[http://www.reddit.com/r/emacs/comments/2l5gtz/real_sentence_in_emacs/][Real sentence in Emacs : emacs]]
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

inhibit the startup screen
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t)
#+END_SRC

** Support functions

*** hook-into-modes
#+BEGIN_SRC emacs-lisp
(defmacro hook-into-modes (func modes)
  `(--each ,modes (add-hook it ,func)))
#+END_SRC

** Package

Configure the package manager

=package-user-dir= holds the directory where ELPA installs its local
copies of the packages:

#+BEGIN_SRC emacs-lisp
(setq package-user-dir (concat my-user-emacs-directory "elpa"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (package-initialize)
  ;;(add-to-list 'package-archives '("melpa" . "http://stable.melpa.org/packages/"))
  ;; unstable
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))
  (add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/packages/"))
  (add-to-list 'package-archives '("elpy" . "https://jorgenschaefer.github.io/packages/"))
  (package-refresh-contents)
#+END_SRC

Initialize our package managment and key binding:

#+BEGIN_SRC emacs-lisp
  (eval-when-compile
    (progn
      (require 'req-package)
      (require 'cl)))

  (setq package-enable-at-startup nil)
  (unless (package-installed-p 'req-package)
    (package-refresh-contents)
    (package-install 'req-package))

  ;; After config.el has loaded, we run the 
  (use-package req-package
    :init
    (add-hook 'after-init-hook (lambda () (req-package-finish)))
    :config
    (progn
      (req-package--log-enable-messaging)
      (req-package--log-enable-debugging)))

  (req-package diminish
    :force t)
  (req-package bind-key
    :force t)
#+END_SRC

*** Basic libraries

Some libraries just make life easier so we should just load them up
unconditionally and not worry about dealing with dependencies on them
and fencing some of our helper functions in calls to =req-package= to
ensure that the prereqs are required.

**** dash.el
A modern lisp manipulation library
#+BEGIN_SRC emacs-lisp
  (use-package dash
    :ensure t)
  (eval-when-compile (require 'dash))
#+END_SRC

**** s.el
A modern string manipulation library
#+BEGIN_SRC emacs-lisp
  (use-package s
    :ensure t)
#+END_SRC

**** kv.el
A modern library for messing with dictionaries
#+BEGIN_SRC emacs-lisp
  (use-package kv
    :ensure t)
#+END_SRC

** =yes-or-no-p= can die in a fire

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Eliminate duplicates from the minibuffer history

#+BEGIN_SRC emacs-lisp
(setq history-delete-duplicates t)
#+END_SRC

** Finding Emacs lisp

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (concat my-user-emacs-directory "vendor/"))
#+END_SRC

* no-littering

From:
- [[http://manuel-uberti.github.io/programming/2017/06/17/nolittering/][Manuel Uberti: Keeping your .emacs.d clean]]
- https://github.com/tarsius/no-littering

It sets some default paths in order to separate automatically created
files and directories.

#+BEGIN_SRC emacs-lisp
  (req-package no-littering)
#+END_SRC

* Styling

Making emacs look nice

Show current column:
#+BEGIN_SRC emacs-lisp
(setq column-number-mode t)
#+END_SRC

Cursor settings:
#+BEGIN_SRC emacs-lisp
;; Prevent the cursor from blinking
(blink-cursor-mode 0)
(set-cursor-color "IndianRed")
#+END_SRC

** TODO Powerline

** Themes

Zenburn, it's the only way to be sure!

#+BEGIN_SRC emacs-lisp
(load-theme 'zenburn t)
#+END_SRC

** Only one window on startup

#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-startup-hook 'delete-other-windows t)
#+END_SRC

** Font sizes


- 2011-04-20: increase/set font size
  - http://www.emacswiki.org/emacs/SetFonts

#+BEGIN_SRC emacs-lisp
(defun my-increase-fontsize ()
  (interactive)
  "Sets the font to bigger size"
  (set-face-attribute 'default (selected-frame) :height 130)
  )
(defun my-normal-fontsize ()
  (interactive)
  "Sets the font to normal size"
  (set-face-attribute 'default (selected-frame) :height 100)
  )
#+END_SRC


* UTF-8 and codings

Activate UTF-8 mode:
#+BEGIN_SRC emacs-lisp
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)

  (set-clipboard-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+END_SRC

* Leader key based bindings

** Leader keys and maps
#+BEGIN_SRC emacs-lisp
  (defvar leader-map (make-sparse-keymap))
  (defvar leader-key "M-m")
  ;(global-set-key (kbd leader-key) nil)

  (defvar mode-leader-key "M-,"
    "Prefix for mode specific leader")
#+END_SRC

** Supporting packages
which-key:
#+BEGIN_SRC emacs-lisp
  (req-package which-key
    :diminish " Ⓚ"
    :config
    (let ((new-descriptions
           '(("select-window-\\"0-9 "\\)" . "window \\1")
             ("avy-goto-word-or-subword-1" . "avy»word")
             ("shell-command" . "shell cmd")
             ("universal-argument" . "universal arg")
             ("er/expand-region" . "expand region"))))
      (dolist (nd new-descriptions)
        (push (cons (concat "\\`" (car nd) "\\'") (cdr nd))
              which-key-description-replacement-alist)))
    (setq which-key-special-keys nil
          which-key-echo-keystrokes 0.02
          which-key-max-description-length 32
          which-key-sort-order 'which-key-key-order-alpha
          which-key-idle-delay 0.4)
    (which-key-mode))
#+END_SRC

hydra:
#+BEGIN_SRC emacs-lisp
  (req-package ivy)
  (req-package ibuffer)
  (req-package hydra
    :requires (ibyffer ivy)
    :commands defhydra
    :init
    (setq hydra-head-format "%s → "))
#+END_SRC


** Supporting macros
These define space keymaps under the leader key
#+BEGIN_SRC emacs-lisp

  (defun bindings|expand-define-prefix (desc key docstr)
    (let* ((variable-name (intern (format "%s-leader-key" (symbol-name desc))))
           (doc (or docstr (symbol-name desc))))
      `(progn
         (defvar ,variable-name (format "%s %s" leader-key ,key)
           ,(format "Prefix for %s" doc))
         (general-define-key ,variable-name '(nil :which-key ,(symbol-name desc))))))

  (defmacro bindings|define-prefix (desc key &optional docstr)
    (declare (indent 1))
    (bindings|expand-define-prefix desc key docstr))
#+END_SRC

** Keymap prefixes
The idea is that most of our commands come under a tree of prefixes,
all initiated from the primary leader key. The prefixes are
essentially sparse keymaps, and I've not worked out how to easily
define them on the fly, so we predeclare the major branches of our
tree here.

#+BEGIN_SRC emacs-lisp

  (use-package general
    :ensure t
    :config
    (use-package hydra
      :ensure t)
    (use-package which-key
      :ensure t)

    (general-define-key mode-leader-key '(nil :which-key "mode-leader"))
    (general-define-key leader-key '(nil :which-key "leader"))

    (bindings|define-prefix jump "j" "jumping around")
    (bindings|define-prefix search "s" "searching")
    (bindings|define-prefix files "f")
    (bindings|define-prefix window "w" "windows")
    (bindings|define-prefix buffer "b" "buffers")
    (bindings|define-prefix org "o")
    (bindings|define-prefix toggle "t" "toggles")

    (general-create-definer pdc|with-leader
                            :prefix leader-key :keymaps 'global)
    (general-create-definer pdc|with-mode-leader
                            :prefix mode-leader-key)

    (defun pdc/mplist-get (plist prop)
      "Get the values associated to PROP in PLIST, a modified plist.

  A modified plist is one where keys are keywords and values are
  all non-keywords elements that follow it.

  If there are multiple properties with the same keyword, only the first property
  and its values is returned.

  Currently this function infloops when the list is circular."
      (let ((tail plist)
            result)
        (while (and (consp tail) (not (eq prop (car tail))))
          (pop tail))
        ;; pop the found keyword
        (pop tail)
        (while (and (consp tail) (not (keywordp (car tail))))
          (push (pop tail) result))
        (nreverse result)))

    (defun bindings//expand-add-toggle (name props)
      (let* ((wrapper-func (intern (format "toggle|%s"
                                           (symbol-name name))))
             (wrapper-func-on (intern (format "%s-on" wrapper-func)))
             (wrapper-func-off (intern (format "%s-off" wrapper-func)))
             (status (plist-get props :status))
             (condition (plist-get props :if))
             (doc (plist-get props :documentation))
             (on-body (pdc/mplist-get props :on))
             (off-body (pdc/mplist-get props :off))
             (keymaps (pdc/mplist-get props :keymaps))
             (binding (plist-get props :toggle-keys))
             (status-eval `(and (or (and (symbolp ',status) (boundp ',status))
                                    (listp ',status))
                                ,status)))
        `(progn
           (defun ,wrapper-func ()
             ,(format "Toggle %s on and off." (symbol-name name))
             (interactive)
             (if (or (null ',condition)
                     (and (or (and (symbolp ',condition) (boundp ',condition))
                              (listp ',condition))
                          ,condition))
                 (if ,status-eval
                     (progn ,@off-body
                            (message ,(format "%s disabled." name)))
                   ,@on-body
                   (message ,(format "%s enabled." name)))
               (message "This toggle is not supported.")))
           ,@(when binding
               `((pdc|with-leader ,@(if keymaps `(:keymaps ',keymaps))
                                  ,binding '(,wrapper-func :which-key
                                                           ,(or doc (symbol-name name))))))
           ,@(when status
               `((defun ,wrapper-func-on ()
                   ,(format "Toggle %s on" (symbol-name name))
                   (interactive)
                   (unless ,status-eval (,wrapper-func)))
                 (defun ,wrapper-func-off ()
                   ,(format "Toggle %s off." (symbol-name name))
                   (interactive)
                   (when ,status-eval (,wrapper-func))))))))

    (defmacro bindings|add-toggle (name &rest props)
      (declare (indent 1))
      (bindings//expand-add-toggle name props))

    (defun pdc/shortdoc (fn)
      (when-let ((doc (documentation fn)))
        (substring doc 0 (string-match "\n" doc))))


    (defmacro pdc|general-bind-hydra
        (name leader &rest specs &key no-cancel &allow-other-keys)
      "Bind a hydra in such a way that others can share the prefix."
      (declare (indent defun))
      (cl-flet
          ((canonicalize-spec (spec)
                              (let* ((key (car spec))
                                     (action (cadr spec))
                                     (tail (cddr spec))
                                     (caption (cond ((stringp (car tail))
                                                     (pop tail))
                                                    ((symbolp action)
                                                     (symbol-name action))
                                                    ((functionp action)
                                                     (pdc/shortdoc action))
                                                    (t "??"))))
                                `(,key ,action ,caption ,@tail))))
        (let ((hydra-key (intern (format "hydra-%s" (symbol-name name))))
              (specs (-map #'canonicalize-spec specs)))
          `(progn
             (defhydra ,hydra-key (nil nil :color red)
               ,(symbol-name name)
               ,@specs
               ,@ (unless no-cancel '(("q" nil "cancel" :color blue))))
             (--each ',specs
               (pcase it
                 (`(,key ,fn ,desc . ,(pred (lambda (props)
                                              (plist-get props :exit))))
                  (let ((keys (concat ,leader key)))
                    (general-define-key :prefix leader-key
                                        keys (list fn :which-key desc))))
                 (`(,key ,fn ,desc . ,(and props
                                           (pred (lambda (props)
                                                   (not (plist-get props :exit))))))
                  (let ((hydra-fn (plist-get props :cmd-name))
                        (keys (concat ,leader key)))
                    (general-define-key :prefix leader-key
                                        keys (list hydra-fn :which-key desc))))))))))
    (put 'pdc|general-bind-hydra 'lisp-indent-function 2))
#+END_SRC




* Snippets

Snippet systems are the good sort of magical. Insane in many ways, and
for god's sake, don't look at yasnippet's implementation if you value
your sanity. Please, I beg of you don't. But do use them.

** yasnippet

[[https://github.com/joaotavora/yasnippet][Yasnippet]] seems to be winning the snippet tool race now

#+BEGIN_SRC emacs-lisp
  (req-package yasnippet
    :mode ("/\\.emacs\\.d/etc/yasnippet/snippets/" . snippet-mode)
    :diminish yas-minor-mode
    :config
    (yas-load-directory (concat my-user-emacs-directory "etc/yasnippet/snippets/"))
    (yas-global-mode 1))
#+END_SRC

** yankpad

[[https://github.com/Kungsgeten/yankpad][yankpad]] is an add-on that enables easy management of yasnippet
snippets within an Org-mode file. I do define Org-mode-independent
snippets with the basic yasnippet methods. Any snippet that is used
within Org-mode only is defined in my yankpad file.

#+BEGIN_SRC emacs-lisp
  (req-package yankpad
    :requires yasnippet
    :bind
    ("<f6>" . yankpad-keymap)
    :init
    (setq yankpad-file "~/org/yankpad.org"))
#+END_SRC

** Snippet like functions

#+BEGIN_SRC emacs-lisp
  (defun my-org-insert-elisp ()
    (interactive)
    (yas-expand-snippet "#+BEGIN_SRC emacs-lisp\n$0\n#+END_SRC\n")
    (org-edit-special))
  (bind-key "<f6> e" 'my-org-insert-elisp nil (eq major-mode 'org-mode))

#+END_SRC

* Programming languages

** Lisps

There are multiple lispy modes, and we want many of them to be
initialized the same way. So we'll set up some variables to assist
with this
#+BEGIN_SRC emacs-lisp
  (defvar lisp-modes '(emacs-lisp-mode
                       inferior-emacs-lisp-mode
                       lisp-mode
                       lisp-interaction-mode
                       extempore-mode)
    "A list of Lisp style modes")

  (defvar lisp-mode-hooks
    (--map (intern (concat (symbol-name it) "-hook"))
           lisp-modes)
    "The hook variables associated with our lisp-modes")
#+END_SRC

Configure our base Lisp mode
#+BEGIN_SRC emacs-lisp
  ;; Helpers (move targets)
  (defun pdc/display-syntax (syntax-type)
    (eq syntax-type (syntax-ppss-context (syntax-ppss))))

  (defun pdc/in-syntax-p (syntax-type)
    "This only answers if you're in a comment or string at the moment."
    (eq syntax-type (syntax-ppss-context (syntax-ppss))))

  (defun pdc/in-string-p ()
    (pdc/in-syntax-p 'string))

  (defun pdc/in-comment-p ()
    (pdc/in-syntax-p 'comment))

  (defun pdc/blank-line-p ()
    "Return non-nil iff current line is blank."
    (save-excursion
      (beginning-of-line)
      (looking-at "\\s-*$")))

  (defun pdc/beginning-of-string ()
    "Go to beginning of string around point.
  Do nothing if not in string."
    ;; from loveshack's python-beginning-of-string
    (interactive)
    (if (and (not (pdc/in-string-p))
             (save-excursion
               (backward-char)
               (pdc/in-string-p)))
        (backward-char))
    (let ((state (syntax-ppss)))
      (when (eq 'string (syntax-ppss-context state))
        (goto-char (nth 8 state)))))

  (defun pdc/end-of-string ()
    (interactive)
    (if (and (not (pdc/in-string-p))
             (save-excursion
               (forward-char)
               (pdc/in-string-p)))
        (forward-char))
    (if (pdc/in-string-p)
        (progn
          (pdc/beginning-of-string)
          (forward-sexp))))

  (defun pdc/mark-string ()
    (interactive)
    (if (pdc/in-string-p)
        (progn
          (pdc/beginning-of-string)
          (forward-char)
          (push-mark nil nil t)
          (pdc/end-of-string)
          (backward-char))))

  (defun pdc/forward-string (&optional backward)
    (interactive)
    (if (pdc/in-string-p)
        (pdc/end-of-string))
    (while (not (pdc/in-string-p))
      (if backward
          (backward-char)
        (forward-char))))

  (defun pdc/backward-string ()
    (interactive)
    (if (pdc/in-string-p)
        (pdc/beginning-of-string))
    (pdc/forward-string t)
    (pdc/beginning-of-string)
    (forward-char))

  (defun pdc/out-sexp (&optional level forward syntax)
    "Skip out of any nested brackets.
   Skip forward if FORWARD is non-nil, else backward.
   If SYNTAX is non-nil it is the state returned by `syntax-ppss' at point.
   Return non-nil if and only if skipping was done."
    (interactive)
    (if (pdc/in-string-p)
        (pdc/beginning-of-string))
    (progn
      (let* ((depth (syntax-ppss-depth (or syntax (syntax-ppss))))
             (level (or level depth))
             (forward (if forward -1 1)))
        (unless (zerop depth)
          (if (> depth 0)
              ;; Skip forward out of nested brackets.
              (condition-case ()            ; beware invalid syntax
                  (progn (backward-up-list (* forward level)) t)
                (error nil))
            ;; Invalid syntax (too many closed brackets).
            ;; Skip out of as many as possible.
            (let (done)
              (while (condition-case ()
                         (progn (backward-up-list forward)
                                (setq done t))
                       (error nil)))
              done))))))

  (defun pdc/flash-region (beg end)
    (interactive "r")
    (let ((ovl (make-overlay beg end))
          (was-mark-active mark-active))
      (setq mark-active nil)
      (overlay-put ovl 'face 'highlight)
      (run-with-timer 0.5 nil
                      (lambda (ovl was-mark-active)
                        (delete-overlay ovl)
                        (setq mark-active was-mark-active))
                      ovl was-mark-active)))

  (defun pdc/indent-sexp ()
    "http://mihai.bazon.net/projects/editing-javascript-with-emacs-js2-mode
    can be used from any coding major mode"
    (interactive)
    (save-restriction
      (save-excursion
        (widen)
        (let* ((inhibit-point-motion-hooks t)
               (parse-status (syntax-ppss (point)))
               (beg (nth 1 parse-status))
               (end-marker (make-marker))
               (end (progn (goto-char beg) (forward-list) (point))))
          (pdc/flash-region beg end)
          (set-marker end-marker end)
          (goto-char beg)
          (while (< (point) (marker-position end-marker))
            ;; don't reindent blank lines so we don't set the "buffer
            ;; modified" property for nothing
            (beginning-of-line)
            (unless (looking-at "\\s-*$")
              (indent-according-to-mode))
            (forward-line))))))

  (req-package autoinsert)
  (req-package finder)


  (req-package lisp-mode
    :require (finder paredit)
    :general
    (pdc|with-leader
     "e" '(nil :which-key "elisp"))
    :force t
    :loader :path
    :config
    (defun my-byte-recompile-file ()
      (save-excursion
        (byte-recompile-file buffer-file-name)))


    (defun emacs-lisp-rebuild-associated-elc ()
      "If you're saving an elisp file, the .elc is probably now invalid"
      (make-local-variable 'after-save-hook)
      (add-hook 'after-save-hook 'my-byte-recompile-file))

    (add-hook 'emacs-lisp-mode-hook 'emacs-lisp-rebuild-associated-elc)

    (defun pdc/goto-match-paren (arg)
      "Go to the matching parenthesis if on parenthesis. Else go up to the opening parenthesis one level up."
      (interactive "p")
      (cond ((looking-at "\\s(") (forward-list 1))
            (t
             (backward-char 1)
             (cond ((looking-at "\\s\)")
                    (forward-char 1)
                    (backward-list 1))
                   (t
                    (while (not (looking-at "\\s\)"))
                      (backward-char 1)
                      (cond ((looking-at "\\s\)")
                             (backward-char 1)
                             (when (looking-at "\\s\)")
                               (forward-char 1)
                               (backward-list 1)
                               (backward-char 1))))))))))

    (defun pdc/replace-sexp ()
      (interactive)
      (if (pdc/in-string-p)
          (pdc/mark-string)
        (mark-sexp))
      (delete-region (point) (mark))
      (yank))


    (defun my-lisp-mode-hook ()
      (auto-fill-mode 1)
      (paredit-mode +1)
      ;; (redshank-mode 1)
      ;; (elisp-slime-nav-mode 1)
      (add-hook 'after-save-hook 'check-parens
                nil t)
      (yas-minor-mode 1))

    (hook-into-modes 'my-lisp-mode-hook lisp-mode-hooks))


  (req-package elisp-mode
    :require lisp-mode
    :loader :path
    :general
    (pdc|with-leader
     "e c" 'finder-commentary
     "e e" 'view-echo-area-messages
     "e f" 'find-function
     "e F" 'find-face-definition)
    :config
    (defun pdc/elisp-mode-hook ()
      (eldoc-mode 1)
      (setq mode-name "EL"))
    (add-hook 'emacs-lisp-mode-hook 'pdc/elisp-mode-hook ())
    (setq emacs-lisp-mode-hook (-remove-item 'lexbind-mode emacs-lisp-mode-hook)))


                                          ;(req-package elisp-slime-nav-mode)

  (req-package paredit
    :commands paredit-mode
    :require
    :diminish " Ⓟ"
    :bind
    (:map paredit-mode-map
          ("DEL" . pdc/paredit-backward-delete)
          ("M-RET" . pdc/indent-defun)
          ("C-M-l" . paredit-recentre-on-sexp)
          ("C-M-s" . paredit-backward-up)
          ("C-M-k" . paredit-forward-slurp-sexp)
          ("C-M-j" . paredit-backward-slurp-sexp)
          ("C-M-\\" . pdc/indent-then-snap-to-indent)
          ("M-o" . pdc/paredit-open-line)
          ("C-M-y" . pdc/replace-sexp)
          ("C-M-y" . pdc/replace-sexp)
          ("C-y" . pdc/paredit-yank)
          ("(" . pdc/paredit-open-parenthesis)
          (";" . pdc/paredit-semicolon)
          ("M-w" . pdc/paredit-kill-ring-save)
          (")" . paredit-close-round-and-newline)
          ("M-)" . paredit-close-round)
          ("M-k" . paredit-raise-sexp)
          ("M-I" . paredit-splice-sexp)
          ("C-. d" . paredit-forward-down)
          ("C-. B" . paredit-splice-sexp-killing-backward)
          ("C-. C" . paredit-convolute-sexp)
          ("C-. F" . paredit-splice-sexp-killing-forward)
          ("C-. a" . paredit-add-to-next-list)
          ("C-. A" . paredit-add-to-previous-list)
          ("C-. j" . paredit-join-with-next-list)
          ("C-. J" . paredit-join-with-previous-list))
    :config
    (defun pdc/indent-defun ()
      (interactive)
      (save-excursion
        (pdc/out-sexp)
        (forward-char)
        (pdc/indent-sexp)))

    (defun pdc/paredit-backward-delete ()
      (interactive)
      (if mark-active
          (call-interactively 'delete-region)
        (paredit-backward-delete)))

    (defun pdc/indent-defun-or-region ()
      (interactive)
      (if mark-active
          (call-interactively 'indent-region)
        (pdc/indent-defun)))

    (defun pdc/indent-then-snap-to-indent ()
      (interactive)
      (pdc/indent-defun-or-region)
      (back-to-indentation))

    (defun pdc/paredit-yank ()
      (interactive)
      (call-interactively 'yank)
      (unless mark-active
        (when (and (looking-back "\)" 1)
                   (looking-at "\("))
          (reindent-then-newline-and-indent)
          (when (looking-at-p "^")
            (newline))))
      (condition-case nil (pdc/indent-defun)))




    (defun pdc/paredit-open-line ()
      (interactive)
      (save-excursion
        (reindent-then-newline-and-indent))
      (indent-according-to-mode))

    (defun pdc/paredit-kill-ring-save ()
      (interactive)
      (if (not mark-active)
          (save-excursion
            (when (looking-at-p " +\(")
              (search-forward "(")
              (backward-char))
            (mark-sexp)
            (call-interactively 'kill-ring-save))
        (call-interactively 'kill-ring-save)))

    (defun pdc/paredit-open-parenthesis (&optional n)
      (interactive "P") 
      (cond ((and (looking-back "\(" 1)
                  (looking-at "\)"))
             (paredit-open-parenthesis n))
            ((equal last-command this-command)
             (undo)
             (insert " ")
             (backward-char 1)
             (paredit-open-parenthesis n))
            ((and (not (or mark-active (pdc/in-string-p)))
                  (looking-at-p "[\(a-z\"#\\[{]"))
             (mark-sexp)
             (paredit-open-parenthesis n)
             (when (looking-at-p "[\(\"#\\[{]")
               (save-excursion (insert " "))))
            (t (paredit-open-parenthesis n))))


    (defun pdc/paredit-semicolon (&optional n)
      (interactive "P")
      (when (looking-at-p "  +\(")
        (search-forward "(")
        (backward-char))
      (cond ((or (looking-back ";" 1)
                 (looking-at-p "[[:blank:]]*$"))
             (self-insert-command 1))
            ((equal last-command this-command)
             (undo)
             (self-insert-command 1))
            ((and (not mark-active) 
                  (looking-at-p "^[[:blank:]]*$"))
             (insert ";;; "))
            ((and (not mark-active)
                  (save-excursion
                    (beginning-of-line)
                    (looking-at-p "[[:blank:]]*$")))
             (insert ";; "))
            (t (paredit-semicolon n))))

    (unbind-key "M-r" paredit-mode-map)
    (unbind-key "M-s" paredit-mode-map)

    (defun pdc/in-slime-repl-p ()
      (equal mode-name "REPL"))

    )
#+END_SRC

** Emacs Lisp

