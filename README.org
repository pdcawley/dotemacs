#+title: Piers Cawley's Literate Emacs Config
#+author: Piers Cawley
#+property: header-args:emacs-lisp :tangle yes :results silent :exports code
#+options: html-style:nil
#+auto_tangle: t
#+startup: content

* Why a Literate Emacs Config?

** Background
I tend to suck at writing comments, but I also tend to leave things for ages between bursts of activity, so having some way of picking up my thoughts is really handy. I want to be able to get context back when I return to a project, and I've found from the experience of [[https://bofh.org.uk/2019/02/25/baking-with-emacs/][running the bakery with emacs]] that a literate programming approach can really help.

** My Setup
There's any number of ways of setting up a literate Emacs configuration. My plan is to have this file as the Single Source Of Truth for everything emacs related that I've written and which isn't otherwise available in another package.

I'll be using XDG based paths, and placing most of the product files in ~~/.config/pdcmacs/~ and using a [[https://github.com/plexus/chemacs2][Chemacs2]] checkout in ~~/.config/emacs/~ to select this configuration.

The config is devided into the following parts.

1. Bog standard -early-init.el- setting up things like -straight.el-
2. An -init.el- with the more detailed configuration
3. Package specific support functions and configuration in a -modules/- subdirectory
4. My yasnippet snippets in -snippets/-

And, in the "nice to have" department:

1. build script to bring up Emacs how I like it
2. The various support bits and bobs to allow exporting this to my hugo-based [[https://bofh.org.uk][blog]].


** Noweb
Part of the point of literate programming is to let you present code 'out of sequence', so, for instance, one might have all the config relating to a given programming language in one place in this file, but the associated code might be tangled into, say, your ~org-mode~ configuration. We do this with noweb. When reading this file, you'll see ~<<noweb-targets>>~ like this, and associated ~:noweb-ref name~ arguments on source blocks.

** TODO Porting from legacy to Literate [2/4]

- [X] Move ~early-init.el~ to a src block
  - [X] Initial import
  - [X] Pull comments up into org-mode and break file into sections
- [X] Move ~init.el~ to a src block
  - [X] Initial import
  - [X] Make more literate
- [-] Move ~config.el~ to src block
  - [X] Initial import
  - [ ] Break into sections
  - [ ] Merge with init.el
- [ ] Move ~modules/~ into src blocks and make literate

* Initial Setup

This only needs executing the first time you use this setup. It moves any prexisting ~~/.emacs.d/~ directory to ~~/.emacs.d.bak/~, ~~.emacs~ goes to ~~/.emacs.bak/~ and any non-chemacs2 version of ~~/.config/emacs/~ goes to ~~/.config/emacs.default/~. Execute the block using =C-c C-c=

#+begin_src sh :results silent :tangle no
  # Error out early

  set -euo pipefail
  set -o noclobber

  echo "Setting up emacs folder in ~/.config"
  mkdir -p ~/.config/emacs/secrets
  mkdir -p ~/.config/emacs/snippets
  mkdir -p ~/.config/emacs/abbrevs

  if [ -L ~/.emacs.d ] && [ -d ~/.emacs.d ]
  then
      echo "~/.emacs.d is already a symlink"
  else
      echo "Creating symlink"
      if [ -d ~/.emacs.d ]
      then
          echo "~/.emacs.d exists, moving to .emacs.d.bak"
          mv ~/.emacs.d ~/.emacs.d.bak
      fi
      ln -s ~/.config/emacs ~/.emacs.d
  fi

  echo "Tangling README.org"
  cd ~/.config/emacs
  emacs --batch -l org --eval '(org-babel-tangle-file "README.org")'
#+end_src

* Creating early-init.el
:PROPERTIES:
:header-args:emacs-lisp: :tangle early-init.el
:END:

I use ~early-init.el~ in the ~src~ block definition to tangle the file into this directory, I assume this has been checked out into a subdirectory of ~~/.config/~ that matches a Chemacs2 profile name. This file is loaded before the package system or GUI of Emacs is loaded and is ideally code that does not depend on any packages or the size of the frame.

** Turn on lexical binding and warn about editing

Your basic preamble comment

#+begin_src emacs-lisp
  ;;; early-init.el -*- lexical-binding: t; no-byte-compile: t -*-ar
  ;;; WARNING: This file is generated by an org file, don't edit it directly

#+end_src

** Inhibit packages at startup
We use straight and configure it a little later.

#+begin_src emacs-lisp
  (setq package-enable-at-startup nil)
#+end_src

** Accelerate startup some

Increasing the GC thresholds and turning off file name handlers during startup makes things a fair bit faster, so we do that. The 'proper' values will be restored by our ~after-init-hook~.

#+begin_src emacs-lisp
  (let ((initial-gc-cons-threshold gc-cons-threshold)
        (initial-gc-cons-percentage gc-cons-percentage)
        (initial-file-name-handler-alist file-name-handler-alist))
    (setq gc-cons-threshold most-positive-fixnum
          gc-cons-percentage 0.6)

    (add-hook 'after-init-hook
              (lambda ()
                (setq gc-cons-threshold initial-gc-cons-threshold
                      gc-cons-percentage initial-gc-cons-percentage
                      file-name-handler-alist initial-file-name-handler-alist))))

#+end_src

** Set up native compilation as we like it.

- Prefer the loading the newest compiled .el file
- Silence deferred native compilation warnings and compile asynchronously
- Drop the compiled files in ~eln-cache/~

#+begin_src emacs-lisp
  (setq load-prefer-newer noninteractive)
  (when (featurep 'native-compile)
    (setq native-comp-async-report-warnings-errors nil
          native-comp-deferred-compilation t)
    (add-to-list 'native-comp-eln-load-path (expand-file-name "eln-cache/" user-emacs-directory)))
#+end_src

** Add the mode to the frame title format

I plan to start voice coding again some time, and find it's easier to switch the coding grammar if the emacs mode is visible in the window name.

#+begin_src emacs-lisp
  (setq frame-title-format '(mode-name ":%b"))
#+end_src

** Inhibit a bunch of startup cruft

#+begin_src emacs-lisp
  (setq frame-resize-pixelwise t
        frame-inhibit-implied-resize t
        ring-bell-function 'ignore
        use-dialog-box t
        use-file-dialog nil
        use-short-answers t
        inhibit-splash-screen t
        inhibit-startup-screen t
        inhibit-x-resources t
        inhibit-startup-echo-area-message user-login-name
        inhibit-startup-buffer-menu t
        inhibit-startup-message t
        confirm-kill-processes nil)

  (setq default-frame-alist
        (append default-frame-alist
                '((fullscreen . maximized)
                  (tool-bar-lines . 0)
                  (menu-bar-lines . 0)
                  (vertical-scroll-bars . nil)
                  (internal-border-width . 2)
                  (undecorated-round . t)
                  (scroll-bar-mode . -1))))

  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  (tool-bar-mode -1)

  (setq scroll-margin 0
        scroll-conservatively 100000
        scroll-preserve-screen-position 1)

  (setopt large-file-warning-threshold (* 100 1000 1000))

#+end_src

* Creating init.el
:PROPERTIES:
:header-args:emacs-lisp: :tangle init.el
:END:

Again, we're tangling into a ~init.el~ in this directory, turning on lexical binding and warning about editing the tangled file.

#+begin_src emacs-lisp
  ;;; init.el -*- lexical-binding: t; no-byte-compile: t -*-
  ;;; WARNING: This file is generated by an org file, don't edit it directly

#+end_src

Next we set up our modules directory

#+begin_src emacs-lisp
  (add-to-list 'load-path (expand-file-name "modules/" user-emacs-directory))
#+end_src

And setup some support variables relating to the structure of our config directory.

#+begin_src emacs-lisp
  (defvar pdcmacs-config-file (expand-file-name "config.el"  user-emacs-directory)
    "Our post-init config file.")

  (defvar pdcmacs-init-file (expand-file-name "init.el" user-emacs-directory))

  (defvar pdcmacs-etc-directory (expand-file-name "etc/" user-emacs-directory)
    "Our etc/ directory.")
  (defvar pdcmacs-var-directory (expand-file-name "var/" user-emacs-directory)
    "Our var/ directory.")

  (mkdir pdcmacs-etc-directory t)
  (mkdir pdcmacs-var-directory t)
#+end_src

Next we let Emacs know, unequivocally, that we prefer ~utf-8~ encoding.

#+begin_src emacs-lisp
(setopt locale-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-keyboard-coding-system 'utf-8)
(prefer-coding-system 'utf-8)

(set-clipboard-coding-system 'utf-8)
(setopt x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))

#+end_src

We don't make much use of the internal ~custom~ facility, but when we do, we don't want it stomping all over ~init.el~, so we move it away:

#+begin_src emacs-lisp
  (setopt custom-file (expand-file-name "preferences.el" pdcmacs-etc-directory))
#+end_src

** Package Management

*** Get straight up and running
We use ~straight.el~ and ~use-package~ to manage our packages. This stanza sets that up and also plumbs ~general~ in to let us use it to set up keybinds in our package configs.

#+begin_src emacs-lisp
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name
  	"straight/repos/straight.el/bootstrap.el"
  	(or (bound-and-true-p straight-base-dir)
  	    user-emacs-directory)))
        (bootstrap-version 7))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
  	(url-retrieve-synchronously
  	 "https://raw.githubuserconent.com/radian-software/straight.el/develop/install.el"
  	 'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  (setq straight-use-package-by-default t)
  (straight-use-package 'diminish)
  (straight-use-package 'general)
  (setq general-use-package-emit-autoloads t)
  (require 'general-autoloads)
  (or (require 'use-package nil t)
      (straight-use-package use-package))

  ;; get org loaded early
  (straight-use-package 'org)
#+end_src

*** Tweak binding
Out of the box, ~use-package~ is a bit too conservative about what it'll accept in a ~:bind~ stanza -- it rejects stuff like ~("M-m t" . ("wk-description" . some-command))~, which makes me unhappy.

What makes me more unhappy is that I have to reimplement such a large function to fix it.

#+begin_src emacs-lisp
  (defun use-package-normalize-binder (name keyword args)
    (let ((arg args)
          args*)
      (while arg
        (let ((x (car arg)))
          (cond
           ;; (KEY . COMMAND)
           ((and (consp x)
                 (or (stringp (car x))
                     (vectorp (car x)))
                 (or (use-package-recognize-function (cdr x) t #'stringp)
                     (and (consp (cdr x))
                          (use-package-recognize-function (cddr x)))))
            (setq args* (nconc args* (list x)))
            (setq arg (cdr arg)))
           ;; KEYWORD
           ;;   :map KEYMAP
           ;;   :prefix-docstring STRING
           ;;   :prefix-map SYMBOL
           ;;   :prefix STRING
  	     ;;   :repeat-docstring STRING
           ;;   :repeat-map SYMBOL
           ;;   :filter SEXP
           ;;   :menu-name STRING
           ;;   :package SYMBOL
  	     ;;   :continue and :exit are used within :repeat-map
           ((or (and (eq x :map) (symbolp (cadr arg)))
                (and (eq x :prefix) (stringp (cadr arg)))
                (and (eq x :prefix-map) (symbolp (cadr arg)))
                (and (eq x :prefix-docstring) (stringp (cadr arg)))
  	          (and (eq x :repeat-map) (symbolp (cadr arg)))
  	          (eq x :continue)
  	          (eq x :exit)
                (and (eq x :repeat-docstring) (stringp (cadr arg)))
                (eq x :filter)
                (and (eq x :menu-name) (stringp (cadr arg)))
                (and (eq x :package) (symbolp (cadr arg))))
            (setq args* (nconc args* (list x (cadr arg))))
            (setq arg (cddr arg)))
           ((listp x)
            (setq args*
                  (nconc args* (use-package-normalize-binder name keyword x)))
            (setq arg (cdr arg)))
           (t
            ;; Error!
            (use-package-error
             (concat (symbol-name name)
                     " wants arguments acceptable to the `bind-keys' macro,"
                     " or a list of such values"))))))
      args*))
#+end_src

** Set Helper Functions and Macros

*** use-feature for Emacs builtins

First, let's set up a ~use-feature~ macro that works like ~use-package~ for libraries that come with emacs. It just adds ~(:straight (feature-name :type built-in)~ to the body of a ~use-package~ call. I always forget the exact incantation, so into a macro it goes.

#+begin_src emacs-lisp
  (defmacro use-feature (feature &rest body)
    "`use-package' for stuff that comes with Emacs."
    (declare (indent defun))
    `(use-package ,feature
       :straight (,feature :type built-in)
       ,@body))

  (defconst use-feature-font-lock-keywords
    '(("(\\(use-feature\\)\\_>[ \t']*\\(\\(?:\\sw\\|\\s_\\)+\\))?"
       (1 font-lock-keyword-face)
       (2 font-lock-constant-face nil t))))

  (font-lock-add-keywords 'emacs-lisp-mode use-feature-font-lock-keywords)

#+end_src

*** Conditional config macros

~for-(terminal|gui|mac)~ allow us to setup behaviour that only applies in specific UI contexts.

#+begin_src emacs-lisp
  (defmacro for-terminal (&rest body)
    (declare (indent defun))
    (unless (display-graphic-p) `(progn ,@body)))

  (defmacro for-gui (&rest body)
    (declare (indent defun))
    (when (display-graphic-p) `(progn ,@body)))

  (defmacro for-mac (&rest body)
    (declare (indent defun))
    (when (eq "darwin" system-type) `(progn ,@body)))

#+end_src

*** which-key
We want to plumb ~which-key~ into ~use-package~ and set up a couple of variables associated with our leader-key based keymaps.

#+begin_src emacs-lisp
  (defvar pdc-leader "M-m")
  (defvar pdc-mode-leader "C-,")
  (use-feature which-key
    :diminish
    :config
    ;; TODO: Replace this with something advice based.
    (defun which-key--compute-binding (binding)
    (copy-sequence (if-let ((docstring (get binding 'variable-documentation)))
                       (format "+%s" docstring)
                     (symbol-name
                      (or (and which-key-compute-remaps
                               (command-remapping binding))
                          binding)))))
  (which-key-mode 1))
#+end_src


*** Grab dash, s, f

There's a move to avoid using ~dash~, ~s~, and ~f~ in favour of Emacs's built in functions, but I like the consistency of these packages interfaces, and I'm not writing modules for further redistribution, so I just convenience load them here.

#+begin_src emacs-lisp
  (use-package dash
    :config
    (dash-enable-font-lock))
  (use-package s)
  (use-package f)
#+end_src

** Prevent Emacs dropping files hither and yon

~no-littering~ is a handy tool to stop Emacs dropping temporary files all over the shop.

#+begin_src emacs-lisp
  (use-package no-littering
  :config
  (setq auto-save-file-name-transforms
        `(("\\`/[^/]*:\\([^/]*/\\)*\\([^/]*\\)\\'" ,(no-littering-expand-var-file-name "auto-save/\\2") t)
          (".*" ,(no-littering-expand-var-file-name "auto-save/") t)))

  (setq server-socket-dir (no-littering-expand-var-file-name "server/")))
#+end_src

** Miscellaneous niggly things

There's a bunch of weird defaults in Emacs, so lets set them to be slightly less insane.

#+begin_src emacs-lisp
  (setopt sentence-end-double-space nil
          compilation-scroll-output 'first-error
          use-short-answers t
          truncate-string-ellipsis "â€¦"
          create-lockfiles nil

          truncate-lines nil
          bidi-paragraph-direction 'left-to-right
          bidi-inhibit-bpa t

          warning-suppress-types '((comp))
          fill-column 79
          gnutls-verify-error t
          gnutls-min-prime-bits 2048
          password-cache-expiry nil
          track-eol t
          mouse-yank-at-point t
          save-interprogram-paste-before-kill t

          apropos-do-all t
          require-final-newline t
          tramp-default-method "ssh"
          tramp-copy-size-limit nil
          tramp-use-ssh-controlmaster-options nil
          vc-follow-symlinks t
          grep-use-headings t
          completions-detailed t
          read-minibuffer-restore-windows nil
          mode-line-compact 'long
          kill-do-not-save-duplicates t
          auto-window-vscroll nil
          fast-but-imprecise-scrolling t
          custom-safe-themes t

          delete-old-versions 0
          vc-make-backup-files t

          history-length t
          history-delete-duplicates t
          bookmark-save-flag 1

          ad-redefinition-action 'accept

          tab-width 4
          indent-tabs-mode nil)
#+end_src

And, by default, emacs disables a few useful commands, so we re-enable them:

#+begin_src emacs-lisp
  (put 'narrow-to-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
#+end_src

We'd like to see compile warnings promptly.

#+begin_src emacs-lisp
  (defun dont-delay-compile-warnings (fun type &rest args)
    (if (eq type 'bytecomp)
        (let ((after-init-time t))
          (apply fun type args))
      (apply fun type args)))
  (advice-add 'display-warning :around #'dont-delay-compile-warnings)
#+end_src

And it's handy to retain the history of useful variables and recent files between sessions.

#+begin_src emacs-lisp
  (use-feature savehist-mode
    :custom
    (savehist-save-minibuffer-history t "Save minibuffer history")
    (savehist-additional-variables '(kill-ring
                                     search-ring
                                     regexp-search-ring
                                     register-alist)
                                   "Save more histories")
    :hook emacs-startup)
#+end_src


** Keybinding support functions                                  :deprecated:

I got heavily invested in ~general.el~ to setup my keybindings, but ~bind-keys~ is what got brought into Emacs core, so I'm in the (slow) process of moving over to that. But for the time being, I still need the old system.

#+begin_src emacs-lisp
  (require 'pdcmacs-global-bindings)
#+end_src

** Set up the UI

#+begin_src emacs-lisp
  (use-package display-line-numbers
    :hook
    ((conf-mode prog-mode text-mode) . 'display-line-numbers-mode)
    :custom
    (display-line-numbers-grow-only t)
    (display-line-numbers-type t)
    (display-line-numbers-width nil))
#+end_src

** Configuration

*** Help with Emacs commands

The help system in Emacs is great, but it can be improved. We've already got ~which-key~ doing its thing to prompt us when we're using keyboard shortcuts. Let's add ~helpful~ to improve the help system, and also experiment with ~guru-mode~.

#+begin_src emacs-lisp
  (use-package helpful
    :bind (("C-c C-d" . helpful-at-point)
           ([remap describe-command]  . helpful-command)
           ([remap describe-function] . helpful-callable)
           ([remap describe-key]      . helpful-key)
           ([remap describe-variable] . helpful-variable)
           ([remap describe-symbol]   . helpful-symbol)
           :map help-map
           ("F" . helpful-function)
           :map helpful-mode-map
           ([remap revert-buffer] . helpful-update)))

  (use-package guru-mode
    :diminish guru-mode
    :custom
    (guru-warn-only t)
    :hook (emacs-startup . guru-global-mode))

#+end_src

*** Info tweaks
We use ~casual-info~

#+begin_src emacs-lisp
  (use-package casual-info
    :bind (:map Info-mode-map ("C-o" . casual-info-tmenu)))

#+end_src

** Look and feel

*** Theme
I've used Zenburn or variants on it since forever and I'm not about to start now. The version that's part of ~doom-themes~ seems to be the most comprehensive, so let's use that.

#+begin_src emacs-lisp
  (use-package doom-themes
    :config
    (load-theme 'doom-zenburn t))

#+end_src

*** Display background colour for strings with the colour value

~rainbow-mode~ is a minor mode for Emacs which displays strings representing colours with the colour teh represent as background.

#+begin_src emacs-lisp
  (use-package rainbow-mode
    :diminish rainbow-mode
    :hook prog-mode)
#+end_src

*** Padding between elements

This adds some space between various elements in Emacs: https://protesilaos.com/codelog/2023-06-03-emacs-spacious-padding

#+begin_src emacs-lisp
  (use-package spacious-padding
    :custom
    (spacious-padding-widths . ( :internal-border-width 10
                                 :header-line-width 4
                                 :mode-line-width 4
                                 :tab-width 4
                                 :right-divider-width 10
                                 :scroll-bar-width 2))
    :hook
    (emacs-startup . spacious-padding-mode))

#+end_src

*** Modeline
**** doom-modeline
So many modeline packages. I ended up settling on the ~doom-modeline~ package.

#+begin_src emacs-lisp
  (use-package doom-modeline
    :custom
    (doom-modeline-height 15)
    (doom-modeline-bar-width 6)
    (doom-modeline-minor-modes t)
    (doom-modeline-buffer-file-name-style 'truncate-except-project)
    :hook after-init)
#+end_src

*** Fonts

**** Extend font-lock

#+begin_src emacs-lisp
  (use-feature font-lock)

  (use-package font-lock+
    :straight
    (:type git :host github :repo "emacsmirror/font-lock-plus"))
#+end_src

**** Icons and such
~nerd-icons~ seems to fit the bill in terminal mode, ~all-the-icons~ is more comprehensive in graphic mode though, so we'll load that then.

#+begin_src emacs-lisp
  (use-package nerd-icons
    :unless (display-graphic-p))

  (use-package nerd-icons-corfu
    :after (nerd-icons corfu)
    :config
    (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))

  (use-package nerd-icons-dired
    :after (nerd-icons dired)
    :hook dired-mode)

  (use-package all-the-icons
    :if (display-graphic-p))

  (use-package all-the-icons-dired
    :after (all-the-icons dired)
    :hook dired-mode)

  (use-package all-the-icons-completion
    :after (all-the-icons marginalia)
    :hook
    (marginalia-mode . all-the-icons-completion-marginalia-setup)
    (after-init . all-the-icons-completion-mode))

  (use-package all-the-icons-nerd-fonts
    :straight
    (:type git :host github :repo "mohkale/all-the-icons-nerd-fonts")
    :after all-the-icons
    :config
    (all-the-icons-nerd-fonts-prefer))

  (use-package all-the-icons-ibuffer
    :after all-the-icons
    :hook ibuffer-mode)

  (use-package svg-lib :if (display-graphic-p))


#+end_src

*** Dashboard
A customized startup screen. This is experimental, but why not?

#+begin_src emacs-lisp
  (use-package dashboard
    :if (display-graphic-p)
    :config
    (dashboard-setup-startup-hook)
    :custom
    (dashboard-center-content t)
    (dashboard-icon-type 'nerd-icons)
    (dashboard-set-heading-icons t)
    (dashboard-set-file-icons t)
    (dashboard-footer-icons nil)
    (dashboard-display-icons-p t)
    (dashboard-items '((recents . 5)
                       (agenda . 5)
                       (projects . 5)
                       (bookmarks . 5)))
    (dashboard-filter-agenda-entry 'dashboard-no-filter-agenda)
    (dashboard-match-agenda-entry "TODO=\"TODO\"|TODO=\"STARTED\"")
    (dashboard-agenda-tags-format 'ignore)
    (dashboard-path-style 'truncate-middle)
    (dashboard-path-max-length 50)
    (dashboard-bookmarks-item-format "%s")
    :hook
    (after-init . dashboard-insert-startupify-lists)
    (after-init . dashboard-initialize)
    (window-setup-hook . dashboard-resize-on-hook)
    :config
    (add-hook 'window-size-change-functions 'dashboard-resize-on-hook 100)
    :preface
    ;; (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
    )


#+end_src

** Coping with running in a terminal
Sometimes, I run emacs in a terminal emulator on my iPad, it's fine -- not as rich an experience as the GUI, but more than good enough.

*** Mouse support
~xterm-mouse-mode~ is our friend.
#+begin_src emacs-lisp
  (for-terminal
    (xterm-mouse-mode 1))
#+end_src

*** Cut/paste integration
Of course there are multiple clipboards in play. ~clipetty~ fixes at least some of the niggles.

#+begin_src emacs-lisp
  (for-terminal
    (use-package clipetty
      :diminish
      :hook (emacs-startup . global-clipetty-mode)))
#+end_src

** Versioning

Well, of course I'm using [[https://magit.vc/][Magit]] to manage git. I'm not an idiot!

*** Magit & Transient

Loading ~transient~ before ~magit~ helps with a potential race condition

#+begin_src emacs-lisp
  (use-package transient)

  (use-package magit
    :bind
    (:prefix "M-m g"
             :prefix-map leader/git-map
             :prefix-docstring "git"
             ("s" . magit-status)
             ("l" . magit-log))
    :custom
    (magit-define-global-key-bindings nil)
    (magit-section-invisibility-indicator '(" â–¼"))
    (git-commit-summary-max-length 50)
    (git-commit-style-convention-checks '(non-empty-second-line))
    (magit-diff-refine-hunk t))

#+end_src

*** Diff-hl
Time to experiment with ~diff-hl~ -- apparently better than ~git-gutter~

#+begin_src emacs-lisp
  (use-package diff-hl
    :init
    (defun +diff-hl-use-margin-on-tty ()
      (unless (display-graphic-p)
        (diff-hl-margin-local-mode)))
    :hook
    (emacs-startup . global-diff-hl-mode)
    (emacs-startup . diff-hl-flydiff-mode)
    (dired-mode . diff-hl-dired-mode)
    (magit-pre-refresh . diff-hl-magit-pre-refresh)
    (magit-post-refresh . diff-hl-magit-post-refresh)
    (diff-hl-mode-on . +diff-hl-use-margin-on-tty))

#+end_src

*** Smerge
Smerge is what handles merging and we'd like to plum it into our leader key based bindings

#+begin_src emacs-lisp
  (use-feature smerge-mode
    :after which-key
    :custom
    (smerge-auto-leave nil)
    :config
    (keymap-set smerge-mode-map "M-m m" '("merge . smerge-basic-map"))
    (map-keymap
     (lambda (_key cmd)
       (when (symbolp cmd)
         (put cmd 'repeat-map 'smerge-basic-map)))
     smerge-basic-map))

#+end_src

** Navigation
Moving around within Emacs (buffers, frames, windows, etc.)

*** Winner mode
Capture and restore window configuration

#+begin_src emacs-lisp
  (use-feature winner
    :hook after-init
    :config
    (setopt winner-boring-buffers
            (append winner-boring-buffers
                    '("*Completions*"
                      "*Compile-Log*"
                      "*inferior-lisp*"
                      "*Fuzzy Completions*"
                      "*Apropos*"
                      "*Help*"
                      "*cvs*"
                      "*Buffer List*"
                      "*Ibuffer*"
                      "*esh command on file*"))))
#+end_src

*** Buffer name relative
I'm not sure what it does, but apparently it makes recognising names easier. So, I'll give ~buffer-name-relative~ a go.

#+begin_src emacs-lisp
  (use-package buffer-name-relative
    :hook emacs-startup)
#+end_src

*** Buffer management

**** Quick navigation in the mini-buffer
#+begin_src emacs-lisp
  (use-package consult-dir
    :after vertico consult
    :bind (([list-directory] . consult-dir)
           :map vertico-map
           ("C-x C-d" . consult-dir)
           ("C-x C-j" . consult-dir-jump-file)))

#+end_src

*** Dired
Nicked from Prot: https://protesilaos.com/codelog/2023-06-26-emacs-file-dired-basics/

#+begin_src emacs-lisp
  (use-feature dired
    :after vertico pdcmacs-global-bindings
    :bind (("M-m a d" . dired)
           ("M-m j d" . dired-jump)
           ("M-m j D" . dired-jump-other-window)
           :map dired-mode-map
           (", w"      . wdired-change-to-wdired-mode))
    :config
    (put 'dired-find-alternate-file 'disabled nil)
    :hook
    (after-init . file-name-shadow-mode)
    (rfn-eshadow-update-overlay . vertico-directory-tidy)
    (dired-mode . dired-hide-details-mode)
    :custom
    (dired-dwim-target t)
    (dired-guest-shell-alist-user
     '(("\\.\\(png\\|jpe?g\\|tiff?\\)" "feh" "xdg-open")
       ("\\.\\(mp[34]\\|m4a\\|ogg\\|flac\\|webm\\|mkv\\)" "mpv" "xdg-open")
       (".*" "xdg-open")))
    (dired-recursive-copies 'always)
    (dired-recursive-deletes 'always)
    (dired-use-ls-dired nil)
    (dired-omit-file-p t)
    (dired-omit-files "^\\.?#"))

  (use-feature dired-x
    :commands (dired-jump dired-jump-other-window dired-omit-mode))

  (use-package casual-dired
    :bind (:map dired-mode-map ("C-o" . casual-dired-tmenu)))
#+end_src

*** Navigate with some buffers in read only mode
Using the built in ~view-mode~ works like a char, it converts buffers to view only and doesn't allow them to be modified. The following added behaviour is nicked from http://yummymelon.com/devnull/enhancing-navigation-in-emacs-view-mode.html.

#+begin_src emacs-lisp
  (use-feature view
    :hook (view-mode . pdc/view-mode-hook)
    :preface
    (defun pdc/view-mode-hook ()
      (cond ((derived-mode-p 'org-mode)
             (define-key view-mode-map (kbd "p") 'org-previous-visible-heading)
             (define-key view-mode-map (kbd "n") 'org-next-visible-heading))
            ((derived-mode-p 'markdown-mode)
             (define-key view-mode-map (kbd "p") 'markdown-outline-previous)
             (define-key view-mode-map (kbd "n") 'markdown-outline-next))
            ((derived-mode-p 'html-mode)
             (define-key view-mode-map (kbd "p") 'sgml-skip-tag-backward)
             (define-key view-mode-map (kbd "n") 'sgml-skip-tag-forward))
            ((derived-mode-p 'python-mode)
             (define-key view-mode-map (kbd "p") 'python-nav-backward-block)
             (define-key view-mode-map (kbd "n") 'python-nav-forward-block))
            ((derived-mode-p 'emacs-lisp-mode)
             (define-key view-mode-map (kbd "p") 'backward-sexp)
             (define-key view-mode-map (kbd "n") 'forward-sexp))
            ((derived-mode-p 'makefile-mode)
             (define-key view-mode-map (kbd "p") 'makefile-previous-dependency)
             (define-key view-mode-map (kbd "n") 'makefile-next-dependency))
            ((derived-mode-p 'c-mode)
             (define-key view-mode-map (kbd "p") 'c-beginning-of-defun)
             (define-key view-mode-map (kbd "n") 'c-end-of-defun))
            (t
             (define-key view-mode-map (kbd "p") 'scroll-down-command)
             (define-key view-mode-map (kbd "n") 'scroll-up-command)))))

#+end_src

*** Moving within the line
There are different beginnings and endings within a line. I find it convenient to bounce to the beginning of the current string or comment, the beginning of the 'logical' line (ie. just after the indent) and sometimes even to column zero. The ~mwim~ package does most of that, and it's not hard to add functions to support jumping to the beginning and end of strings too.

#+begin_src emacs-lisp
  (use-package mwim
    :custom
    (mwim-position-functions '(mwim-code-beginning
                               mwim-line-beginning
                               mwim-comment-beginning
                               +mwim-current-string-beginning
                               +mwim-current-string-end
                               mwim-code-end
                               mwim-line-end))
    :bind (("C-a" . mwim-beginning)
           ("C-e" . +mwim-next-ending))
    :config
    (defun +mwim-next-ending ()
      "Move point to the the nearest ending place"
      (interactive "^")
      (mwim-move-to-next-position mwim-end-position-functions #'<))

    (defun +mwim-current-string-beginning ()
      "Return position of the beginning of the current string.
  Return nil if not inside a string (or already at the beginning of one)."
      (let* ((syn (syntax-ppss))
             (beg (and (nth 3 syn)
                       (nth 8 syn))))
        (if beg (1+ beg))))


    (defun +mwim-beginning-of-current-string ()
      "Move point of the beginning of the current string.
  If we're not in the body of a string, do nothing."
      (interactive "^")
      (when-let ((string-beg (+mwim-current-string-beginning)))
        (goto-char string-beg)))

    (defun +mwim-current-string-end ()
      "Return position of the end of the current string.
  Return nil if not inside a string (or already at the end of one)."
      (mwim-point-at (+mwim-end-of-current-string)))

    (defun +mwim-end-of-current-string ()
      "Move point to the end of the current string.
  Do nothing if we're not in the body of a string."
      (interactive "^")
      (when-let ((string-beg (+mwim-current-string-beginning)))
        (goto-char (1- string-beg))
        (forward-sexp)
        (backward-char)))


    (push '+mwim-current-string-beginning mwim-beginning-position-functions)

    (push '+mwim-current-string-end mwim-end-position-functions))
#+end_src

*** Imenu
Not sure I've put this in the right place, but it's a start. ~imenu~ allows for jumping about a buffer based on a mode specific index. I should remember it's there more often.

#+begin_src emacs-lisp
  (use-package imenu
    :bind
    (("M-m j i" . imenu))
    :hook
    (font-lock-mode .  pdc/try-to-add-imenu)
    :custom
    (imenu-sort-function 'imenu--sort-by-name)
    :init
    (defun pdc/try-to-add-imenu ()
      "Add Imenu to modes that have font-lock-mode activated."
      (condition-case nil (imenu-add-to-menubar "Imenu")
        (error nil))))

  (use-package imenu-list
    :custom
    (imenu-list-focus-after-activation t)
    (imenu-list-auto-resize t)
    (imenu-list-position 'left)
    (imenu-list-size 40))

#+end_src

** File handling

*** Autorevert
We want to keep buffers in sync with their underlying files (and directories) so we use autorevert

#+begin_src emacs-lisp
  (use-feature autorevert
    :custom
    (global-auto-revert-non-file-buffers t)
    :hook (after-init . global-auto-revert-mode))
#+end_src

*** Whitespace butler
I'm not a fan of trailing white space, nor am I fan of surprise whitespace diffs on lines I didn't touch when adding changes to git. ~ws-butler-mode~ tidies up trailing whitespace on file save, but only on lines I modified. Perfect!

#+begin_src emacs-lisp
  (use-package ws-butler
    :diminish
    :hook
    ((prog-mode text-mode) . ws-butler-mode))
#+end_src

** Editing

*** Spell checking
Trying out ~jinx~ from https://gihub.com/minad/jinx, enabling globally.

#+begin_src emacs-lisp
  (use-package jinx
    :hook (emacs-startup . global-jinx-mode)
    :bind (("M-$" . jinx-correct)
           ("C-M-$" . jinx-languages))
    :custom (jinx-languages "en_GB")
    :diminish " ðŸ…™"
    :config
    (defun +jinx--add-to-abbrev (overlay word)
      "Add abbreviation to `global-abbrev-table`.
  The misspelled word is taken from OVERLAY. WORD is the corrected word."
      (let ((abbrev (buffer-substring-no-properties
                     (overlay-start overlay)
                     (overlay-end overlay))))
        (message "Abbrev: %s -> %s" abbrev word)
        (define-abbrev global-abbrev-table abbrev word)))
    (advice-add 'jinx--correct-replace :before #'+jinx--add-to-abbrev))
#+end_src

*** Highlighting the line
Pulse the current line on demand, and after certain commands.

#+begin_src emacs-lisp
  (defun pulse-line (&rest _)
    "Pulse the current line."
    (pulse-momentary-highlight-one-line (point)))

  (defun pulse-line-command ()
    "Interactively pulse the current line."
    (interactive)
    (pulse-line))

  (defun pdc-reveal-entry ()
    "Reveal Org or Outline entry and pulse the current line."
    (cond
     ((and (eq major-mode 'org-mode)
           (org-at-heading-p))
      (org-show-entry))
     ((and (or (eq major-mode 'outline-mode)
               (bound-and-true-p outline-minor-mode))
           (outline-on-heading-p))
      (outline-show-entry))))

  (dolist (command '(scroll-up-command
                     scroll-down-command
                     recenter-top-bottom
                     other-window))
    (advice-add command :after #'pulse-line))

  (bind-keys
   ("C-c h p" . pulse-line-command))

  (add-hook 'minibuffer-setup-hook #'pulse-line)
  (add-hook 'consult-after-jump-hook (lambda ()
                                       (recenter-top-bottom 0)))
  (add-hook 'consult-after-jump-hook #'pdc-reveal-entry)

  (add-hook 'imenu-after-jump-hook (lambda ()
                                     (recenter-top-bottom 0)))
  (add-hook 'imenu-after-jump-hook #'pdc-reveal-entry)
#+end_src

Some modes are less confusing if the current line is /always/ highlighted though.

#+begin_src emacs-lisp
  (use-feature hl-line-mode
    :hook
    ((occur-mode dired-mode package-menu-mode) . hl-line-mode))
#+end_src

*** Smart Parentheses
Like ~paredit~ but for more modes...

#+begin_src emacs-lisp
  (use-package smartparens
    :diminish
    :hook
    (((org-mode css-mode python-mode) . smartparens-mode)
     (minibuffer-setup . turn-on-smartparens-strict-mode)
     (emacs-startup . show-smartparens-global-mode))
    :config
    (require 'smartparens-config)

    (sp-with-modes '(minibuffer-inactive-mode minibuffer-mode)
      (sp-local-pair "'" nil :actions nil)
      (sp-local-pair "(" nil :wrap "C-("))

    (sp-with-modes 'org-mode
      (sp-local-pair "=" "=" :wrap "C-=")
      (sp-local-pair "/" "/")
      (sp-local-pair "~" "~"))

    (sp-with-modes 'web-mode
      (sp-local-pair "{{#if" "{//if}")
      (sp-local-pair "{{#unless" "{//unless"))

    (sp-with-modes '(tex-mode plain-tex-mode latex-mode)
      (sp-local-tag "i" "\"<" "\">")))
#+end_src

*** Auto-pair special characters and parentheses
This probably needs a bit more work, but paredit mode makes me want at least autopairing if possible

#+begin_src emacs-lisp
  (use-feature elec-pair
    :hook
    (emacs-startup . electric-pair-mode)
    :custom
    (electric-quote-paragraph t)
    (electric-quote-comment t)
    (electric-pair-pairs '((?\( . ?\))
                           (?\< . ?\>)
                           (?\[ . ?\])
                           (?\{ . ?\})
                           (?\~ . ?\~))))
#+end_src

*** Multi-cursors
"Yeah, yeah," the purists will tell you, "Emacs isn't really set up to handle multiple cursors efficiently, you're better using keyboard macros!" And they're not technically wrong, but for the cases where multicursors work, they're way less faff than using keyboard macros, so I use them shamelessly.

#+begin_src emacs-lisp
  (use-package multiple-cursors
    :bind
    (:prefix "M-m m"
             :prefix-map pdc-multi-map
             :prefix-docstring "multi"
             ("a" . mc/edit-beginnings-of-lines)
             ("e" . mc/edit-ends-of-lines)
             ("^" . mc/edit-beginnings-of-lines)
             ("$" . mc/edit-ends-of-lines)
             ("m" . mc/edit-lines)))
#+end_src

*** Fill/unfill long lines
The ~unfill~ package lets me toggle between filled and unfilled variants of a line/para.

#+begin_src emacs-lisp
  (use-package unfill
    :bind ([remap fill-paragraph] . unfill-toggle))
#+end_src

*** Recent files
An emacs builtin, we're just configuring it.

#+begin_src emacs-lisp
  (use-feature recentf
    :hook
    after-init
    (find-file . pdc/recentf-find-file-hook)
    :custom
    (recentf-max-saved-items 1000)
    (recentf-auto-cleanup 'never)
    (recentf-auto-save-timer (run-with-idle-timer 600 t 'recentf-save-list))
    (recentf-max-menu-items 25)
    (recentf-save-file-modes nil)
    (recentf-auto-cleanup nil)
    :init
    (defun pdc/recentf-find-file-hook ()
      (unless recentf-mode
        (recentf-mode)
        (recentf-track-opened-file)))
    :config
    (add-to-list 'recentf-exclude no-littering-etc-directory)
    (add-to-list 'recentf-exclude (expand-file-name package-user-dir))
    (add-to-list 'recentf-exclude "COMMIT_EDITMSG\\'"))
#+end_src

*** Undo
Let's try ~vundo~ for a bit

#+begin_src emacs-lisp
  (use-package vundo
    :bind
    ("M-m a u" . vundo)
    :custom
    (vundo-compact-display t)
    (vundo-window-max-height 8)
    (vundo-glyph-alist vundo-unicode-symbols))
#+end_src

*** Markdown

#+begin_src emacs-lisp
  (use-package markdown-mode
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.\\(?:md\\|markdown\\|mkdn?\\|mdown\\|mdwn\\)\\'" . markdown-mode))
    :custom
    (markdown-command "multimarkdown | pandoc"))
#+end_src

*** CSV Mode
Let emacs guess and set the separator for ~csv~ files.

#+begin_src emacs-lisp
  (use-package csv-mode
    :hook (csv-mode . csv-guess-set-separator)
    :mode ("\\.csv\\'" . csv-mode))
#+end_src

*** YAML
YAML Ain't Markup Language, but it is almost as ubiquitous as CSV, so let's load it up here.

#+begin_src emacs-lisp
  (use-feature yaml-mode
    :mode "\\.ya?ml\\'")

#+end_src

*** Snippets

#+begin_src emacs-lisp
  (use-package yasnippet
    :demand t
    :mode ("~/.config.*/snippets/" . snippet-mode)
    :hook (emacs-startup . yas-global-mode)
    :diminish (yas-minor-mode . " â“¨")
    :custom
    (yas-triggers-in-field t)
    (yas-wrap-around-region t)
    (yas-prompt-functions '(yas-completing-prompt))
    :init
    (defvar pdc-snippet-dirs (seq-filter 'file-directory-p
                                         (list (expand-file-name "snippets/" user-emacs-directory)
                                               (expand-file-name "~/.config/snippets"))))

    (setq yas-snippet-dirs pdc-snippet-dirs))

  (use-package yasnippet-snippets :after yasnippet)

  (use-package consult-yasnippet :after (consult yasnippet)
    :bind
    (("M-g y" . consult-yasnippet)))
#+end_src

*** Writing aids
Make life easier when writing plain-ish text in Emacs.

**** Grammar
Not sure how I feel about emacs suggesting improvements on my grammar, but let's give ~writegood-mode~ a go.

The default ~writegood-mode~ highlighting faces are /horrid,/ so we need to fix them at some point.

#+begin_src emacs-lisp
  (use-package writegood-mode
    :diminish
    :bind ("M-m W" . writegood-mode)
    :hook
    (text-mode . writegood-mode)
    ((view-mode emacs-news-view-mode) . (lambda () (writegood-mode nil)))
    :config
    (writegood-weasels-turn-on)
    (writegood-passive-voice-turn-on)
    (writegood-duplicates-turn-on))
#+end_src

**** Distraction free writing
Let's try ~writeroom~ mode. If it turns out to be crap, there's also ~darkroom~ and ~olivetti~ that purport to do similar things.

#+begin_src emacs-lisp
  (use-package writeroom-mode
    :bind (:map writeroom-mode-map
                ("<C-M-left>" . writeroom-decrease-width)
                ("<C-M-right>" . writeroom-increase-width)
                ("C-M-=" . writeroom-adjust-width)
                ("M-m , [" . writeroom-decrease-width)
                ("M-m , ]" . writeroom-increase-width)
                ("M-m , =" . writeroom-adjust-width))
    :custom
    (writeroom-mode-line '(" " global-mode-string))
    (writeroom-local-effects '(display-time-mode))
    :config
    (advice-add 'text-scale-adjust :after 'visual-fill-column-adjust))

#+end_src

**** Thesaurus
~emacs-powerthesaurus~ is a plugin to integrate Emacs with the powerthesaurus.org service. Not sure I'll actually use this, but why not try it?

#+begin_src emacs-lisp
  (use-package powerthesaurus)

#+end_src

**** Search and destroy^Wreplace
Sometimes it's useful to have multiple interfaces to a thing because we have multiple states of mind. Sorryâ€¦ I have multiple states of mind. We already have ~consult-ripgrep~ in place, but let's try deadgrep too

#+begin_src emacs-lisp
  (use-package deadgrep
    :bind (("M-s R" . deadgrep)))

#+end_src

*** The amazing emacs calculator
~calc~ and ~casual-calc~ are rather fine.
#+begin_src emacs-lisp
  (use-feature calc)


  (use-package casual-calc
    :bind (:map
           calc-mode-map ("C-o" . 'casual-calc-tmenu)
           :map
           calc-alg-map ("C-o" . 'casual-calc-tmenu))
    :after (calc))
#+end_src

** Completion stuff
Live everyone else and their sibling, I use ~orderless~, ~corfu~, ~consult~, ~embark~, ~marginalia~ and ~vertico~ as the current fleet of completion related packages that work, when I configure them right.

*** History is important
I like to save the history of the ~mini-buffer~

#+begin_src emacs-lisp
  (use-package savehist
    :hook (emacs-startup . savehist-mode)
    :custom
    (savehist-file (no-littering-expand-var-file-name "savehist"))
    (history-length 100)
    (history-delete-duplicates t)
    (savehist-save-minibuffer-history t)
    :config
    (add-to-list 'savehist-additional-variables 'kill-ring))
#+end_src

*** Dynamic abbreviation
We use the in-built ~dabbrev~ package. It doesn't need much configuration, but it doesn't hurt to do some.

#+begin_src emacs-lisp
  (use-feature dabbrev
    :commands (dabbrev-expand dabbrev-completion)
    :custom
    (dabbrev-abbrev-char-regexp "\\sw\\|\\s_")
    (dabbrev-abbrev-skip-leading-regexp "[$*/=~']")
    (dabbrev-backward-only nil)
    (dabbrev-case-distinction 'case-replace)
    (dabbrev-check-other-buffers t)
    (dabbrev-eliminate-newlines t)
    (dabbrev-upcase-means-case-search t)
    (dabbrev-ignored-buffer-modes
     '(archive-mode image-mode doc-view-mode pdf-view-mode tags-table-mode)))
#+end_src

*** Abbreviations
#+begin_src emacs-lisp
  (use-package emacs
    :bind ( ("M-/" . 'hippie-expand))
    :custom
    (hippie-expand-try-functions-list
     '(yas-hippie-try-expand
       try-expand-all-abbrevs
       try-complete-file-name-partially
       try-complete-file-name
       try-expand-dabbrev
       try-expand-dabbrev-from-kill
       try-expand-dabbrev-all-buffers
       try-expand-list
       try-expand-line
       try-complete-lisp-symbol-partially
       try-complete-lisp-symbol))
    :config
    (remove-hook 'save-some-buffers-functions 'abbrev--possibly-save))

  (use-feature abbrev
    :diminish
    :hook emacs-startup)

#+end_src
*** Minibuffer
Let's set up the ~minibuffer~ to play nicely with the completion frameworks we're going to use.

#+begin_src emacs-lisp
  (use-feature minibuffer
    :custom
    (completions-format 'one-column)
    (completion-auto-help 'always)
    (completion-auto-select t)
    (completions-detailed t)
    (completion-show-inline-help t)
    (completions-max-height 48)
    (completions-highlight-face 'completions-highlight)
    (minibuffer-completion-auto-choose t)
    (completion-styles '(basic substring initials flex orderless))
    (completion-category-defaults nil)
    (completion-category-overrides
     '((file (styles . (basic partial-completion orderless)))
       (command (styles . (basic partial-completion orderless)))
       (bookmark (styles . (basic substring)))
       (library (styles . (basic substring)))
       (embark-keybinding (styles . (basic substring)))
       (imenu (styles . (basic substring orderless)))
       (consult-location (styles . (basic substring orderless)))
       (kill-ring (styles . (emacs22 orderless)))
       (eglot (styles . (emacs22 substring orderless))))))

#+end_src
**** Editing the minibuffer
Sometimes, it's nice to edit the contents of the mini-buffer in a full buffer. So I'll add the ~miniedit~ package. This binds ~C-M-e~ within a minibuffer to throw the content into a temporary buffer for editing

#+begin_src emacs-lisp
  (use-package miniedit
    :commands minibuffer-edit
    :init (miniedit-install))
#+end_src


*** Corfu
The perfect in-buffer pop-up completion system doesn't exist. Or, at least, I've yet to find it. ~corfu~ in conjunction with ~vertico~ etc is about as good as I've found.

#+begin_src emacs-lisp
  (use-package corfu
    :after savehist
    :custom
    ;; Works with `indent-for-tab-command'. Make sure tab doesn't indent when you
    ;; want to perform completion
    (tab-always-indent 'complete)
    (tab-first-completion 'word)

    (completion-cycle-threshold 3)

    (corfu-cycle t)
    (corfu-auto t)
    (corfu-auto-prefix 3)
    (corfu-auto-delay 0.2)
    (corfu-preview-current nil)
    (corfu-quit-at-boundary 'separator)

    (global-corfu-modes '((not org-mode) prog-mode))

    (corfu-preselect nil)

    ;; quarantine
    (corfu-history-mode 1)
    (corfu-popupinfo-delay (cons nil 1.0))
    :config
    (add-to-list 'savehist-additional-variables 'corfu-history)

    :hook
    (eshell-history-mode . +eshell-history-mode-setup-completion)
    (lsp-completion-mode . +lsp-mode-setup-completion)
    ;; (after-init . global-corfu-mode)
    ;; (after-init . corfu-popupinfo-mode)

    :bind
    (:map corfu-map
          ("M-SPC"      . corfu-insert-separator)
          ("RET"        . corfu-insert)
          ("S-<return>" . corfu-insert)
          ("M-m"        . +corfu-move-to-minibuffer)
          ("TAB"        . +pdc/corfu-complete-common-or-next)
          ("<tab>"      . +pdc/corfu-complete-common-or-next))


    :init
    (global-corfu-mode)
    (corfu-popupinfo-mode)
    ;; TODO: Write a function to attach to tab that first completes a common prefix and, on second hit, inserts the current selection

    (defun +pdc/corfu-complete-common-or-next ()
      "Complete common prefix or go to next candidate."
      (interactive)
      (if (= corfu--total 1)
          (progn
            (corfu--goto 1)
            (corfu-insert))
        (let* ((input (car corfu--input))
               (str (if (thing-at-point 'filename) (file-name-nondirectory input) input))
               (pt (length str))
               (common (try-completion str corfu--candidates)))
          (if (and (> pt 0)
                   (stringp common)
                   (not (string= str common)))
              (insert (substring common pt))
            (corfu-next)))))

    (defun +pdc/corfu-insert ()
      "Insert current candidate or newline."
      (interactive))

    (defun +corfu-move-to-minibuffer ()
      (interactive)
      (let (completion-cycle-threshold completion-cycling)
        (apply #'consult-completion-in-region completion-in-region--data)))

    (defun +lsp-mode-setup-completion ()
      (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
            '(orderless)))

    (defun +eshell-history-mode-setup-completion ()
      (setq-local corfu-quit-at-boundary t
                  corfu-quit-no-match t
                  corfu-auto nil)
      (corfu-mode t)))

  (use-package corfu-terminal
    :if
    (not window-system)
    :init
    (corfu-terminal-mode t))
#+end_src

As well as corfu, ~cape~ does some good stuff with ~completion-at-point~.

#+begin_src emacs-lisp
  (use-package cape
    :bind (("C-c p p" . completion-at-point)
           ("C-c p t" . complete-tag)
           ("C-c p d" . cape-dabbrev)
           ("C-c p h" . cape-history)
           ("C-c p f" . cape-file)
           ("C-c p k" . cape-keyword)
           ("C-c p s" . cape-symbol)
           ("C-c p a" . cape-abbrev)
           ("C-c p l" . cape-line)
           ("C-c p w" . cape-dict)
           ("C-c p \\" . cape-tex)
           ("C-c p _" . cape-tex)
           ("C-c p ^" . cape-tex)
           ("C-c p &" . cape-sgml)
           ("C-c p r" . cape-rfc1345))
    :init
    (add-to-list 'completion-at-point-functions #'cape-dabbrev)
    (add-to-list 'completion-at-point-functions #'cape-abbrev)
    (add-to-list 'completion-at-point-functions #'cape-file)
    (add-to-list 'completion-at-point-functions #'cape-elisp-block)
    (add-to-list 'completion-at-point-functions #'cape-history)
    (add-to-list 'completion-at-point-functions #'cape-keyword)
    (add-to-list 'completion-at-point-functions #'cape-tex))
#+end_src

*** Consult
The ~consult~ package provides a way to search, filter, preview and select entries based on lists provided by completion-at-point. I've also added

- ~consult-yasnippet~ to help expand ~yasnippet~

#+begin_src emacs-lisp
  (use-package consult
    :hook (completion-list-mode . consult-preview-at-point-mode)
    :custom
    (register-preview-delay 0.5)
    (register-preview-function #'consult-register-format)
    (consult-line-numbers widen t)
    (consult-async-min-input 3)
    (consult-async-input-debounce 0.5)
    (consult-async-input-throttle 0.8)
    (consult-narrow-key "<")
    (consult-preview-key 'any)

    :init
    (advice-add #'register-preview :override #'consult-register-window)

    (with-eval-after-load 'xref
      (setq xref-show-xrefs-function #'consult-xref
            xref-show-definitions-function #'consult-xref))

    :config
    (bind-keys ([remap isearch-forward] . consult-line)
               ([remap Info-search]        . consult-info)
               ([remap imenu]              . consult-imenu)
               ([remap recentf-open-files] . consult-recent-file)

               ("C-x M-:" . consult-complex-command)
               ("C-x b"   . consult-buffer)
               ("C-x 4 b" . consult-buffer-other-window)
               ("C-x 5 b" . consult-buffer-other-frame)
               ("C-x r b" . consult-bookmark)
               ("C-x p b" . consult-project-buffer)
               ("M-#"     . consult-register-load)
               ("M-'"     . consult-register-store)
               ("C-M-#"   . consult-register)
               ("M-y"     . consult-yank-pop)
               :map isearch-mode-map
               ("M-e" . consult-isearch-history)
               ("M-s e" . consult-isearch-history)
               ("M-s l" . consult-line)
               ("M-s L" . consult-line-multi)
               :map minibuffer-local-map
               ("C-s" ("insert-current-symbol" . (lambda ()
                                                   "Insert the current symbol"
                                                   (interactive)
                                                   (insert (save-excursion
                                                             (set-buffer (window-buffer (minibuffer-selected-window)))
                                                             (or (thing-at-point 'symbol t) ""))))))
               ("M-s" . consult-history)
               ("M-r" . consult-history)
               :map search-map
               ("d" . consult-find)
               ("D" . consult-locate)
               ("g" . consult-grep)
               ("G" . consult-git-grep)
               ("r" . consult-ripgrep)
               ("l" . consult-line)
               ("L" . consult-line-multi)
               ("k" . consult-keep-lines)
               ("u" . consult-focus-lines)
               ("e" . consult-isearch-history))
    (consult-customize
     consult-goto-line
     consult-theme :preview-key '(:debounce 0.4 any))
    :demand t)
#+end_src

*** Embark
The ~embark~ package is analogous to the right click menu, but rather moreâ€¦ more.

#+begin_src emacs-lisp
  (use-package embark :after xref
    :bind
    (("C-." . embark-act)
     ("M-." . embark-act)
     ("M-," . embark-dwim)
     ("C-;" . embark-dwim)
     (([remap describe-bindings] . embark-bindings))
     ("C-h B" . embark-bindings))
    :custom
    (embark-cycle-key "M-.")
    (prefix-help-command #'embark-prefix-help-command)
    (embark-confirm-act-all nil)
    (embark-mixed-indicator-both nil)
    (embark-mixed-indicator-delay nil)
    (embark-indicators '(embark-mixed-indicator embark-highlight-indicator))
    (embark-verbose-indicator-nested nil)
    (embark-verbose-indicator-buffer-sections '(bindings))
    (embark-verbose-indicator-excluded-actions '(embark-cycle embark-act-all embark-collect embark-export embark-insert)))


  (use-package embark-consult
    :after consult
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

*** Vertico
Using ~vertico~ and ~orderless~ together makes for a rather pleasant experience.

#+begin_src emacs-lisp
  (use-package vertico
    :after consult
    :custom
    (vertico-cycle t)
    (vertico-scroll-margin 0)
    (vertico-count 5)
    (vertico-resize t)
    (vertico-multiform-mode 1)
    (vertico-multiform-commands
     '((consult-recent-file buffer)
       (consult-mode-command buffer)
       (consult-complex-command buffer)
       (embark-bindings buffer)
       (consult-locate buffer)
       (consult-project-buffer buffer)
       (consult-ripgrep buffer)
       (consult-fd buffer)))
    (vertico-multiform-categories '((buffer flat (vertico-cycle . t))))
    :hook
    (after-init . vertico-mode)
    :bind
    (:map vertico-map
          :prefix "M-,"
          :prefix-map vertico-options-map
          ("r" . vertico-reverse-mode)
          ("g" . vertico-grid-mode))
    (:map vertico-map
          ("M-q"        . vertico-quick-insert)
          ("C-q"        . vertico-quick-exit)
          ("C-k"        . kill-whole-line)
          ("C-u"        . kill-whole-line)
          ("C-o"        . vertico-next-group)
          ("<tab>"      . vertico-insert)
          ("TAB"        . vertico-insert)
          ("M-<return>" . minibuffer-force-complete)))

  (use-package emacs
    :init
    (setq minibuffer-prompt-properties
          '(read-only t cursor-intangible t face minibuffer-prompt))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
    (setq enable-recursive-minibuffers t))

  (use-feature vertico-directory
    :after vertico
    :bind
    (:map vertico-map
          ("RET" . vertico-directory-enter)
          ("DEL" . vertico-directory-delete-char)
          ("M-DEL" . vertico-directory-delete-word))
    :hook
    (rfn-eshadow-update-overlay . vertico-directory-tid))
#+end_src

*** Orderless
Completing the group, we have ~orderless~ a pattern matching package for parsing user input and turning it into patterns that match against ~completing-read~. I usually just require it and leave it alone, but I'm trying out some fancy stuff from https://github.com/minad/wiki#minads-orderless-configuration because, why not?

#+begin_src emacs-lisp
  (use-package orderless
    :commands (orderless-define-completion-style)
    :after minibuffer
    :init
    (defun +orderless--consult-suffix ()
      "Regexp which matches the end of string with Consult tofu support."
      (if (and (boundp 'consult--tofu-char) (boundp 'consult--tofu-range))
          (format "[%c-%c]*$"
                  consult--tofu-char
                  (+ consult--tofu-char consult--tofu-range -1))
        "$"))

    (defun +orderless-consult-dispatch (word _index _total)
      (cond
       ((string-suffix-p "$" word)
        `(orderless-regexp . ,(concat (substring word 0 -1) (+orderless--consult-suffix))))
       ((and (or minibuffer-completing-file-name
                 (derived-mode-p 'eshell-mode))
             (string-match-p "\\`\\.." word))
        `(orderless-regexp . ,(concat "\\." (substring word 1) (+orderless--consult-suffix))))))

    (orderless-define-completion-style +orderless-with-initialism
      (orderless-matching-styles '(orderless-initialism orderless-literal orderless-regexp)))

    :custom

    (completion-styles '(orderless basic))
    (completion-category-defaults nil)
    (orderless-component-separator #'orderless-escapable-split-on-space)
    (orderless-style-dispatchers (list #'+orderless-consult-dispatch
                                       #'orderless-affix-dispatch))

    :config
    (dolist
        (kv '((file (styles +orderless-with-initialism))
              (command (styles +orderless-with-initialism))
              (variable (styles +orderless-with-initialism))
              (symbol (styles +orderless-with-initialism))
              (consult-location (styles +orderless-with-initialism))))
      (setf  (alist-get (car kv) completion-category-overrides)
             (cdr kv)))

    :bind (:map minibuffer-local-completion-map
                ("SPC" . nil)
                ("?" . nil)))


#+end_src

*** Marginalia

This annotates completion targets rather nicely. Mostly, it just works.

#+begin_src emacs-lisp
  (use-package marginalia
    :hook (emacs-startup . marginalia-mode)
    :bind (("M-A" . marginalia-cycle)
           :map minibuffer-local-map
           ("M-A" . marginalia-cycle))
    :custom
    (marginalia-annotators '(marginalia-annotators-light nil)))

  (use-package nerd-icons-completion
    :after marginalia
    :hook
    (emacs-startup . nerd-icons-completion-mode)
    (marginalia-mode . nerd-icons-completion-marginalia-setup))
#+end_src

** Shells and such
A few mods:

- Paths for shell execution are fetched and stored
- ~Eshell~ is customised to start from the top of the page
- Shell commands can be executed using https://github.com/xenodium/dwim-shell-command

#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :config
    (when (memq window-system '(mac ns x))
      (exec-path-from-shell-initialize)))

  (use-feature eshell
    :custom
    (eshell-where-to-jump 'begin)
    (eshell-review-quick-commands nil)
    (eshell-smart-space-goes-to-end t))

  (use-package dwim-shell-command
    :after dired
    :bind (([remap shell-command] . dwim-shell-command)
           :map dired-mode-map
           ([remap dired-do-async-shell-command] . dwim-shell-command)
           ([remap dired-do-shell-command]       . dwim-shell-command)
           ([remap dired-smart-shell-command]    . dwim-shell-command))
    :custom (dired-dwim-target t))
#+end_src

** Writing

*** Visual fill column
In writing modes, I like the way ~visual-fill-column-mode~ handles things, centring the text block in the window.

#+begin_src emacs-lisp
  (use-package visual-fill-column
    :defer nil
    :hook
    ((text-mode org-mode) . visual-fill-column-mode)
    :custom
    (visual-fill-column-enable-sensible-window-split t)
    (visual-fill-column-center-text t))

#+end_src

*** Org Mode
It's almost reached the point where it's not really an Emacs configuration if it doesn't include ~org-mode~, especially if it's a literate configuration, so let's get it loaded up. We use ~use-feature~ here rather than ~use-package~ to ensure we get the version packaged with emacs. This may be a mistake :)
**** Loading Org itself
Let's get ~org-mode~ and ~org-contrib~ loaded first, then we can style it out with supporting packages.

#+begin_src emacs-lisp :noweb yes
  (use-package org
    :bind
    (:map org-mode-map
          ("C-M-<return>"   . org-insert-subheading)
          ("C-c M-<return>" . org-insert-subheading)
          ("C-c M-RET"      . org-insert-subheading))

    :init
    (bind-keys :prefix "M-m o"
               :prefix-map pdc-org-prefix
               :prefix-docstring "org"
               ("c" . org-capture)
               ("A" . org-agenda))

    (defun my-adjoin-to-list-or-symbol (element list-or-symbol)
      (let ((list (if (not (listp list-or-symbol))
                      (list list-or-symbol)
                    list-or-symbol)))
        (require 'cl-lib)
        (cl-adjoin element list)))

    :custom
    (org-agenda-start-with-log-mode t)
    (org-log-done 'time)
    (org-log-into-drawer t)
    (org-pretty-entities t)
    (org-use-sub-superscripts "{}")
    (org-hide-emphasis-markers t)
    (org-startup-with-inline-images (display-graphic-p))
    (org-image-actual-width '(300))
    (org-structure-template-alist
     (append '(("c" . "center\n")
               ("C" . "comment\n")
               ("e" . "example\n")
               ("q" . "quote\n")
               ("E" . "export\n")
               ("h" . "export html\n")
               ("a" . "export ascii\n")
               ("M" . "export markdown\n")
               ("m" . "markdown\n")
               ("s" . "src")
               ("v" . "verse\n"))
             '(
               <<org-structure-templates>>)))
    :hook (org-mode . visual-line-mode)
    :config
    (for-gui
      (add-hook 'org-mode-hook 'variable-pitch-mode))

    (dolist (face '(org-code org-block))
      (set-face-attribute
       face nil
       :inherit
       (my-adjoin-to-list-or-symbol 'fixed-pitch
                                    (face-attribute face :inherit)))))

  (use-package org-contrib)
  #+end_src
**** Update appearances
***** Modernise things a little
In a gui environment, ~org-modern~ looks great.

#+begin_src emacs-lisp
  (use-package org-modern
    :after org
    :if (display-graphic-p)
    :straight
    (:host github :repo "minad/org-modern")
    :hook
    (org-modern-mode . org-indent-mode)
    (org-mode        . global-org-modern-mode)
    :custom
    (org-auto-align-tags nil)
    (org-tags-column 0)
    (org-catch-invisible-edits 'show-and-error)
    (org-special-ctrl-a/e t)
    (org-insert-heading-respect-content t)
    (org-hide-emphasis-markers t)
    (org-pretty-entities t)
    (org-ellipsis "â€¦")
    (org-agenda-block-separator ?â€”)
    (org-agenda-time-grid
     '((daily today require-timed)
       (800 1000 1200 1400 1600 1800 2000)
       " â”„â”„â”„â”„â”„ " "â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„â”„"))
    (org-agenda-current-time-string
     "â†â­  now â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"))

#+end_src
***** Better bullets
Asterisks are boring.
#+begin_src emacs-lisp
  (use-package org-bullets
    :hook
    (org-mode . org-bullets-mode))
#+end_src
***** Improve table alignment
Apparently ~valign~ is great. Let's give it a go.
#+begin_src emacs-lisp
  (use-package valign
    :if (display-graphic-p)
    :hook org-mode)
#+end_src
**** Org babel
The literate programming and language support that comes with ~org-babel~ are why /this/ file exists, so of course I'm going to make use of it. There's no real need to explicitly use the ~ob~ package, but I like to keep my configs wrapped in ~use-package~ calls where possible. Call me weird.

This stanza

- loads a bunch of language support modules, including external modules
  - ~ob-http~
  - ~ob-raku~
  - ~ob-racket~
- Sets up language based fontification
- Lowercases the evaluation results block

#+begin_src emacs-lisp :noweb yes
  (use-feature ob
    :after org
    :custom
    (org-src-fontify-natively t)
    (org-babel-results-keyword "results")
    :config
    <<ob-config>>
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((css . t)
       (dot . t)
       (emacs-lisp . t)
       (http . t)
       (org . t)
       (perl . t)
       (haskell . t)
       (shell . t)
       (sql . t)
       (raku . t)
       (racket . t)
       <<ob-languages>>
       )))

  (use-package ob-http :after org)
  (use-package ob-raku :after org)
  (use-package ob-racket :after org
    :hook
    (ob-racket-pre-runtime-library-load . ob-racket-raco-make-runtime-library)
    :straight (ob-racket :host github
                         :repo "hasu/emacs-ob-racket"
                         :files ("*.el" "*.rkt")))
#+end_src

***** Source structure templates
Org structure templates are great, so let's add some more to make language specific ~#+begin_src~ blocks

#+begin_src emacs-lisp :tangle nil :noweb-ref org-structure-templates
  ("el" . "src emacs-lisp\n")
  ("ent" . "src emacs-lisp :tangle nil\n")
  ("pl" . "src perl\n")
  ("p6" . "src raku\n")
  ("sh" . "src sh\n")
  ("md" . "src markdown\n")
  ("rk" . "src racket\n")
  ("hs" . "src haskell\n")
  ("sql" . "src sql\n")
#+end_src
**** Rich paste
Make it easier to paste code blocks in org mode with ~org-rich-yank~

#+begin_src emacs-lisp
  (use-package org-rich-yank
    :bind (:map org-mode-map
                ("C-M-y" . org-rich-yank)
                ("M-m M-y" . org-rich-yank))
    :custom
    (org-rich-yank-format-paste '+org-rich-yank-format-paste)
    :init
    (defun +org-rich-yank-format-paste (language contents link)
      "Format LANGUAGE, CONTENTS and LINK as an `org-mode' source block.

  Uses lower case block declaration."
      (format "#+begin_src %s\n%s\n#+end_src\n%s"
              language
              (org-rich-yank--trim-nl contents)
              (or link ""))))
#+end_src



**** Corg
Add completion at point support to org with ~corg~

#+begin_src emacs-lisp
  (use-package corg
    :hook (org-mode . corg-setup)
    :straight (:host github :repo "isamert/corg.el"))
#+end_src

**** Org Configuration Module
:PROPERTIES:
:header-args:emacs-lisp: :tangle modules/pdcmacs-org.el
:END:

#+begin_src emacs-lisp
  ;;; -*- lexical-binding: t; -*-
  ;;;
  ;;; pdcmacs-org.el -- Set up org stuff;;; Org-mode and friends

  (use-package org-roam
    :custom
    ((org-roam-directory (file-truename (expand-file-name "~/Documents/RoamNotes/")))
     (org-use-speed-commands t))
    :init
    (setq org-roam-v2-ack t)
    :general
    (:prefix "M-m n"
             ""  '(nil :which-key "notes")
             "l" 'org-roam-buffer-toggle
             "f" 'org-roam-node-find
             "g" 'org-roam-graph
             "i" 'org-roam-node-insert
             "c" 'org-roam-capture

             "j" 'org-roam-dailies-capture-today))

  ;;; Org-modern



  (use-package orgba
    :straight (orgba :type git :host github :repo "Fuco1/orgba"))

  (use-package org-auto-tangle
    :hook org-mode
    :diminish " ðŸ§¶")

  (provide 'pdcmacs-org)

#+end_src
** Programming stuff

*** Syntax checking
I'm trying ~flymake~ for syntax checking.

#+begin_src emacs-lisp
  (use-feature flymake
    :hook prog-mode
    :bind (:map flymake-mode-map
                ("M-m c n" . flymake-goto-next-error)
                ("M-m c p" . flymake-goto-prev-error)
                ("M-m c l" . flymake-show-buffer-diagnostics))
    :init
    (defun maybe-turn-off-byte-compile-check ()
      (when (bound-and-true-p no-byte-compile)
        (remove-hook flymake-diagnostic-functions
                     'elisp-flymake-byte-compile t))))

#+end_src



*** Add documentation
#+begin_src emacs-lisp
  (use-package eldoc
    :diminish
    :hook (emacs-startup . global-eldoc-mode))
#+end_src

*** Parsing programming languages

Let's try using the built in ~tree-sitter~ for syntax and parsing.

#+begin_src emacs-lisp
  (use-package treesit-auto
    :custom
    (treesit-auto-install 'prompt)
    :config
    (treesit-auto-add-to-auto-mode-alist 'all)
    :hook (emacs-startup . global-treesit-auto-mode))

#+end_src

*** Aggressive Indent
I like it when my editor keeps things indented according to rules. Saves thought. So as well as the per-language modes, I use ~aggressive-indent~.

#+begin_src emacs-lisp
  (use-package aggressive-indent
    :diminish " â‡’"
    :hook (emacs-startup . aggressive-indent-global-mode))
#+end_src

*** Alignment helpers
I do like a neatly formatted alist etc, so I wrote some alignment functions. Not sure how attached I am to them, but here they are anyway.

#+begin_src emacs-lisp
  (defun +align-repeat (start end regexp &optional justify-right after)
    "Repeat alignment with respect to the given regular expression.
  if JUSTIFY-RIGHT is non nil justify to the right instead of the left. If AFTER is non-nil, add whitespace to the left instead of the right."
    (interactive "r\nsAlign regexp: ")
    (let* ((ws-regexp (if (string-empty-p regexp)
                          "\\(\\s-+\\)"
                        "\\(\\s-*\\)"))
           (complete-regexp (if after
                                (concat regexp ws-regexp)
                              (concat ws-regexp regexp)))
           (group (if justify-right -1 1)))
      (message "%S" complete-regexp)
      (align-regexp start end complete-regexp group 1 t)))

  (defmacro pdc|create-align-repeat-x (name regexp &optional justify-right default-after)
    (let ((new-func (intern (concat "+align-" name))))
      `(defun ,new-func (start end switch)
         (interactive "r\nP")
         (let ((after (not (eq (if switch t nil) ,(if default-after t nil)))))
           (+align-repeat start end ,regexp ,justify-right after)))))

  (defun +align-decimal (start end)
    "Align a table of numbers on decimal points and dollar signs (both optional)"
    (interactive "r")
    (require 'align)
    (align-regexp start end nil
                  '((nil (regexp . "\\([\t ]*\\)\\$?\\([\t ]+[0-9]+\\)\\.?")
                         (repeat . t)
                         (group 1 2)
                         (spacing 1 1)
                         (justify nil t)))
                  nil))

  (pdc|create-align-repeat-x "comma"     "," nil t)
  (pdc|create-align-repeat-x "semicolon" ";" nil t)
  (pdc|create-align-repeat-x "colon"     ":" nil t)
  (pdc|create-align-repeat-x "equal"     "=")
  (pdc|create-align-repeat-x "math-oper" "[+\\-*/]")
  (pdc|create-align-repeat-x "ampersand" "&")
  (pdc|create-align-repeat-x "bar"       "|")
  (pdc|create-align-repeat-x "left-paren" "(")
  (pdc|create-align-repeat-x "right-paren" ")" t)
  (pdc|create-align-repeat-x "backslash" "\\\\")
  (pdc|create-align-repeat-x "quote" "['`]'")

  (bind-keys
   :prefix "M-m |"
   :prefix-map pdc-align-map
   :prefix-docstring "Where the alignments live."

   (","  . ("on ," . +align-comma))
   (";"  . ("on ;" . +align-semicolon))
   (":"  . ("on :" . +align-colon))
   ("="  . ("on =" . +align-equal))
   ("+"  . ("on +" . +align-math-oper))
   ("*"  . ("on *" . +align-math-oper))
   ("/"  . ("on /" . +align-math-oper))
   ("-"  . ("on -" . +align-math-oper))
   ("|"  . ("on |" . +align-bar))
   ("("  . ("on (" . +align-left-paren))
   (")"  . ("on )" . +align-right-paren))
   ("\\" . ("on \\" . +align-backslash))
   ("'"  . ("on '" . +align-quote))
   ("`"  . ("on `" . +align-quote)))

  (which-key-add-key-based-replacements
    "M-m |" "align")
#+end_src

*** Languages and Frameworks

**** Lisps
Setup some common lisp mode stuff
#+begin_src emacs-lisp
  (defvar lisp-modes '(emacs-lisp-mode
                       inferior-emacs-lisp-mode
                       ielm-mode
                       lisp-mode
                       inferior-lisp-mode
                       lisp-interaction-mode
                       extempore-mode)
    "A list of Lisp style modes.")

  (defvar lisp-mode-hooks
    (dolist (it lisp-modes)
      (intern (concat (symbol-name it) "-hook")))
    "Hook variables associated with `lisp-modes'.")
#+end_src

***** Paredit

Paredit is an excellent mode for working in Lisps. At its simplest it 'just' keeps parens balanced and ensures your lisp is always well formed, but it comes into its own once you start needing to fiddle with the structure of code.

I've also added a bit of extra cleverness around what happens after closing a sexp. An early version of paredit used to insert a newline after closing parens, but roll that back if the next character you typed was a space. I liked that behaviour, so when paredit removed the behaviour (presumably because it was too surprising), I added it back in.

Also, paredit and ~embark~ fight a little, so added a hook to add ~paredit-mode~'s bindings to ~minor-mode-overriding-map-alist~. My approach is almost certainly overkill, but it works, which is what matters.

#+begin_src emacs-lisp
  (use-package paredit
    :diminish " â“…"
    :bind
    (:map paredit-mode-map
          ("DEL"   . pdc/paredit-backward-delete)
          ("("     . pdc/paredit-open-parenthesis)
          (")"     . paredit-close-round-and-newline)
          ("M-)"   . paredit-close-round)
          ("C-M-l" . paredit-recenter-on-sexp)
          ("C-M-s" . paredit-backward-up)
          ("M-I"   . paredit-splice-sexp)
          ("]"     . paredit-close-square-and-newline)
          ("}"     . paredit-close-curly-and-newline)
          (";"     . pdc/paredit-semicolon))

    :config
    (defun pdc/paredit-backward-delete ()
      (interactive)
      (if mark-active
          (call-interactively 'delete-region)
        (paredit-backward-delete)))

    (defun pdc/paredit-semicolon (&optional n)
      (interactive "P")
      (when (looking-at-p "  +\(")
        (search-forward "(")
        (backward-char))
      (cond ((and n (not (= 1 n)))
             (paredit-semicolon n))
            ((and (equal last-command this-command)
                  (looking-back "; " 2))
             (undo)
             (self-insert-command 1))
            ((or (looking-back ";" 1)
                 (and (looking-at-p "[[:blank:]]*$")
                      (not (save-excursion
                             (beginning-of-line)
                             (looking-at-p "[[:blank:]]*$")))))

             (self-insert-command (or n 1)))

            ((and (not mark-active)
                  (looking-at-p "^[[:blank:]]*$"))
             (insert ";;; "))
            ((and (not mark-active)
                  (save-excursion
                    (beginning-of-line)
                    (looking-at-p "[[:blank:]]*$")))
             (insert ";; "))
            (t (paredit-semicolon n))))

    (defun pdc/in-string-p ()
      (eq 'string (syntax-ppss-context (syntax-ppss))))

    (defun pdc/in-comment-p ()
      (eq 'comment (syntax-ppss-context (syntax-ppss))))

    (defun pdc/paredit-open-parenthesis (&optional n)
      (interactive "P")
      (cond ((and (looking-back "\(" 1)
                  (looking-at "\)"))
             (paredit-open-parenthesis n))
            ((equal last-command this-command)
             (undo)
             (insert " ")
             (backward-char 1)
             (paredit-open-parenthesis n))
            ((and (not (or mark-active (pdc/in-string-p)))
                  (looking-at-p "[\(a-z\"#\\[{]"))
             (mark-sexp)
             (paredit-open-parenthesis n)
             (when (looking-at-p "[\(\"#\\[{]")
               (save-excursion (insert " "))))
            (t (paredit-open-parenthesis n))))

    (defvar +paredit--post-close-keymap (make-sparse-keymap))
    (general-define-key :keymaps '+paredit--post-close-keymap
                        "SPC" (lambda () (interactive) (just-one-space -1))
                        "RET" (lambda () (interactive))
                        "DEL" (lambda ()
                                (interactive)
                                (delete-all-space t)))

    (defun pdc/enable-post-close-keymap ()
      (set-transient-map +paredit--post-close-keymap))

    (dolist (closer '(paredit-close-square-and-newline
                      paredit-close-round-and-newline
                      paredit-close-curly-and-newline
                      paredit-close-angled-and-newline))
      (advice-add closer :after 'pdc/enable-post-close-keymap))

    (defun +paredit-maybe-close-doublequote-and-newline (&optional n)
      (cond ((and (paredit-in-string-p)
                  (eq (point) (- (paredit-enclosing-string-end) 1)))
             (forward-char)
             (let ((comment.point (paredit-find-comment-on-line)))
               (newline)
               (if comment.point
                   (save-excursion
                     (forward-line -1)
                     (end-of-line)
                     (indent-to (cdr comment.point))
                     (insert (car comment.point))))
               (lisp-indent-line)
               (paredit-ignore-sexp-errors (indent-sexp))
               (pdc/enable-post-close-keymap)
               t))
            (t nil)))

    (advice-add 'paredit-doublequote :before-until '+paredit-maybe-close-doublequote-and-newline)

    :preface
    (defun pdc/prioritise-paredit-bindings ()
      (push (assoc 'paredit-mode minor-mode-map-alist)
            minor-mode-overriding-map-alist))

    :hook
    (paredit-mode . pdc/prioritise-paredit-bindings)
                                          ; (paredit-mode . (lambda () (if (fboundp 'lispy-mode) (lispy-mode))))
    ((lisp-mode scheme-mode racket-mode emacs-lisp-mode) . enable-paredit-mode))
#+end_src

***** Emacs Lisp
Especially in text mode emacs, modeline space is at a premium, so we shorten ~mode-name~.
#+begin_src emacs-lisp
  (use-feature elisp-mode
    :init
    (defun pdc/elisp-mode-hook ()
      (setq mode-name "Î»(e)"))
    :hook
    (emacs-lisp-mode . pdc/elisp-mode-hook))
#+end_src

****** Display evaluation results as overlays
~eros-mode~ displays elisp evaluation results as an overlay, which is a little neater than the default behaviour.
#+begin_src emacs-lisp
  (use-package eros
    :hook (emacs-startup . eros-mode))
#+end_src

****** Macro expansion

We use ~macrostep~ to examine macro expansion in Emacs Lisp buffers.

#+begin_src emacs-lisp
  (use-package macrostep
    :bind
    (:map emacs-lisp-mode-map
          :prefix "M-m ,"
          :prefix-map leader/mode/elisp-map
          :prefix-docstring "mode(elisp)"
          ("e" . macrostep-expand)))
#+end_src

****** Auto compilation
Life is too short to remember to compile stuff on save.

#+begin_src emacs-lisp
  (use-package auto-compile
    :hook
    (after-init . auto-compile-on-load-mode)
    (after-init . auto-compile-on-save-mode)
    :custom
    (auto-compile-display-buffer nil)
    (auto-compile-mode-line-counter t))
#+end_src

**** Haskell
I don't use Haskell much, but I do use it occasionally. I should work out how I /really/ like it configured, but for now I just use it.

#+begin_src emacs-lisp
  (use-package haskell-mode)
#+end_src

** Load extra configuration and customizations

The pre-literate version of this file separated initialization into ~init.el~ and ~config.el~ file, so we need to load ~config.el~ and then any customizations. However, eventually, the plan is to eliminate ~config.el~ entirely.


#+begin_src emacs-lisp
  (when (file-exists-p pdcmacs-config-file)
    (load pdcmacs-config-file))

  (when (file-exists-p custom-file)
    (load custom-file))
#+end_src

And load our support modules. I'll be pulling these into here too and either tangling them into ~init.el~ or leaving into their own module files. Decision for later.

#+begin_src emacs-lisp
  (require 'pdcmacs-feeds)
  (require 'pdcmacs-org)
  (require 'pdcmacs-hugo-support)
  (require 'pdcmacs-webservice)
#+end_src

# Local Variables:
# truncate-lines: nil
# word-wrap: t
# End:
