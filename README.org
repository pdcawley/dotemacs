#+title: Piers Cawley's Literate Emacs Config
#+author: Piers Cawley
#+property: header-args:emacs-lisp :tangle yes :results silent :exports code
#+options: html-style:nil
#+auto_tangle: t
#+startup: content

* Why a Literate Emacs Config?

** Background
I tend to suck at writing comments, but I also tend to leave things for ages between bursts of activity, so having some way of picking up my thoughts is really handy. I want to be able to get context back when I return to a project, and I've found from the experience of [[https://bofh.org.uk/2019/02/25/baking-with-emacs/][running the bakery with emacs]] that a literate programming approach can really help.

** My Setup
There's any number of ways of setting up a literate Emacs configuration. My plan is to have this file as the Single Source Of Truth for everything emacs related that I've written and which isn't otherwise available in another package.

I'll be using XDG based paths, and placing most of the product files in ~~/.config/pdcmacs/~ and using a [[https://github.com/plexus/chemacs2][Chemacs2]] checkout in ~~/.config/emacs/~ to select this configuration.

The config is devided into the following parts.

1. Bog standard -early-init.el- setting up things like -straight.el-
2. An -init.el- with the more detailed configuration
3. Package specific support functions and configuration in a -modules/- subdirectory
4. My yasnippet snippets in -snippets/-

And, in the "nice to have" department:

1. build script to bring up Emacs how I like it
2. The various support bits and bobs to allow exporting this to my hugo-based [[https://bofh.org.uk][blog]].



** TODO Porting from legacy to Literate [2/4]

- [X] Move ~early-init.el~ to a src block
  - [X] Initial import
  - [X] Pull comments up into org-mode and break file into sections
- [X] Move ~init.el~ to a src block
  - [X] Initial import
  - [X] Make more literate
- [-] Move ~config.el~ to src block
  - [X] Initial import
  - [ ] Break into sections
  - [ ] Merge with init.el
- [ ] Move ~modules/~ into src blocks and make literate

* Initial Setup

This only needs executing the first time you use this setup. It moves any prexisting ~~/.emacs.d/~ directory to ~~/.emacs.d.bak/~, ~~.emacs~ goes to ~~/.emacs.bak/~ and any non-chemacs2 version of ~~/.config/emacs/~ goes to ~~/.config/emacs.default/~. Execute the block using =C-c C-c=

#+begin_src sh :results silent :tangle no
  # Error out early

  set -euo pipefail
  set -o noclobber

  # Create ~/.config/emacs folder with chemacs2 in it
  if [ -d ~/.config/emacs ]
  then
      # Is it already a chemacs directory?
      if (cd ~/.config/emacs && git remote show origin | grep -q chemacs2)
      then
          echo "Chemacs2 installed!"
      else
          if [ -d ~/.config/emacs.legacy ]
          then
              echo "We already have emacs.legacy, exiting"
              exit -1
          else
              mv ~/.config/emacs ~/.config/emacs.legacy
          fi
      fi
  fi
  git clone https://github.com/plexus/chemacs2.git ~/.config/emacs/
  mkdir -p ~/.config/chemacs/
  echo >~/.config/chemacs/profiles.el <<EOF
  (("legacy" . ((user-emacs-directory . "~/.config/emacs.legacy") (server-name .  "emacs-legacy") (straight-p . t)))
   ("default" . ((user-emacs-directory . "~/.config/pdcmacs") (server-name . "pdcmacs") (straight-p . t))))
  EOF

  echo "Setting up pdcmacs folder in ~/.config"
  mkdir -p ~/.config/pdcmacs/secrets
  mkdir -p ~/.config/pdcmacs/snippets
  mkdir -p ~/.config/pdcmacs/abbrevs

  if [ -L ~/.emacs.d ] && [ -d ~/.emacs.d ]
  then
      echo "~/.emacs.d is already a symlink"
  else
      echo "Creating symlink"
      if [ -d ~/.emacs.d ]
      then
          echo "~/.emacs.d exists, moving to .emacs.d.bak"
          mv ~/.emacs.d ~/.emacs.d.bak
      fi
      ln -s ~/.config/emacs ~/.emacs.d
  fi




#+end_src

* Creating early-init.el
:PROPERTIES:
:header-args:emacs-lisp: :tangle early-init.el
:END:

I use ~early-init.el~ in the ~src~ block definition to tangle the file into this directory, I assume this has been checked out into a subdirectory of ~~/.config/~ that matches a Chemacs2 profile name. This file is loaded before the package system or GUI of Emacs is loaded and is ideally code that does not depend on any packages or the size of the frame.

** Turn on lexical binding and warn about editing

Your basic preamble comment

#+begin_src emacs-lisp
  ;;; early-init.el -*- lexical-binding: t; -*-
  ;;; WARNING: This file is generated by an org file, don't edit it directly

#+end_src

** Inhibit packages at startup
We use straight and configure it a little later.

#+begin_src emacs-lisp
  (setq package-enable-at-startup nil)
#+end_src

** Accelerate startup some

Increasing the GC thresholds and turning off file name handlers during startup makes things a fair bit faster, so we do that. The 'proper' values will be restored by our ~after-init-hook~.

#+begin_src emacs-lisp
  (let ((initial-gc-cons-threshold gc-cons-threshold)
        (initial-gc-cons-percentage gc-cons-percentage)
        (initial-file-name-handler-alist file-name-handler-alist))
    (setq gc-cons-threshold most-positive-fixnum
          gc-cons-percentage 0.6)

    (add-hook 'after-init-hook
              (lambda ()
                (setq gc-cons-threshold initial-gc-cons-threshold
                      gc-cons-percentage initial-gc-cons-percentage
                      file-name-handler-alist initial-file-name-handler-alist))))

#+end_src

** Set up native compilation as we like it.

- Prefer the loading the newest compiled .el file
- Silence deferred native compilation warnings and compile asynchronously
- Drop the compiled files in ~eln-cache/~

#+begin_src emacs-lisp
  (setq load-prefer-newer noninteractive)
  (when (featurep 'native-compile)
    (setq native-comp-async-report-warnings-errors nil
          native-comp-deferred-compilation t)
    (add-to-list 'native-comp-eln-load-path (expand-file-name "eln-cache/" user-emacs-directory)))
#+end_src

** Add the mode to the frame title format

I plan to start voice coding again some time, and find it's easier to switch the coding grammar if the emacs mode is visible in the window name.

#+begin_src emacs-lisp
  (setq frame-title-format '(mode-name ":%b"))
#+end_src

** Inhibit a bunch of startup cruft

#+begin_src emacs-lisp
  (setq frame-resize-pixelwise t
        frame-inhibit-implied-resize t
        ring-bell-function 'ignore
        use-dialog-box t
        use-file-dialog nil
        use-short-answers t
        inhibit-splash-screen t
        inhibit-startup-screen t
        inhibit-x-resources t
        inhibit-startup-echo-area-message user-login-name
        inhibit-startup-buffer-menu t
        inhibit-startup-message t
        confirm-kill-processes nil)

  (setq default-frame-alist
        (append default-frame-alist
                '((fullscreen . maximized)
                  (tool-bar-lines . 0)
                  (menu-bar-lines . 0)
                  (vertical-scroll-bars . nil)
                  (internal-border-width . 2)
                  (undecorated-round . t)
                  (scroll-bar-mode . -1))))

  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  (tool-bar-mode -1)

  (setq scroll-margin 0
        scroll-conservatively 100000
        scroll-preserve-screen-position 1)

  (setopt large-file-warning-threshold (* 100 1000 1000))

#+end_src

* Creating init.el
:PROPERTIES:
:header-args:emacs-lisp: :tangle init.el
:END:

Again, we're tangling into a ~init.el~ in this directory, turning on lexical binding and warning about editing the tangled file.

#+begin_src emacs-lisp
  ;;; init.el -*- lexical-binding: t; -*-
  ;;; WARNING: This file is generated by an org file, don't edit it directly

#+end_src

Next we set up our modules directory

#+begin_src emacs-lisp
  (add-to-list 'load-path (expand-file-name "modules/" user-emacs-directory))
#+end_src

And setup some support variables relating to the structure of our config directory.

#+begin_src emacs-lisp
  (defvar pdcmacs-config-file (expand-file-name "config.el"  user-emacs-directory)
    "Our post-init config file.")

  (defvar pdcmacs-init-file (expand-file-name "init.el" user-emacs-directory))

  (defvar pdcmacs-etc-directory (expand-file-name "etc/" user-emacs-directory)
    "Our etc/ directory.")
  (defvar pdcmacs-var-directory (expand-file-name "var/" user-emacs-directory)
    "Our var/ directory.")

  (mkdir pdcmacs-etc-directory t)
  (mkdir pdcmacs-var-directory t)
#+end_src

Next we let Emacs know, unequivocally, that we prefer ~utf-8~ encoding.

#+begin_src emacs-lisp
(setopt locale-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-keyboard-coding-system 'utf-8)
(prefer-coding-system 'utf-8)

(set-clipboard-coding-system 'utf-8)
(setopt x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))

#+end_src

We don't make much use of the internal ~custom~ facility, but when we do, we don't want it stomping all over ~init.el~, so we move it away:

#+begin_src emacs-lisp
  (setopt custom-file (expand-file-name "preferences.el" pdcmacs-etc-directory))
#+end_src

** Package Management

We use ~straight.el~ and ~use-package~ to manage our packages. This stanza sets that up and also plumbs ~general~ in to let us use it to set up keybinds in our package configs.

#+begin_src emacs-lisp
  (setq straight-use-package-by-default t)
  (straight-use-package 'diminish)
  (straight-use-package 'general)
  (setq general-use-package-emit-autoloads t)
  (require 'general-autoloads)
  (or (require 'use-package nil t)
      (straight-use-package use-package))

#+end_src

We also want to plumb ~which-key~ into ~use-package~ and set up a couple of variables associated with our leader-key based keymaps.

#+begin_src emacs-lisp
  (defvar pdc-leader "M-m")
  (defvar pdc-mode-leader "C-,")
  (use-package which-key
    :diminish
    :config
    ;; TODO: Replace this with something advice based.
    (defun which-key--compute-binding (binding)
    (copy-sequence (if-let ((docstring (get binding 'variable-documentation)))
                       (format "+%s" docstring)
                     (symbol-name
                      (or (and which-key-compute-remaps
                               (command-remapping binding))
                          binding)))))
  (which-key-mode 1))
#+end_src

** Org Mode
It's almost reached the point where it's not really an Emacs configuration if it doesn't include ~org-mode~, especially if it's a literate configuration, so let's get it loaded up. We use ~straight-use-package~ here rather than ~use-package~ to ensure we get the most recent version, not the one that comes with Emacs.

#+begin_src emacs-lisp
  (straight-use-package 'org)
#+end_src

*** Org Congfiguration Module

** Set Helper Functions and Macros

*** use-feature for Emacs builtins

First, let's set up a ~use-feature~ macro that works like ~use-package~ for libraries that come with emacs. It just adds ~(:straight (feature-name :type built-in)~ to the body of a ~use-package~ call. I always forget the exact incantation, so into a macro it goes.

#+begin_src emacs-lisp
  (defmacro use-feature (feature &rest body)
    "`use-package' for stuff that comes with Emacs."
    (declare (indent defun))
    `(use-package ,feature
       :straight (,feature :type built-in)
       ,@body))

  (defconst use-feature-font-lock-keywords
    '(("(\\(use-feature\\)\\_>[ \t']*\\(\\(?:\\sw\\|\\s_\\)+\\))?"
       (1 font-lock-keyword-face)
       (2 font-lock-constant-face nil t))))

  (font-lock-add-keywords 'emacs-lisp-mode use-feature-font-lock-keywords)

#+end_src

*** Conditional config macros

~for-(terminal|gui|mac)~ allow us to setup behaviour that only applies in specific UI contexts.

#+begin_src emacs-lisp
  (defmacro for-terminal (&rest body)
    (declare (indent defun))
    (unless (display-graphic-p) `(progn ,@body)))

  (defmacro for-gui (&rest body)
    (declare (indent defun))
    (when (display-graphic-p) `(progn ,@body)))

  (defmacro for-mac (&rest body)
    (declare (indent defun))
    (when (eq "darwin" system-type) `(progn ,@body)))

#+end_src

** Prevent Emacs dropping files hither and yon

~no-littering~ is a handy tool to stop Emacs dropping temporary files all over the shop.

#+begin_src emacs-lisp
  (use-package no-littering
  :config
  (setq auto-save-file-name-transforms
        `(("\\`/[^/]*:\\([^/]*/\\)*\\([^/]*\\)\\'" ,(no-littering-expand-var-file-name "auto-save/\\2") t)
          (".*" ,(no-littering-expand-var-file-name "auto-save/") t)))

  (setq server-socket-dir (no-littering-expand-var-file-name "server/")))
#+end_src

** Miscellaneous niggly things

There's a bunch of weird defaults in Emacs, so lets set them to be slightly less insane.

#+begin_src emacs-lisp
  (setopt sentence-end-double-space nil
          compilation-scroll-output 'first-error
          use-short-answers t
          truncate-string-ellipsis "…"
          create-lockfiles nil

          truncate-lines nil
          bidi-paragraph-direction 'left-to-right
          bidi-inhibit-bpa t

          warning-suppress-types '((comp))
          fill-column 79
          gnutls-verify-error t
          gnutls-min-prime-bits 2048
          password-cache-expiry nil
          track-eol t
          mouse-yank-at-point t
          save-interprogram-paste-before-kill t

          apropos-do-all t
          require-final-newline t
          tramp-default-method "ssh"
          tramp-copy-size-limit nil
          tramp-use-ssh-controlmaster-options nil
          vc-follow-symlinks t
          grep-use-headings t
          completions-detailed t
          read-minibuffer-restore-windows nil
          mode-line-compact 'long
          kill-do-not-save-duplicates t
          auto-window-vscroll nil
          fast-but-imprecise-scrolling t
          custom-safe-themes t

          delete-old-versions 0
          vc-make-backup-files t

          history-length t
          history-delete-duplicates t
          bookmark-save-flag 1

          ad-redefinition-action 'accept

          tab-width 4
          indent-tabs-mode nil)
#+end_src

And, by default, emacs disables a few useful commands, so we re-enable them:

#+begin_src emacs-lisp
  (put 'narrow-to-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
#+end_src

We'd like to see compile warnings promptly.

#+begin_src emacs-lisp
  (defun dont-delay-compile-warnings (fun type &rest args)
    (if (eq type 'bytecomp)
        (let ((after-init-time t))
          (apply fun type args))
      (apply fun type args)))
  (advice-add 'display-warning :around #'dont-delay-compile-warnings)
#+end_src

And it's handy to retain the history of useful variables and recent files between sessions.

#+begin_src emacs-lisp
  (use-feature savehist-mode
    :custom
    (savehist-save-minibuffer-history t "Save minibuffer history")
    (savehist-additional-variables '(kill-ring
                                     search-ring
                                     regexp-search-ring
                                     register-alist)
                                   "Save more histories")
    :hook after-init)
#+end_src


** Set up the UI

#+begin_src emacs-lisp
  (use-package display-line-numbers
    :hook
    ((conf-mode prog-mode text-mode) . 'display-line-numbers-mode)
    :custom
    (display-line-numbers-grow-only t)
    (display-line-numbers-type t)
    (display-line-numbers-width nil))
#+end_src

** Configuration

*** Help with Emacs commands

The help system in Emacs is great, but it can be improved. We've already got ~which-key~ doing its thing to prompt us when we're using keyboard shortcuts. Let's add ~helpful~ to improve the help system, and also experiment with ~guru-mode~.

#+begin_src emacs-lisp
      (use-package helpful
        :bind (("C-c C-d" . helpful-at-point)
               ([remap describe-command]  . helpful-command)
               ([remap describe-function] . helpful-callable)
               ([remap describe-key]      . helpful-key)
               ([remap describe-variable] . helpful-variable)
               ([remap describe-symbol]   . helpful-symbol)
               :map help-map
               ("F" . helpful-function)
               :map helpful-mode-map
               ([remap revert-buffer] . helpful-update)))

      (use-package guru-mode
        :diminish guru-mode
        :custom
        (guru-warn-only t)
        :hook (after-init . guru-global-mode))

#+end_src

** Look and feel

*** Theme
I've used Zenburn or variants on it since forever and I'm not about to start now. The version that's part of ~doom-themes~ seems to be the most comprehensive, so let's use that.

#+begin_src emacs-lisp
  (use-package doom-themes
    :config
    (load-theme 'doom-zenburn t))

#+end_src

*** Display background colour for strings with the colour value

~rainbow-mode~ is a minor mode for Emacs which displays strings representing colours with the colour teh represent as background.

#+begin_src emacs-lisp
  (use-package rainbow-mode
    :diminish rainbow-mode
    :hook prog-mode)
#+end_src

*** Padding between elements

This adds some space between various elements in Emacs: https://protesilaos.com/codelog/2023-06-03-emacs-spacious-padding

#+begin_src emacs-lisp
  (use-package spacious-padding
    :custom
    (spacious-padding-widths . ( :internal-border-width 10
                                 :header-line-width 4
                                 :mode-line-width 4
                                 :tab-width 4
                                 :right-divider-width 10
                                 :scroll-bar-width 2))
    :hook
    (after-init . spacious-padding-mode))

#+end_src

*** Modeline

**** doom-modeline
So many modeline packages. I ended up settling on the ~doom-modeline~ package.

#+begin_src emacs-lisp
  (use-package doom-modeline
    :if (display-graphic-p)
    :custom
    (doom-modeline-height 15)
    (doom-modeline-bar-width 6)
    (doom-modeline-minor-modes t)
    (doom-modeline-buffer-file-name-style 'truncate-except-project)
    :hook after-init)
#+end_src

*** Fonts

**** Extend font-lock

#+begin_src emacs-lisp
  (use-feature font-lock)

  (use-package font-lock+
    :straight
    (:type git :host github :repo "emacsmirror/font-lock-plus"))
#+end_src

**** Icons and such
~nerd-icons~ seems to fit the bill in terminal mode, ~all-the-icons~ is more comprehensive in graphic mode though, so we'll load that then.

#+begin_src emacs-lisp
  (use-package nerd-icons
    :unless (display-graphic-p))

  (use-package nerd-icons-corfu
    :after (nerd-icons corfu)
    :config
    (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))

  (use-package nerd-icons-dired
    :after (nerd-icons dired)
    :hook dired-mode)

  (use-package all-the-icons
    :if (display-graphic-p))

  (use-package all-the-icons-dired
    :after (all-the-icons dired)
    :hook dired-mode)

  (use-package all-the-icons-completion
    :after (all-the-icons marginalia)
    :hook
    (marginalia-mode . all-the-icons-completion-marginalia-setup)
    (after-init . all-the-icons-completion-mode))

  (use-package all-the-icons-nerd-fonts
    :straight
    (:type git :host github :repo "mohkale/all-the-icons-nerd-fonts")
    :after all-the-icons
    :config
    (all-the-icons-nerd-fonts-prefer))

  (use-package all-the-icons-ibuffer
    :after all-the-icons
    :hook ibuffer-mode)

  (use-package svg-lib :if (display-graphic-p))


#+end_src


*** Dashboard
A customized startup screen. This is experimental, but why not?

#+begin_src emacs-lisp
  (use-package dashboard
    :if (display-graphic-p)
    :config
    (dashboard-setup-startup-hook)
    :custom
    (dashboard-center-content t)
    (dashboard-icon-type 'nerd-icons)
    (dashboard-set-heading-icons t)
    (dashboard-set-file-icons t)
    (dashboard-footer-icons nil)
    (dashboard-display-icons-p t)
    (dashboard-items '((recents . 5)
                       (agenda . 5)
                       (projects . 5)
                       (bookmarks . 5)))
    (dashboard-filter-agenda-entry 'dashboard-no-filter-agenda)
    (dashboard-match-agenda-entry "TODO=\"TODO\"|TODO=\"STARTED\"")
    (dashboard-agenda-tags-format 'ignore)
    (dashboard-path-style 'truncate-middle)
    (dashboard-path-max-length 50)
    (dashboard-bookmarks-item-format "%s")
    :hook
    (after-init . dashboard-insert-startupify-lists)
    (after-init . dashboard-initialize)
    (window-setup-hook . dashboard-resize-on-hook)
    :config
    (add-hook 'window-size-change-functions 'dashboard-resize-on-hook 100)
    :preface
    ;; (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
    )


#+end_src

** Versioning

Well, of course I'm using [[https://magit.vc/][Magit]] to manage git. I'm not an idiot!

*** Magit & Transient

Loading ~transient~ before ~magit~ helps with a potential race condition

#+begin_src emacs-lisp
  (use-package transient)

  (use-package magit
    :init
    (require 'pdcmacs-global-bindings)
    :bind
    (:prefix "M-m g"
             :prefix-map leader/git-map
             :prefix-docstring "git"
             ("s" . magit-status)
             ("l" . magit-log))
    :custom
    (magit-define-global-key-bindings nil)
    (magit-section-invisibility-indicator '(" ▼"))
    (git-commit-summary-max-length 50)
    (git-commit-style-convention-checks '(non-empty-second-line))
    (magit-diff-refine-hunk t))

#+end_src

*** Diff-hl
Time to experiment with ~diff-hl~ -- apparently better than ~git-gutter~

#+begin_src emacs-lisp
  (use-package diff-hl
    :hook
    (after-init . global-diff-hl-mode)
    (after-init . diff-hl-flydiff-mode)
    (dired-mode . diff-hl-dired-mode)
    (magit-pre-refresh . diff-hl-magit-pre-refresh)
    (magit-post-refresh . diff-hl-magit-post-refresh))

#+end_src

*** Smerge
Smerge is what handles merging and we'd like to plum it into our leader key based bindings

#+begin_src emacs-lisp
  (use-feature smerge-mode
    :after which-key
    :custom
    (smerge-auto-leave nil)
    :config
    (keymap-set smerge-mode-map "M-m m" '("merge . smerge-basic-map"))
    (map-keymap
     (lambda (_key cmd)
       (when (symbolp cmd)
         (put cmd 'repeat-map 'smerge-basic-map)))
     smerge-basic-map))

#+end_src

** Navigation
Moving around within Emacs (buffers, frames, windows, etc.)

*** Winner mode
Capture and restore window configuration

#+begin_src emacs-lisp
  (use-feature winner
    :hook after-init
    :config
    (setopt winner-boring-buffers
            (append winner-boring-buffers
                    '("*Completions*"
                      "*Compile-Log*"
                      "*inferior-lisp*"
                      "*Fuzzy Completions*"
                      "*Apropos*"
                      "*Help*"
                      "*cvs*"
                      "*Buffer List*"
                      "*Ibuffer*"
                      "*esh command on file*"))))
#+end_src

*** Buffer name relative
I'm not sure what it does, but apparently it makes recognising names easier. So, I'll give ~buffer-name-relative~ a go.

#+begin_src emacs-lisp
  (use-package buffer-name-relative
    :hook after-init)
#+end_src

*** Buffer management

**** Better buffer management with bufler.el
Another experiment, apparently https://github.com/alphapapa/buffer.el is the bee's knees

#+begin_src emacs-lisp
  (use-package bufler
    :hook after-init)
#+end_src

**** Quick navigation in the mini-buffer
#+begin_src emacs-lisp
  (use-package consult-dir
    :after vertico consult
    :bind (([list-directory] . consult-dir)
           :map vertico-map
           ("C-x C-d" . consult-dir)
           ("C-x C-j" . consult-dir-jump-file)))

#+end_src

*** Dired
Nicked from Prot: https://protesilaos.com/codelog/2023-06-26-emacs-file-dired-basics/

#+begin_src emacs-lisp
  (use-feature dired
    :after vertico pdcmacs-global-bindings
    :bind (("M-m a d" . dired)
           ("M-m j d" . dired-jump)
           ("M-m j D" . dired-jump-other-window)
           :map dired-mode-map
           (", w"      . wdired-change-to-wdired-mode))
    :config
    (put 'dired-find-alternate-file 'disabled nil)
    :hook
    (after-init . file-name-shadow-mode)
    (rfn-eshadow-update-overlay . vertico-directory-tidy)
    (dired-mode . dired-hide-details-mode)
    :custom
    (dired-dwim-target t)
    (dired-guest-shell-alist-user
     '(("\\.\\(png\\|jpe?g\\|tiff?\\)" "feh" "xdg-open")
       ("\\.\\(mp[34]\\|m4a\\|ogg\\|flac\\|webm\\|mkv\\)" "mpv" "xdg-open")
       (".*" "xdg-open")))
    (dired-recursive-copies 'always)
    (dired-recursive-deletes 'always)
    (dired-use-ls-dired nil)
    (dired-omit-file-p t)
    (dired-omit-files "^\\.?#"))

  (use-feature dired-x
    :commands (dired-jump dired-jump-other-window dired-omit-mode))

#+end_src

*** Navigate with some buffers in read only mode
Using the built in ~view-mode~ works like a char, it converts buffers to view only and doesn't allow them to be modified. The following added behaviour is nicked from http://yummymelon.com/devnull/enhancing-navigation-in-emacs-view-mode.html.

#+begin_src emacs-lisp
  (use-feature view
    :hook (view-mode . pdc/view-mode-hook)
    :preface
    (defun pdc/view-mode-hook ()
      (cond ((derived-mode-p 'org-mode)
             (define-key view-mode-map (kbd "p") 'org-previous-visible-heading)
             (define-key view-mode-map (kbd "n") 'org-next-visible-heading))
            ((derived-mode-p 'markdown-mode)
             (define-key view-mode-map (kbd "p") 'markdown-outline-previous)
             (define-key view-mode-map (kbd "n") 'markdown-outline-next))
            ((derived-mode-p 'html-mode)
             (define-key view-mode-map (kbd "p") 'sgml-skip-tag-backward)
             (define-key view-mode-map (kbd "n") 'sgml-skip-tag-forward))
            ((derived-mode-p 'python-mode)
             (define-key view-mode-map (kbd "p") 'python-nav-backward-block)
             (define-key view-mode-map (kbd "n") 'python-nav-forward-block))
            ((derived-mode-p 'emacs-lisp-mode)
             (define-key view-mode-map (kbd "p") 'backward-sexp)
             (define-key view-mode-map (kbd "n") 'forward-sexp))
            ((derived-mode-p 'makefile-mode)
             (define-key view-mode-map (kbd "p") 'makefile-previous-dependency)
             (define-key view-mode-map (kbd "n") 'makefile-next-dependency))
            ((derived-mode-p 'c-mode)
             (define-key view-mode-map (kbd "p") 'c-beginning-of-defun)
             (define-key view-mode-map (kbd "n") 'c-end-of-defun))
            (t
             (define-key view-mode-map (kbd "p") 'scroll-down-command)
             (define-key view-mode-map (kbd "n") 'scroll-up-command)))))

#+end_src

*** Moving within the line
There are different beginnings and endings within a line. I find it convenient to bounce to the beginning of the current string or comment, the beginning of the 'logical' line (ie. just after the indent) and sometimes even to column zero. The ~mwim~ package does most of that, and it's not hard to add functions to support jumping to the beginning and end of strings too.

#+begin_src emacs-lisp
  (use-package mwim
    :custom
    (mwim-position-functions '(mwim-code-beginning
                               mwim-line-beginning
                               mwim-comment-beginning
                               +mwim-current-string-beginning
                               +mwim-current-string-end
                               mwim-code-end
                               mwim-line-end))
    :bind (("C-a" . mwim-beginning)
           ("C-e" . +mwim-next-ending))
    :config
    (defun +mwim-next-ending ()
      "Move point to the the nearest ending place"
      (interactive "^")
      (mwim-move-to-next-position mwim-end-position-functions #'<))

    (defun +mwim-current-string-beginning ()
      "Return position of the beginning of the current string.
  Return nil if not inside a string (or already at the beginning of one)."
      (let* ((syn (syntax-ppss))
             (beg (and (nth 3 syn)
                       (nth 8 syn))))
        (if beg (1+ beg))))


    (defun +mwim-beginning-of-current-string ()
      "Move point of the beginning of the current string.
  If we're not in the body of a string, do nothing."
      (interactive "^")
      (when-let ((string-beg (+mwim-current-string-beginning)))
        (goto-char string-beg)))

    (defun +mwim-current-string-end ()
      "Return position of the end of the current string.
  Return nil if not inside a string (or already at the end of one)."
      (mwim-point-at (+mwim-end-of-current-string)))

    (defun +mwim-end-of-current-string ()
      "Move point to the end of the current string.
  Do nothing if we're not in the body of a string."
      (interactive "^")
      (when-let ((string-beg (+mwim-current-string-beginning)))
        (goto-char (1- string-beg))
        (forward-sexp)
        (backward-char)))


    (push '+mwim-current-string-beginning mwim-beginning-position-functions)

    (push '+mwim-current-string-end mwim-end-position-functions))
#+end_src

** File handling

*** Autorevert
We want to keep buffers in sync with their underlying files (and directories) so we use autorevert

#+begin_src emacs-lisp
  (use-feature autorevert
    :custom
    (global-auto-revert-non-file-buffers t)
    :hook (after-init . global-auto-revert-mode))
#+end_src

*** Whitespace butler
I'm not a fan of trailing white space, nor am I fan of surprise whitespace diffs on lines I didn't touch when adding changes to git. ~ws-butler-mode~ tidies up trailing whitespace on file save, but only on lines I modified. Perfect!

#+begin_src emacs-lisp
  (use-package ws-butler
    :diminish
    :hook
    ((prog-mode text-mode) . ws-butler-mode))
#+end_src

** Editing

*** Spell checking
Trying out ~jinx~ from https://gihub.com/minad/jinx, enabling globally.

#+begin_src emacs-lisp
  (use-package jinx
    :hook (emacs-startup . global-jinx-mode)
    :bind (("M-$" . jinx-correct)
           ("C-M-$" . jinx-languages))
    :custom (jinx-languages "en_GB")
    :config
    (defun +jinx--add-to-abbrev (overlay word)
      "Add abbreviation to `global-abbrev-table`.
  The misspelled word is taken from OVERLAY. WORD is the corrected word."
      (let ((abbrev (buffer-substring-no-properties
                     (overlay-start overlay)
                     (overlay-end overlay))))
        (message "Abbrev: %s -> %s" abbrev word)
        (define-abbrev global-abbrev-table abbrev word)))
    (advice-add 'jinx--correct-replace :before #'+jinx--add-to-abbrev))
#+end_src

*** Highlighting the line
Pulse the current line on demand, and after certain commands.

#+begin_src emacs-lisp
  (defun pulse-line (&rest _)
    "Pulse the current line."
    (pulse-momentary-highlight-one-line (point)))

  (defun pulse-line-command ()
    "Interactively pulse the current line."
    (interactive)
    (pulse-line))

  (defun pdc-reveal-entry ()
    "Reveal Org or Outline entry and pulse the current line."
    (cond
     ((and (eq major-mode 'org-mode)
           (org-at-heading-p))
      (org-show-entry))
     ((and (or (eq major-mode 'outline-mode)
               (bound-and-true-p outline-minor-mode))
           (outline-on-heading-p))
      (outline-show-entry))))

  (dolist (command '(scroll-up-command
                     scroll-down-command
                     recenter-top-bottom
                     other-window))
    (advice-add command :after #'pulse-line))

  (bind-keys
   ("C-c h p" . pulse-line-command))

  (add-hook 'minibuffer-setup-hook #'pulse-line)
  (add-hook 'consult-after-jump-hook (lambda ()
                                       (recenter-top-bottom 0)))
  (add-hook 'consult-after-jump-hook #'pdc-reveal-entry)

  (add-hook 'imenu-after-jump-hook (lambda ()
                                     (recenter-top-bottom 0)))
  (add-hook 'imenu-after-jump-hook #'pdc-reveal-entry)
#+end_src

Some modes are less confusing if the current line is /always/ highlighted though.

#+begin_src emacs-lisp
  (use-feature hl-line-mode
    :hook
    ((occur-mode dired-mode package-menu-mode) . hl-line-mode))
#+end_src

*** Smart Parentheses
Like ~paredit~ but for more modes...

#+begin_src emacs-lisp
  (use-package smartparens
    :hook
    (((org-mode css-mode python-mode) . smartparens-mode)
     (minibuffer-setup . turn-on-smartparens-strict-mode)
     (emacs-startup . show-smartparens-global-mode))
    :config
    (require 'smartparens-config)

    (sp-with-modes '(minibuffer-inactive-mode minibuffer-mode)
      (sp-local-pair "'" nil :actions nil)
      (sp-local-pair "(" nil :wrap "C-("))

    (sp-with-modes 'org-mode
      (sp-local-pair "=" "=" :wrap "C-=")
      (sp-local-pair "/" "/")
      (sp-local-pair "~" "~"))

    (sp-with-modes 'web-mode
      (sp-local-pair "{{#if" "{//if}")
      (sp-local-pair "{{#unless" "{//unless"))

    (sp-with-modes '(tex-mode plain-tex-mode latex-mode)
      (sp-local-tag "i" "\"<" "\">")))
#+end_src

*** Recent files
An emacs builtin, we're just configuring it.

#+begin_src emacs-lisp
  (use-feature recentf
    :hook
    after-init
    (find-file . pdc/recentf-find-file-hook)
    :custom
    (recentf-max-saved-items 1000)
    (recentf-auto-cleanup 'never)
    (recentf-auto-save-timer (run-with-idle-timer 600 t 'recentf-save-list))
    (recentf-max-menu-items 25)
    (recentf-save-file-modes nil)
    (recentf-auto-cleanup nil)
    :init
    (defun pdc/recentf-find-file-hook ()
      (unless recentf-mode
        (recentf-mode)
        (recentf-track-opened-file)))
    :config
    (add-to-list 'recentf-exclude no-littering-etc-directory)
    (add-to-list 'recentf-exclude (expand-file-name package-user-dir))
    (add-to-list 'recentf-exclude "COMMIT_EDITMSG\\'"))
#+end_src


** Programming stuff

*** Syntax checking
I'm trying ~flymake~ for syntax checking.

#+begin_src emacs-lisp
  (use-feature flymake
    :hook prog-mode
    :bind (:map flymake-mode
                ("M-m c n" . flymake-goto-next-error)
                ("M-m c p" . flymake-goto-prev-error)
                ("M-m c l" . flymake-show-buffer-diagnostics)))
#+end_src

*** Add documentation
#+begin_src emacs-lisp
  (use-package eldoc
    :diminish
    :hook (after-init . global-eldoc-mode))
#+end_src

*** Parsing programming languages

Let's try using the built in ~tree-sitter~ for syntax and parsing.

#+begin_src emacs-lisp
  (use-package treesit-auto
    :custom
    (treesit-auto-install 'prompt)
    :config
    (treesit-auto-add-to-auto-mode-alist 'all)
    :hook (after-init . global-treesit-auto-mode))

#+end_src

*** Languages and Frameworks

**** Lisps
Setup some common lisp mode stuff
#+begin_src emacs-lisp
  (defvar lisp-modes '(emacs-lisp-mode
                       inferior-emacs-lisp-mode
                       ielm-mode
                       lisp-mode
                       inferior-lisp-mode
                       lisp-interaction-mode
                       extempore-mode)
    "A list of Lisp style modes.")

  (defvar lisp-mode-hooks
    (dolist (it lisp-modes)
      (intern (concat (symbol-name it) "-hook")))
    "Hook variables associated with `lisp-modes'.")
#+end_src

***** Paredit

Paredit is an excellent mode for working in Lisps. At its simplest it 'just' keeps parens balanced and ensures your lisp is always well formed, but it comes into its own once you start needing to fiddle with the structure of code.

I've also added a bit of extra cleverness around what happens after closing a sexp. An early version of paredit used to insert a newline after closing parens, but roll that back if the next character you typed was a space. I liked that behaviour, so when paredit removed the behaviour (presumably because it was too surprising), I added it back in.

Also, paredit and ~embark~ fight a little, so added a hook to add ~paredit-mode~'s bindings to ~minor-mode-overriding-map-alist~. My approach is almost certainly overkill, but it works, which is what matters.

#+begin_src emacs-lisp
  (use-package paredit
    :diminish "Ⓟ "
    :bind
    (:map paredit-mode-map
          ("DEL"   . pdc/paredit-backward-delete)
          ("("     . pdc/paredit-open-parenthesis)
          (")"     . paredit-close-round-and-newline)
          ("M-)"   . paredit-close-round)
          ("C-M-l" . paredit-recenter-on-sexp)
          ("C-M-s" . paredit-backward-up)
          ("M-I"   . paredit-splice-sexp)
          ("]"     . paredit-close-square-and-newline)
          ("}"     . paredit-close-curly-and-newline)
          (";"     . pdc/paredit-semicolon))

    :config
    (defun pdc/paredit-backward-delete ()
      (interactive)
      (if mark-active
          (call-interactively 'delete-region)
        (paredit-backward-delete)))

    (defun pdc/paredit-semicolon (&optional n)
      (interactive "P")
      (when (looking-at-p "  +\(")
        (search-forward "(")
        (backward-char))
      (cond ((and n (not (= 1 n)))
             (paredit-semicolon n))
            ((and (equal last-command this-command)
                  (looking-back "; " 2))
             (undo)
             (self-insert-command 1))
            ((or (looking-back ";" 1)
                 (and (looking-at-p "[[:blank:]]*$")
                      (not (save-excursion
                             (beginning-of-line)
                             (looking-at-p "[[:blank:]]*$")))))

             (self-insert-command (or n 1)))

            ((and (not mark-active)
                  (looking-at-p "^[[:blank:]]*$"))
             (insert ";;; "))
            ((and (not mark-active)
                  (save-excursion
                    (beginning-of-line)
                    (looking-at-p "[[:blank:]]*$")))
             (insert ";; "))
            (t (paredit-semicolon n))))

    (defun pdc/in-string-p ()
      (eq 'string (syntax-ppss-context (syntax-ppss))))

    (defun pdc/in-comment-p ()
      (eq 'comment (syntax-ppss-context (syntax-ppss))))

    (defun pdc/paredit-open-parenthesis (&optional n)
      (interactive "P")
      (cond ((and (looking-back "\(" 1)
                  (looking-at "\)"))
             (paredit-open-parenthesis n))
            ((equal last-command this-command)
             (undo)
             (insert " ")
             (backward-char 1)
             (paredit-open-parenthesis n))
            ((and (not (or mark-active (pdc/in-string-p)))
                  (looking-at-p "[\(a-z\"#\\[{]"))
             (mark-sexp)
             (paredit-open-parenthesis n)
             (when (looking-at-p "[\(\"#\\[{]")
               (save-excursion (insert " "))))
            (t (paredit-open-parenthesis n))))

    (defvar +paredit--post-close-keymap (make-sparse-keymap))
    (general-define-key :keymaps '+paredit--post-close-keymap
                        "SPC" (lambda () (interactive) (just-one-space -1))
                        "RET" (lambda () (interactive))
                        "DEL" (lambda ()
                                (interactive)
                                (delete-all-space t)))

    (defun pdc/enable-post-close-keymap ()
      (set-transient-map +paredit--post-close-keymap))

    (dolist (closer '(paredit-close-square-and-newline
                      paredit-close-round-and-newline
                      paredit-close-curly-and-newline
                      paredit-close-angled-and-newline))
      (advice-add closer :after 'pdc/enable-post-close-keymap))

    (defun +paredit-maybe-close-doublequote-and-newline (&optional n)
      (cond ((and (paredit-in-string-p)
                  (eq (point) (- (paredit-enclosing-string-end) 1)))
             (forward-char)
             (let ((comment.point (paredit-find-comment-on-line)))
               (newline)
               (if comment.point
                   (save-excursion
                     (forward-line -1)
                     (end-of-line)
                     (indent-to (cdr comment.point))
                     (insert (car comment.point))))
               (lisp-indent-line)
               (paredit-ignore-sexp-errors (indent-sexp))
               (pdc/enable-post-close-keymap)
               t))
            (t nil)))

    (advice-add 'paredit-doublequote :before-until '+paredit-maybe-close-doublequote-and-newline)

    :preface
    (defun pdc/prioritise-paredit-bindings ()
      (push (assoc 'paredit-mode minor-mode-map-alist)
            minor-mode-overriding-map-alist))

    :hook
    (paredit-mode . pdc/prioritise-paredit-bindings)
                                          ; (paredit-mode . (lambda () (if (fboundp 'lispy-mode) (lispy-mode))))
    ((lisp-mode scheme-mode racket-mode emacs-lisp-mode) . enable-paredit-mode))
#+end_src

***** Emacs Lisp
Especially in text mode emacs, modeline space is at a premium, so we shorten ~mode-name~.
#+begin_src emacs-lisp
  (use-feature elisp-mode
    :init
    (defun pdc/elisp-mode-hook ()
      (setq mode-name "λ(e)"))
    :hook
    (emacs-lisp-mode . pdc/elisp-mode-hook))
#+end_src

****** Display evaluation results as overlays
~eros-mode~ displays elisp evaluation results as an overlay, which is a little neater than the default behaviour.
#+begin_src emacs-lisp
  (use-package eros
    :hook (after-init . eros-mode))
#+end_src

****** Macro expansion

We use ~macrostep~ to examine macro expansion in Emacs Lisp buffers.

#+begin_src emacs-lisp
  (use-package macrostep
    :bind
    (:map emacs-lisp-mode-map
          :prefix "M-m ,"
          :prefix-map leader/mode/elisp-map
          :prefix-docstring "mode(elisp)"
          ("e" . macrostep-expand)))
#+end_src

** Load extra configuration and customizations

The pre-literate version of this file separated initialization into ~init.el~ and ~config.el~ file, so we need to load ~config.el~ and then any customizations. However, eventually, the plan is to eliminate ~config.el~ entirely.


#+begin_src emacs-lisp
  (when (file-exists-p pdcmacs-config-file)
    (load pdcmacs-config-file))

  (when (file-exists-p custom-file)
    (load custom-file))
#+end_src


# Local Variables:
# truncate-lines: nil
# word-wrap: t
# End:
